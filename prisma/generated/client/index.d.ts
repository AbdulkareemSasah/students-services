
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Global
 * 
 */
export type Global = $Result.DefaultSelection<Prisma.$GlobalPayload>
/**
 * Model GlobalTranslation
 * 
 */
export type GlobalTranslation = $Result.DefaultSelection<Prisma.$GlobalTranslationPayload>
/**
 * Model SocialLink
 * 
 */
export type SocialLink = $Result.DefaultSelection<Prisma.$SocialLinkPayload>
/**
 * Model NavbarItem
 * 
 */
export type NavbarItem = $Result.DefaultSelection<Prisma.$NavbarItemPayload>
/**
 * Model NavbarItemTranslation
 * 
 */
export type NavbarItemTranslation = $Result.DefaultSelection<Prisma.$NavbarItemTranslationPayload>
/**
 * Model DropDownGroup
 * 
 */
export type DropDownGroup = $Result.DefaultSelection<Prisma.$DropDownGroupPayload>
/**
 * Model DropDownGroupTranslation
 * 
 */
export type DropDownGroupTranslation = $Result.DefaultSelection<Prisma.$DropDownGroupTranslationPayload>
/**
 * Model DropdownItem
 * 
 */
export type DropdownItem = $Result.DefaultSelection<Prisma.$DropdownItemPayload>
/**
 * Model DropdownItemTranslation
 * 
 */
export type DropdownItemTranslation = $Result.DefaultSelection<Prisma.$DropdownItemTranslationPayload>
/**
 * Model Footer
 * 
 */
export type Footer = $Result.DefaultSelection<Prisma.$FooterPayload>
/**
 * Model FooterTranslation
 * 
 */
export type FooterTranslation = $Result.DefaultSelection<Prisma.$FooterTranslationPayload>
/**
 * Model GroupFooter
 * 
 */
export type GroupFooter = $Result.DefaultSelection<Prisma.$GroupFooterPayload>
/**
 * Model GroupFooterTranslation
 * 
 */
export type GroupFooterTranslation = $Result.DefaultSelection<Prisma.$GroupFooterTranslationPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model PageTranslation
 * 
 */
export type PageTranslation = $Result.DefaultSelection<Prisma.$PageTranslationPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model CategoryTranslation
 * 
 */
export type CategoryTranslation = $Result.DefaultSelection<Prisma.$CategoryTranslationPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model ArticleTranslation
 * 
 */
export type ArticleTranslation = $Result.DefaultSelection<Prisma.$ArticleTranslationPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagTranslation
 * 
 */
export type TagTranslation = $Result.DefaultSelection<Prisma.$TagTranslationPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentTranslation
 * 
 */
export type CommentTranslation = $Result.DefaultSelection<Prisma.$CommentTranslationPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model CategoryService
 * 
 */
export type CategoryService = $Result.DefaultSelection<Prisma.$CategoryServicePayload>
/**
 * Model CategoryServiceTranslation
 * 
 */
export type CategoryServiceTranslation = $Result.DefaultSelection<Prisma.$CategoryServiceTranslationPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceTranslation
 * 
 */
export type ServiceTranslation = $Result.DefaultSelection<Prisma.$ServiceTranslationPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  AUTHER: 'AUTHER',
  ADMIN: 'ADMIN',
  SUPERUSER: 'SUPERUSER'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.global`: Exposes CRUD operations for the **Global** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Globals
    * const globals = await prisma.global.findMany()
    * ```
    */
  get global(): Prisma.GlobalDelegate<ExtArgs>;

  /**
   * `prisma.globalTranslation`: Exposes CRUD operations for the **GlobalTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalTranslations
    * const globalTranslations = await prisma.globalTranslation.findMany()
    * ```
    */
  get globalTranslation(): Prisma.GlobalTranslationDelegate<ExtArgs>;

  /**
   * `prisma.socialLink`: Exposes CRUD operations for the **SocialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLink.findMany()
    * ```
    */
  get socialLink(): Prisma.SocialLinkDelegate<ExtArgs>;

  /**
   * `prisma.navbarItem`: Exposes CRUD operations for the **NavbarItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavbarItems
    * const navbarItems = await prisma.navbarItem.findMany()
    * ```
    */
  get navbarItem(): Prisma.NavbarItemDelegate<ExtArgs>;

  /**
   * `prisma.navbarItemTranslation`: Exposes CRUD operations for the **NavbarItemTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavbarItemTranslations
    * const navbarItemTranslations = await prisma.navbarItemTranslation.findMany()
    * ```
    */
  get navbarItemTranslation(): Prisma.NavbarItemTranslationDelegate<ExtArgs>;

  /**
   * `prisma.dropDownGroup`: Exposes CRUD operations for the **DropDownGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropDownGroups
    * const dropDownGroups = await prisma.dropDownGroup.findMany()
    * ```
    */
  get dropDownGroup(): Prisma.DropDownGroupDelegate<ExtArgs>;

  /**
   * `prisma.dropDownGroupTranslation`: Exposes CRUD operations for the **DropDownGroupTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropDownGroupTranslations
    * const dropDownGroupTranslations = await prisma.dropDownGroupTranslation.findMany()
    * ```
    */
  get dropDownGroupTranslation(): Prisma.DropDownGroupTranslationDelegate<ExtArgs>;

  /**
   * `prisma.dropdownItem`: Exposes CRUD operations for the **DropdownItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropdownItems
    * const dropdownItems = await prisma.dropdownItem.findMany()
    * ```
    */
  get dropdownItem(): Prisma.DropdownItemDelegate<ExtArgs>;

  /**
   * `prisma.dropdownItemTranslation`: Exposes CRUD operations for the **DropdownItemTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropdownItemTranslations
    * const dropdownItemTranslations = await prisma.dropdownItemTranslation.findMany()
    * ```
    */
  get dropdownItemTranslation(): Prisma.DropdownItemTranslationDelegate<ExtArgs>;

  /**
   * `prisma.footer`: Exposes CRUD operations for the **Footer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Footers
    * const footers = await prisma.footer.findMany()
    * ```
    */
  get footer(): Prisma.FooterDelegate<ExtArgs>;

  /**
   * `prisma.footerTranslation`: Exposes CRUD operations for the **FooterTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FooterTranslations
    * const footerTranslations = await prisma.footerTranslation.findMany()
    * ```
    */
  get footerTranslation(): Prisma.FooterTranslationDelegate<ExtArgs>;

  /**
   * `prisma.groupFooter`: Exposes CRUD operations for the **GroupFooter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupFooters
    * const groupFooters = await prisma.groupFooter.findMany()
    * ```
    */
  get groupFooter(): Prisma.GroupFooterDelegate<ExtArgs>;

  /**
   * `prisma.groupFooterTranslation`: Exposes CRUD operations for the **GroupFooterTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupFooterTranslations
    * const groupFooterTranslations = await prisma.groupFooterTranslation.findMany()
    * ```
    */
  get groupFooterTranslation(): Prisma.GroupFooterTranslationDelegate<ExtArgs>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs>;

  /**
   * `prisma.pageTranslation`: Exposes CRUD operations for the **PageTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageTranslations
    * const pageTranslations = await prisma.pageTranslation.findMany()
    * ```
    */
  get pageTranslation(): Prisma.PageTranslationDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.categoryTranslation`: Exposes CRUD operations for the **CategoryTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryTranslations
    * const categoryTranslations = await prisma.categoryTranslation.findMany()
    * ```
    */
  get categoryTranslation(): Prisma.CategoryTranslationDelegate<ExtArgs>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs>;

  /**
   * `prisma.articleTranslation`: Exposes CRUD operations for the **ArticleTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleTranslations
    * const articleTranslations = await prisma.articleTranslation.findMany()
    * ```
    */
  get articleTranslation(): Prisma.ArticleTranslationDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.tagTranslation`: Exposes CRUD operations for the **TagTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagTranslations
    * const tagTranslations = await prisma.tagTranslation.findMany()
    * ```
    */
  get tagTranslation(): Prisma.TagTranslationDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.commentTranslation`: Exposes CRUD operations for the **CommentTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentTranslations
    * const commentTranslations = await prisma.commentTranslation.findMany()
    * ```
    */
  get commentTranslation(): Prisma.CommentTranslationDelegate<ExtArgs>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs>;

  /**
   * `prisma.categoryService`: Exposes CRUD operations for the **CategoryService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryServices
    * const categoryServices = await prisma.categoryService.findMany()
    * ```
    */
  get categoryService(): Prisma.CategoryServiceDelegate<ExtArgs>;

  /**
   * `prisma.categoryServiceTranslation`: Exposes CRUD operations for the **CategoryServiceTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryServiceTranslations
    * const categoryServiceTranslations = await prisma.categoryServiceTranslation.findMany()
    * ```
    */
  get categoryServiceTranslation(): Prisma.CategoryServiceTranslationDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.serviceTranslation`: Exposes CRUD operations for the **ServiceTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTranslations
    * const serviceTranslations = await prisma.serviceTranslation.findMany()
    * ```
    */
  get serviceTranslation(): Prisma.ServiceTranslationDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: ac9d7041ed77bcc8a8dbd2ab6616b39013829574
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Language: 'Language',
    Global: 'Global',
    GlobalTranslation: 'GlobalTranslation',
    SocialLink: 'SocialLink',
    NavbarItem: 'NavbarItem',
    NavbarItemTranslation: 'NavbarItemTranslation',
    DropDownGroup: 'DropDownGroup',
    DropDownGroupTranslation: 'DropDownGroupTranslation',
    DropdownItem: 'DropdownItem',
    DropdownItemTranslation: 'DropdownItemTranslation',
    Footer: 'Footer',
    FooterTranslation: 'FooterTranslation',
    GroupFooter: 'GroupFooter',
    GroupFooterTranslation: 'GroupFooterTranslation',
    Page: 'Page',
    PageTranslation: 'PageTranslation',
    Category: 'Category',
    CategoryTranslation: 'CategoryTranslation',
    Article: 'Article',
    ArticleTranslation: 'ArticleTranslation',
    Tag: 'Tag',
    TagTranslation: 'TagTranslation',
    Comment: 'Comment',
    CommentTranslation: 'CommentTranslation',
    Block: 'Block',
    CategoryService: 'CategoryService',
    CategoryServiceTranslation: 'CategoryServiceTranslation',
    Service: 'Service',
    ServiceTranslation: 'ServiceTranslation',
    Order: 'Order'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'session' | 'user' | 'verificationToken' | 'language' | 'global' | 'globalTranslation' | 'socialLink' | 'navbarItem' | 'navbarItemTranslation' | 'dropDownGroup' | 'dropDownGroupTranslation' | 'dropdownItem' | 'dropdownItemTranslation' | 'footer' | 'footerTranslation' | 'groupFooter' | 'groupFooterTranslation' | 'page' | 'pageTranslation' | 'category' | 'categoryTranslation' | 'article' | 'articleTranslation' | 'tag' | 'tagTranslation' | 'comment' | 'commentTranslation' | 'block' | 'categoryService' | 'categoryServiceTranslation' | 'service' | 'serviceTranslation' | 'order'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>,
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Global: {
        payload: Prisma.$GlobalPayload<ExtArgs>
        fields: Prisma.GlobalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>
          }
          findFirst: {
            args: Prisma.GlobalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>
          }
          findMany: {
            args: Prisma.GlobalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>[]
          }
          create: {
            args: Prisma.GlobalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>
          }
          createMany: {
            args: Prisma.GlobalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GlobalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>
          }
          update: {
            args: Prisma.GlobalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>
          }
          deleteMany: {
            args: Prisma.GlobalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GlobalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalPayload>
          }
          aggregate: {
            args: Prisma.GlobalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGlobal>
          }
          groupBy: {
            args: Prisma.GlobalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GlobalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalCountArgs<ExtArgs>,
            result: $Utils.Optional<GlobalCountAggregateOutputType> | number
          }
        }
      }
      GlobalTranslation: {
        payload: Prisma.$GlobalTranslationPayload<ExtArgs>
        fields: Prisma.GlobalTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>
          }
          findFirst: {
            args: Prisma.GlobalTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>
          }
          findMany: {
            args: Prisma.GlobalTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>[]
          }
          create: {
            args: Prisma.GlobalTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>
          }
          createMany: {
            args: Prisma.GlobalTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GlobalTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>
          }
          update: {
            args: Prisma.GlobalTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>
          }
          deleteMany: {
            args: Prisma.GlobalTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GlobalTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GlobalTranslationPayload>
          }
          aggregate: {
            args: Prisma.GlobalTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGlobalTranslation>
          }
          groupBy: {
            args: Prisma.GlobalTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GlobalTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<GlobalTranslationCountAggregateOutputType> | number
          }
        }
      }
      SocialLink: {
        payload: Prisma.$SocialLinkPayload<ExtArgs>
        fields: Prisma.SocialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLinkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLinkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findFirst: {
            args: Prisma.SocialLinkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLinkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findMany: {
            args: Prisma.SocialLinkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          create: {
            args: Prisma.SocialLinkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          createMany: {
            args: Prisma.SocialLinkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SocialLinkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          update: {
            args: Prisma.SocialLinkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          deleteMany: {
            args: Prisma.SocialLinkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLinkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SocialLinkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          aggregate: {
            args: Prisma.SocialLinkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSocialLink>
          }
          groupBy: {
            args: Prisma.SocialLinkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLinkCountArgs<ExtArgs>,
            result: $Utils.Optional<SocialLinkCountAggregateOutputType> | number
          }
        }
      }
      NavbarItem: {
        payload: Prisma.$NavbarItemPayload<ExtArgs>
        fields: Prisma.NavbarItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavbarItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavbarItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>
          }
          findFirst: {
            args: Prisma.NavbarItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavbarItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>
          }
          findMany: {
            args: Prisma.NavbarItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>[]
          }
          create: {
            args: Prisma.NavbarItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>
          }
          createMany: {
            args: Prisma.NavbarItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NavbarItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>
          }
          update: {
            args: Prisma.NavbarItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>
          }
          deleteMany: {
            args: Prisma.NavbarItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NavbarItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NavbarItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemPayload>
          }
          aggregate: {
            args: Prisma.NavbarItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNavbarItem>
          }
          groupBy: {
            args: Prisma.NavbarItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NavbarItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavbarItemCountArgs<ExtArgs>,
            result: $Utils.Optional<NavbarItemCountAggregateOutputType> | number
          }
        }
      }
      NavbarItemTranslation: {
        payload: Prisma.$NavbarItemTranslationPayload<ExtArgs>
        fields: Prisma.NavbarItemTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavbarItemTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavbarItemTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>
          }
          findFirst: {
            args: Prisma.NavbarItemTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavbarItemTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>
          }
          findMany: {
            args: Prisma.NavbarItemTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>[]
          }
          create: {
            args: Prisma.NavbarItemTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>
          }
          createMany: {
            args: Prisma.NavbarItemTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NavbarItemTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>
          }
          update: {
            args: Prisma.NavbarItemTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>
          }
          deleteMany: {
            args: Prisma.NavbarItemTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NavbarItemTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NavbarItemTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavbarItemTranslationPayload>
          }
          aggregate: {
            args: Prisma.NavbarItemTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNavbarItemTranslation>
          }
          groupBy: {
            args: Prisma.NavbarItemTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NavbarItemTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavbarItemTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<NavbarItemTranslationCountAggregateOutputType> | number
          }
        }
      }
      DropDownGroup: {
        payload: Prisma.$DropDownGroupPayload<ExtArgs>
        fields: Prisma.DropDownGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropDownGroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropDownGroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>
          }
          findFirst: {
            args: Prisma.DropDownGroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropDownGroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>
          }
          findMany: {
            args: Prisma.DropDownGroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>[]
          }
          create: {
            args: Prisma.DropDownGroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>
          }
          createMany: {
            args: Prisma.DropDownGroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DropDownGroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>
          }
          update: {
            args: Prisma.DropDownGroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>
          }
          deleteMany: {
            args: Prisma.DropDownGroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DropDownGroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DropDownGroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupPayload>
          }
          aggregate: {
            args: Prisma.DropDownGroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDropDownGroup>
          }
          groupBy: {
            args: Prisma.DropDownGroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DropDownGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.DropDownGroupCountArgs<ExtArgs>,
            result: $Utils.Optional<DropDownGroupCountAggregateOutputType> | number
          }
        }
      }
      DropDownGroupTranslation: {
        payload: Prisma.$DropDownGroupTranslationPayload<ExtArgs>
        fields: Prisma.DropDownGroupTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropDownGroupTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropDownGroupTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>
          }
          findFirst: {
            args: Prisma.DropDownGroupTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropDownGroupTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>
          }
          findMany: {
            args: Prisma.DropDownGroupTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>[]
          }
          create: {
            args: Prisma.DropDownGroupTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>
          }
          createMany: {
            args: Prisma.DropDownGroupTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DropDownGroupTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>
          }
          update: {
            args: Prisma.DropDownGroupTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>
          }
          deleteMany: {
            args: Prisma.DropDownGroupTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DropDownGroupTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DropDownGroupTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropDownGroupTranslationPayload>
          }
          aggregate: {
            args: Prisma.DropDownGroupTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDropDownGroupTranslation>
          }
          groupBy: {
            args: Prisma.DropDownGroupTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DropDownGroupTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DropDownGroupTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<DropDownGroupTranslationCountAggregateOutputType> | number
          }
        }
      }
      DropdownItem: {
        payload: Prisma.$DropdownItemPayload<ExtArgs>
        fields: Prisma.DropdownItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropdownItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropdownItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>
          }
          findFirst: {
            args: Prisma.DropdownItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropdownItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>
          }
          findMany: {
            args: Prisma.DropdownItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>[]
          }
          create: {
            args: Prisma.DropdownItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>
          }
          createMany: {
            args: Prisma.DropdownItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DropdownItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>
          }
          update: {
            args: Prisma.DropdownItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>
          }
          deleteMany: {
            args: Prisma.DropdownItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DropdownItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DropdownItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemPayload>
          }
          aggregate: {
            args: Prisma.DropdownItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDropdownItem>
          }
          groupBy: {
            args: Prisma.DropdownItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DropdownItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DropdownItemCountArgs<ExtArgs>,
            result: $Utils.Optional<DropdownItemCountAggregateOutputType> | number
          }
        }
      }
      DropdownItemTranslation: {
        payload: Prisma.$DropdownItemTranslationPayload<ExtArgs>
        fields: Prisma.DropdownItemTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropdownItemTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropdownItemTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>
          }
          findFirst: {
            args: Prisma.DropdownItemTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropdownItemTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>
          }
          findMany: {
            args: Prisma.DropdownItemTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>[]
          }
          create: {
            args: Prisma.DropdownItemTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>
          }
          createMany: {
            args: Prisma.DropdownItemTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DropdownItemTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>
          }
          update: {
            args: Prisma.DropdownItemTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>
          }
          deleteMany: {
            args: Prisma.DropdownItemTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DropdownItemTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DropdownItemTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropdownItemTranslationPayload>
          }
          aggregate: {
            args: Prisma.DropdownItemTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDropdownItemTranslation>
          }
          groupBy: {
            args: Prisma.DropdownItemTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DropdownItemTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DropdownItemTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<DropdownItemTranslationCountAggregateOutputType> | number
          }
        }
      }
      Footer: {
        payload: Prisma.$FooterPayload<ExtArgs>
        fields: Prisma.FooterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FooterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FooterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          findFirst: {
            args: Prisma.FooterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FooterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          findMany: {
            args: Prisma.FooterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>[]
          }
          create: {
            args: Prisma.FooterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          createMany: {
            args: Prisma.FooterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FooterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          update: {
            args: Prisma.FooterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          deleteMany: {
            args: Prisma.FooterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FooterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FooterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          aggregate: {
            args: Prisma.FooterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFooter>
          }
          groupBy: {
            args: Prisma.FooterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FooterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FooterCountArgs<ExtArgs>,
            result: $Utils.Optional<FooterCountAggregateOutputType> | number
          }
        }
      }
      FooterTranslation: {
        payload: Prisma.$FooterTranslationPayload<ExtArgs>
        fields: Prisma.FooterTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FooterTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FooterTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>
          }
          findFirst: {
            args: Prisma.FooterTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FooterTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>
          }
          findMany: {
            args: Prisma.FooterTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>[]
          }
          create: {
            args: Prisma.FooterTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>
          }
          createMany: {
            args: Prisma.FooterTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FooterTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>
          }
          update: {
            args: Prisma.FooterTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>
          }
          deleteMany: {
            args: Prisma.FooterTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FooterTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FooterTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FooterTranslationPayload>
          }
          aggregate: {
            args: Prisma.FooterTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFooterTranslation>
          }
          groupBy: {
            args: Prisma.FooterTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FooterTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FooterTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<FooterTranslationCountAggregateOutputType> | number
          }
        }
      }
      GroupFooter: {
        payload: Prisma.$GroupFooterPayload<ExtArgs>
        fields: Prisma.GroupFooterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFooterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFooterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>
          }
          findFirst: {
            args: Prisma.GroupFooterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFooterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>
          }
          findMany: {
            args: Prisma.GroupFooterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>[]
          }
          create: {
            args: Prisma.GroupFooterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>
          }
          createMany: {
            args: Prisma.GroupFooterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GroupFooterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>
          }
          update: {
            args: Prisma.GroupFooterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>
          }
          deleteMany: {
            args: Prisma.GroupFooterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GroupFooterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GroupFooterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterPayload>
          }
          aggregate: {
            args: Prisma.GroupFooterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroupFooter>
          }
          groupBy: {
            args: Prisma.GroupFooterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupFooterGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupFooterCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupFooterCountAggregateOutputType> | number
          }
        }
      }
      GroupFooterTranslation: {
        payload: Prisma.$GroupFooterTranslationPayload<ExtArgs>
        fields: Prisma.GroupFooterTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFooterTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFooterTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>
          }
          findFirst: {
            args: Prisma.GroupFooterTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFooterTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>
          }
          findMany: {
            args: Prisma.GroupFooterTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>[]
          }
          create: {
            args: Prisma.GroupFooterTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>
          }
          createMany: {
            args: Prisma.GroupFooterTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GroupFooterTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>
          }
          update: {
            args: Prisma.GroupFooterTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>
          }
          deleteMany: {
            args: Prisma.GroupFooterTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GroupFooterTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GroupFooterTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupFooterTranslationPayload>
          }
          aggregate: {
            args: Prisma.GroupFooterTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroupFooterTranslation>
          }
          groupBy: {
            args: Prisma.GroupFooterTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupFooterTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupFooterTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupFooterTranslationCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>,
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      PageTranslation: {
        payload: Prisma.$PageTranslationPayload<ExtArgs>
        fields: Prisma.PageTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          findFirst: {
            args: Prisma.PageTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          findMany: {
            args: Prisma.PageTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
          }
          create: {
            args: Prisma.PageTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          createMany: {
            args: Prisma.PageTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PageTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          update: {
            args: Prisma.PageTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          deleteMany: {
            args: Prisma.PageTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PageTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PageTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          aggregate: {
            args: Prisma.PageTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePageTranslation>
          }
          groupBy: {
            args: Prisma.PageTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PageTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<PageTranslationCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      CategoryTranslation: {
        payload: Prisma.$CategoryTranslationPayload<ExtArgs>
        fields: Prisma.CategoryTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          findFirst: {
            args: Prisma.CategoryTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          findMany: {
            args: Prisma.CategoryTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          create: {
            args: Prisma.CategoryTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          createMany: {
            args: Prisma.CategoryTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          update: {
            args: Prisma.CategoryTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          deleteMany: {
            args: Prisma.CategoryTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          aggregate: {
            args: Prisma.CategoryTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoryTranslation>
          }
          groupBy: {
            args: Prisma.CategoryTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryTranslationCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>,
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      ArticleTranslation: {
        payload: Prisma.$ArticleTranslationPayload<ExtArgs>
        fields: Prisma.ArticleTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          findFirst: {
            args: Prisma.ArticleTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          findMany: {
            args: Prisma.ArticleTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>[]
          }
          create: {
            args: Prisma.ArticleTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          createMany: {
            args: Prisma.ArticleTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArticleTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          update: {
            args: Prisma.ArticleTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ArticleTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArticleTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          aggregate: {
            args: Prisma.ArticleTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArticleTranslation>
          }
          groupBy: {
            args: Prisma.ArticleTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArticleTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<ArticleTranslationCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagTranslation: {
        payload: Prisma.$TagTranslationPayload<ExtArgs>
        fields: Prisma.TagTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          findFirst: {
            args: Prisma.TagTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          findMany: {
            args: Prisma.TagTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>[]
          }
          create: {
            args: Prisma.TagTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          createMany: {
            args: Prisma.TagTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          update: {
            args: Prisma.TagTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          deleteMany: {
            args: Prisma.TagTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          aggregate: {
            args: Prisma.TagTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTagTranslation>
          }
          groupBy: {
            args: Prisma.TagTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<TagTranslationCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentTranslation: {
        payload: Prisma.$CommentTranslationPayload<ExtArgs>
        fields: Prisma.CommentTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>
          }
          findFirst: {
            args: Prisma.CommentTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>
          }
          findMany: {
            args: Prisma.CommentTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>[]
          }
          create: {
            args: Prisma.CommentTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>
          }
          createMany: {
            args: Prisma.CommentTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>
          }
          update: {
            args: Prisma.CommentTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>
          }
          deleteMany: {
            args: Prisma.CommentTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentTranslationPayload>
          }
          aggregate: {
            args: Prisma.CommentTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommentTranslation>
          }
          groupBy: {
            args: Prisma.CommentTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentTranslationCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>,
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      CategoryService: {
        payload: Prisma.$CategoryServicePayload<ExtArgs>
        fields: Prisma.CategoryServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>
          }
          findFirst: {
            args: Prisma.CategoryServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>
          }
          findMany: {
            args: Prisma.CategoryServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>[]
          }
          create: {
            args: Prisma.CategoryServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>
          }
          createMany: {
            args: Prisma.CategoryServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>
          }
          update: {
            args: Prisma.CategoryServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>
          }
          deleteMany: {
            args: Prisma.CategoryServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServicePayload>
          }
          aggregate: {
            args: Prisma.CategoryServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoryService>
          }
          groupBy: {
            args: Prisma.CategoryServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryServiceCountAggregateOutputType> | number
          }
        }
      }
      CategoryServiceTranslation: {
        payload: Prisma.$CategoryServiceTranslationPayload<ExtArgs>
        fields: Prisma.CategoryServiceTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryServiceTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryServiceTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>
          }
          findFirst: {
            args: Prisma.CategoryServiceTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryServiceTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>
          }
          findMany: {
            args: Prisma.CategoryServiceTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>[]
          }
          create: {
            args: Prisma.CategoryServiceTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>
          }
          createMany: {
            args: Prisma.CategoryServiceTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryServiceTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>
          }
          update: {
            args: Prisma.CategoryServiceTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>
          }
          deleteMany: {
            args: Prisma.CategoryServiceTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryServiceTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryServiceTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryServiceTranslationPayload>
          }
          aggregate: {
            args: Prisma.CategoryServiceTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoryServiceTranslation>
          }
          groupBy: {
            args: Prisma.CategoryServiceTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryServiceTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryServiceTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryServiceTranslationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceTranslation: {
        payload: Prisma.$ServiceTranslationPayload<ExtArgs>
        fields: Prisma.ServiceTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTranslationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTranslationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>
          }
          findFirst: {
            args: Prisma.ServiceTranslationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTranslationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>
          }
          findMany: {
            args: Prisma.ServiceTranslationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>[]
          }
          create: {
            args: Prisma.ServiceTranslationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>
          }
          createMany: {
            args: Prisma.ServiceTranslationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceTranslationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>
          }
          update: {
            args: Prisma.ServiceTranslationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ServiceTranslationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTranslationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceTranslationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiceTranslationPayload>
          }
          aggregate: {
            args: Prisma.ServiceTranslationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceTranslation>
          }
          groupBy: {
            args: Prisma.ServiceTranslationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTranslationCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceTranslationCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    pages: number
    articles: number
    categories: number
    Comment: number
    orders: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    pages?: boolean | UserCountOutputTypeCountPagesArgs
    articles?: boolean | UserCountOutputTypeCountArticlesArgs
    categories?: boolean | UserCountOutputTypeCountCategoriesArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PageTranslationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleTranslationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentTranslationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }



  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    globals: number
    pages: number
    categoreis: number
    categoriesServices: number
    services: number
    articles: number
    tags: number
    comments: number
    navbarItems: number
    dropdownGroups: number
    dropdownItems: number
    footers: number
    groupFooters: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    globals?: boolean | LanguageCountOutputTypeCountGlobalsArgs
    pages?: boolean | LanguageCountOutputTypeCountPagesArgs
    categoreis?: boolean | LanguageCountOutputTypeCountCategoreisArgs
    categoriesServices?: boolean | LanguageCountOutputTypeCountCategoriesServicesArgs
    services?: boolean | LanguageCountOutputTypeCountServicesArgs
    articles?: boolean | LanguageCountOutputTypeCountArticlesArgs
    tags?: boolean | LanguageCountOutputTypeCountTagsArgs
    comments?: boolean | LanguageCountOutputTypeCountCommentsArgs
    navbarItems?: boolean | LanguageCountOutputTypeCountNavbarItemsArgs
    dropdownGroups?: boolean | LanguageCountOutputTypeCountDropdownGroupsArgs
    dropdownItems?: boolean | LanguageCountOutputTypeCountDropdownItemsArgs
    footers?: boolean | LanguageCountOutputTypeCountFootersArgs
    groupFooters?: boolean | LanguageCountOutputTypeCountGroupFootersArgs
  }

  // Custom InputTypes

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountGlobalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GlobalTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PageTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountCategoreisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountCategoriesServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryServiceTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountNavbarItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NavbarItemTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountDropdownGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropDownGroupTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountDropdownItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropdownItemTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountFootersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FooterTranslationWhereInput
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountGroupFootersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GroupFooterTranslationWhereInput
  }



  /**
   * Count Type GlobalCountOutputType
   */

  export type GlobalCountOutputType = {
    translations: number
    socialLinks: number
  }

  export type GlobalCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | GlobalCountOutputTypeCountTranslationsArgs
    socialLinks?: boolean | GlobalCountOutputTypeCountSocialLinksArgs
  }

  // Custom InputTypes

  /**
   * GlobalCountOutputType without action
   */
  export type GlobalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalCountOutputType
     */
    select?: GlobalCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GlobalCountOutputType without action
   */
  export type GlobalCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GlobalTranslationWhereInput
  }


  /**
   * GlobalCountOutputType without action
   */
  export type GlobalCountOutputTypeCountSocialLinksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
  }



  /**
   * Count Type NavbarItemCountOutputType
   */

  export type NavbarItemCountOutputType = {
    translations: number
    dropdownGroups: number
    dropdownItems: number
  }

  export type NavbarItemCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | NavbarItemCountOutputTypeCountTranslationsArgs
    dropdownGroups?: boolean | NavbarItemCountOutputTypeCountDropdownGroupsArgs
    dropdownItems?: boolean | NavbarItemCountOutputTypeCountDropdownItemsArgs
  }

  // Custom InputTypes

  /**
   * NavbarItemCountOutputType without action
   */
  export type NavbarItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemCountOutputType
     */
    select?: NavbarItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NavbarItemCountOutputType without action
   */
  export type NavbarItemCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NavbarItemTranslationWhereInput
  }


  /**
   * NavbarItemCountOutputType without action
   */
  export type NavbarItemCountOutputTypeCountDropdownGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropDownGroupWhereInput
  }


  /**
   * NavbarItemCountOutputType without action
   */
  export type NavbarItemCountOutputTypeCountDropdownItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropdownItemWhereInput
  }



  /**
   * Count Type DropDownGroupCountOutputType
   */

  export type DropDownGroupCountOutputType = {
    translations: number
    dropdownItems: number
  }

  export type DropDownGroupCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | DropDownGroupCountOutputTypeCountTranslationsArgs
    dropdownItems?: boolean | DropDownGroupCountOutputTypeCountDropdownItemsArgs
  }

  // Custom InputTypes

  /**
   * DropDownGroupCountOutputType without action
   */
  export type DropDownGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupCountOutputType
     */
    select?: DropDownGroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DropDownGroupCountOutputType without action
   */
  export type DropDownGroupCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropDownGroupTranslationWhereInput
  }


  /**
   * DropDownGroupCountOutputType without action
   */
  export type DropDownGroupCountOutputTypeCountDropdownItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropdownItemWhereInput
  }



  /**
   * Count Type DropdownItemCountOutputType
   */

  export type DropdownItemCountOutputType = {
    translations: number
  }

  export type DropdownItemCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | DropdownItemCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes

  /**
   * DropdownItemCountOutputType without action
   */
  export type DropdownItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemCountOutputType
     */
    select?: DropdownItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DropdownItemCountOutputType without action
   */
  export type DropdownItemCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropdownItemTranslationWhereInput
  }



  /**
   * Count Type FooterCountOutputType
   */

  export type FooterCountOutputType = {
    translations: number
    groups: number
    articles: number
  }

  export type FooterCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | FooterCountOutputTypeCountTranslationsArgs
    groups?: boolean | FooterCountOutputTypeCountGroupsArgs
    articles?: boolean | FooterCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes

  /**
   * FooterCountOutputType without action
   */
  export type FooterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterCountOutputType
     */
    select?: FooterCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FooterCountOutputType without action
   */
  export type FooterCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FooterTranslationWhereInput
  }


  /**
   * FooterCountOutputType without action
   */
  export type FooterCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GroupFooterWhereInput
  }


  /**
   * FooterCountOutputType without action
   */
  export type FooterCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }



  /**
   * Count Type GroupFooterCountOutputType
   */

  export type GroupFooterCountOutputType = {
    translations: number
    articles: number
    pages: number
  }

  export type GroupFooterCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | GroupFooterCountOutputTypeCountTranslationsArgs
    articles?: boolean | GroupFooterCountOutputTypeCountArticlesArgs
    pages?: boolean | GroupFooterCountOutputTypeCountPagesArgs
  }

  // Custom InputTypes

  /**
   * GroupFooterCountOutputType without action
   */
  export type GroupFooterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterCountOutputType
     */
    select?: GroupFooterCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GroupFooterCountOutputType without action
   */
  export type GroupFooterCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GroupFooterTranslationWhereInput
  }


  /**
   * GroupFooterCountOutputType without action
   */
  export type GroupFooterCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }


  /**
   * GroupFooterCountOutputType without action
   */
  export type GroupFooterCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }



  /**
   * Count Type PageCountOutputType
   */

  export type PageCountOutputType = {
    translations: number
  }

  export type PageCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | PageCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageCountOutputType
     */
    select?: PageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PageTranslationWhereInput
  }



  /**
   * Count Type PageTranslationCountOutputType
   */

  export type PageTranslationCountOutputType = {
    blocks: number
  }

  export type PageTranslationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blocks?: boolean | PageTranslationCountOutputTypeCountBlocksArgs
  }

  // Custom InputTypes

  /**
   * PageTranslationCountOutputType without action
   */
  export type PageTranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslationCountOutputType
     */
    select?: PageTranslationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PageTranslationCountOutputType without action
   */
  export type PageTranslationCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    translations: number
    articles: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | CategoryCountOutputTypeCountTranslationsArgs
    articles?: boolean | CategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }



  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    translations: number
    tags: number
    comments: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | ArticleCountOutputTypeCountTranslationsArgs
    tags?: boolean | ArticleCountOutputTypeCountTagsArgs
    comments?: boolean | ArticleCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleTranslationWhereInput
  }


  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type ArticleTranslationCountOutputType
   */

  export type ArticleTranslationCountOutputType = {
    blocks: number
  }

  export type ArticleTranslationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blocks?: boolean | ArticleTranslationCountOutputTypeCountBlocksArgs
  }

  // Custom InputTypes

  /**
   * ArticleTranslationCountOutputType without action
   */
  export type ArticleTranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslationCountOutputType
     */
    select?: ArticleTranslationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ArticleTranslationCountOutputType without action
   */
  export type ArticleTranslationCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }



  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    translations: number
    articles: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | TagCountOutputTypeCountTranslationsArgs
    articles?: boolean | TagCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagTranslationWhereInput
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }



  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    translations: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | CommentCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentTranslationWhereInput
  }



  /**
   * Count Type CategoryServiceCountOutputType
   */

  export type CategoryServiceCountOutputType = {
    services: number
    translations: number
  }

  export type CategoryServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | CategoryServiceCountOutputTypeCountServicesArgs
    translations?: boolean | CategoryServiceCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes

  /**
   * CategoryServiceCountOutputType without action
   */
  export type CategoryServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceCountOutputType
     */
    select?: CategoryServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryServiceCountOutputType without action
   */
  export type CategoryServiceCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * CategoryServiceCountOutputType without action
   */
  export type CategoryServiceCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryServiceTranslationWhereInput
  }



  /**
   * Count Type CategoryServiceTranslationCountOutputType
   */

  export type CategoryServiceTranslationCountOutputType = {
    blocks: number
  }

  export type CategoryServiceTranslationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blocks?: boolean | CategoryServiceTranslationCountOutputTypeCountBlocksArgs
  }

  // Custom InputTypes

  /**
   * CategoryServiceTranslationCountOutputType without action
   */
  export type CategoryServiceTranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslationCountOutputType
     */
    select?: CategoryServiceTranslationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryServiceTranslationCountOutputType without action
   */
  export type CategoryServiceTranslationCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    translations: number
    orders: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | ServiceCountOutputTypeCountTranslationsArgs
    orders?: boolean | ServiceCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTranslationWhereInput
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }



  /**
   * Count Type ServiceTranslationCountOutputType
   */

  export type ServiceTranslationCountOutputType = {
    blocks: number
  }

  export type ServiceTranslationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blocks?: boolean | ServiceTranslationCountOutputTypeCountBlocksArgs
  }

  // Custom InputTypes

  /**
   * ServiceTranslationCountOutputType without action
   */
  export type ServiceTranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslationCountOutputType
     */
    select?: ServiceTranslationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceTranslationCountOutputType without action
   */
  export type ServiceTranslationCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $SessionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }


  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.Role
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    pages?: boolean | User$pagesArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    pages?: boolean | User$pagesArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      pages: Prisma.$PageTranslationPayload<ExtArgs>[]
      articles: Prisma.$ArticleTranslationPayload<ExtArgs>[]
      categories: Prisma.$CategoryTranslationPayload<ExtArgs>[]
      Comment: Prisma.$CommentTranslationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      password: string | null
      image: string | null
      role: $Enums.Role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    pages<T extends User$pagesArgs<ExtArgs> = {}>(args?: Subset<T, User$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    articles<T extends User$articlesArgs<ExtArgs> = {}>(args?: Subset<T, User$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    categories<T extends User$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * User.pages
   */
  export type User$pagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    where?: PageTranslationWhereInput
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    cursor?: PageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }


  /**
   * User.articles
   */
  export type User$articlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    where?: ArticleTranslationWhereInput
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    cursor?: ArticleTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }


  /**
   * User.categories
   */
  export type User$categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    cursor?: CategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }


  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    where?: CommentTranslationWhereInput
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    cursor?: CommentTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentTranslationScalarFieldEnum | CommentTranslationScalarFieldEnum[]
  }


  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }


  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }



  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    label: string | null
    language: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    label: string | null
    language: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    label: number
    language: number
    common: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    label?: true
    language?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    label?: true
    language?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    label?: true
    language?: true
    common?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    label: string
    language: string
    common: JsonValue
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    language?: boolean
    common?: boolean
    globals?: boolean | Language$globalsArgs<ExtArgs>
    pages?: boolean | Language$pagesArgs<ExtArgs>
    categoreis?: boolean | Language$categoreisArgs<ExtArgs>
    categoriesServices?: boolean | Language$categoriesServicesArgs<ExtArgs>
    services?: boolean | Language$servicesArgs<ExtArgs>
    articles?: boolean | Language$articlesArgs<ExtArgs>
    tags?: boolean | Language$tagsArgs<ExtArgs>
    comments?: boolean | Language$commentsArgs<ExtArgs>
    navbarItems?: boolean | Language$navbarItemsArgs<ExtArgs>
    dropdownGroups?: boolean | Language$dropdownGroupsArgs<ExtArgs>
    dropdownItems?: boolean | Language$dropdownItemsArgs<ExtArgs>
    footers?: boolean | Language$footersArgs<ExtArgs>
    groupFooters?: boolean | Language$groupFootersArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    label?: boolean
    language?: boolean
    common?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    globals?: boolean | Language$globalsArgs<ExtArgs>
    pages?: boolean | Language$pagesArgs<ExtArgs>
    categoreis?: boolean | Language$categoreisArgs<ExtArgs>
    categoriesServices?: boolean | Language$categoriesServicesArgs<ExtArgs>
    services?: boolean | Language$servicesArgs<ExtArgs>
    articles?: boolean | Language$articlesArgs<ExtArgs>
    tags?: boolean | Language$tagsArgs<ExtArgs>
    comments?: boolean | Language$commentsArgs<ExtArgs>
    navbarItems?: boolean | Language$navbarItemsArgs<ExtArgs>
    dropdownGroups?: boolean | Language$dropdownGroupsArgs<ExtArgs>
    dropdownItems?: boolean | Language$dropdownItemsArgs<ExtArgs>
    footers?: boolean | Language$footersArgs<ExtArgs>
    groupFooters?: boolean | Language$groupFootersArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LanguagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      globals: Prisma.$GlobalTranslationPayload<ExtArgs>[]
      pages: Prisma.$PageTranslationPayload<ExtArgs>[]
      categoreis: Prisma.$CategoryTranslationPayload<ExtArgs>[]
      categoriesServices: Prisma.$CategoryServiceTranslationPayload<ExtArgs>[]
      services: Prisma.$ServiceTranslationPayload<ExtArgs>[]
      articles: Prisma.$ArticleTranslationPayload<ExtArgs>[]
      tags: Prisma.$TagTranslationPayload<ExtArgs>[]
      comments: Prisma.$CommentTranslationPayload<ExtArgs>[]
      navbarItems: Prisma.$NavbarItemTranslationPayload<ExtArgs>[]
      dropdownGroups: Prisma.$DropDownGroupTranslationPayload<ExtArgs>[]
      dropdownItems: Prisma.$DropdownItemTranslationPayload<ExtArgs>[]
      footers: Prisma.$FooterTranslationPayload<ExtArgs>[]
      groupFooters: Prisma.$GroupFooterTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      label: string
      language: string
      common: Prisma.JsonValue
    }, ExtArgs["result"]["language"]>
    composites: {}
  }


  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LanguageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LanguageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LanguageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
    **/
    create<T extends LanguageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Languages.
     *     @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     *     @example
     *     // Create many Languages
     *     const language = await prisma.language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LanguageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
    **/
    delete<T extends LanguageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LanguageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LanguageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LanguageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
    **/
    upsert<T extends LanguageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    globals<T extends Language$globalsArgs<ExtArgs> = {}>(args?: Subset<T, Language$globalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    pages<T extends Language$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Language$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    categoreis<T extends Language$categoreisArgs<ExtArgs> = {}>(args?: Subset<T, Language$categoreisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    categoriesServices<T extends Language$categoriesServicesArgs<ExtArgs> = {}>(args?: Subset<T, Language$categoriesServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    services<T extends Language$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Language$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    articles<T extends Language$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Language$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    tags<T extends Language$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Language$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    comments<T extends Language$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Language$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    navbarItems<T extends Language$navbarItemsArgs<ExtArgs> = {}>(args?: Subset<T, Language$navbarItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    dropdownGroups<T extends Language$dropdownGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Language$dropdownGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    dropdownItems<T extends Language$dropdownItemsArgs<ExtArgs> = {}>(args?: Subset<T, Language$dropdownItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    footers<T extends Language$footersArgs<ExtArgs> = {}>(args?: Subset<T, Language$footersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    groupFooters<T extends Language$groupFootersArgs<ExtArgs> = {}>(args?: Subset<T, Language$groupFootersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly label: FieldRef<"Language", 'String'>
    readonly language: FieldRef<"Language", 'String'>
    readonly common: FieldRef<"Language", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }


  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }


  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }


  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }


  /**
   * Language.globals
   */
  export type Language$globalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    where?: GlobalTranslationWhereInput
    orderBy?: GlobalTranslationOrderByWithRelationInput | GlobalTranslationOrderByWithRelationInput[]
    cursor?: GlobalTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlobalTranslationScalarFieldEnum | GlobalTranslationScalarFieldEnum[]
  }


  /**
   * Language.pages
   */
  export type Language$pagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    where?: PageTranslationWhereInput
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    cursor?: PageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }


  /**
   * Language.categoreis
   */
  export type Language$categoreisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    cursor?: CategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }


  /**
   * Language.categoriesServices
   */
  export type Language$categoriesServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    where?: CategoryServiceTranslationWhereInput
    orderBy?: CategoryServiceTranslationOrderByWithRelationInput | CategoryServiceTranslationOrderByWithRelationInput[]
    cursor?: CategoryServiceTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryServiceTranslationScalarFieldEnum | CategoryServiceTranslationScalarFieldEnum[]
  }


  /**
   * Language.services
   */
  export type Language$servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    where?: ServiceTranslationWhereInput
    orderBy?: ServiceTranslationOrderByWithRelationInput | ServiceTranslationOrderByWithRelationInput[]
    cursor?: ServiceTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTranslationScalarFieldEnum | ServiceTranslationScalarFieldEnum[]
  }


  /**
   * Language.articles
   */
  export type Language$articlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    where?: ArticleTranslationWhereInput
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    cursor?: ArticleTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }


  /**
   * Language.tags
   */
  export type Language$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    where?: TagTranslationWhereInput
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    cursor?: TagTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }


  /**
   * Language.comments
   */
  export type Language$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    where?: CommentTranslationWhereInput
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    cursor?: CommentTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentTranslationScalarFieldEnum | CommentTranslationScalarFieldEnum[]
  }


  /**
   * Language.navbarItems
   */
  export type Language$navbarItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    where?: NavbarItemTranslationWhereInput
    orderBy?: NavbarItemTranslationOrderByWithRelationInput | NavbarItemTranslationOrderByWithRelationInput[]
    cursor?: NavbarItemTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NavbarItemTranslationScalarFieldEnum | NavbarItemTranslationScalarFieldEnum[]
  }


  /**
   * Language.dropdownGroups
   */
  export type Language$dropdownGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    where?: DropDownGroupTranslationWhereInput
    orderBy?: DropDownGroupTranslationOrderByWithRelationInput | DropDownGroupTranslationOrderByWithRelationInput[]
    cursor?: DropDownGroupTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropDownGroupTranslationScalarFieldEnum | DropDownGroupTranslationScalarFieldEnum[]
  }


  /**
   * Language.dropdownItems
   */
  export type Language$dropdownItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    where?: DropdownItemTranslationWhereInput
    orderBy?: DropdownItemTranslationOrderByWithRelationInput | DropdownItemTranslationOrderByWithRelationInput[]
    cursor?: DropdownItemTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropdownItemTranslationScalarFieldEnum | DropdownItemTranslationScalarFieldEnum[]
  }


  /**
   * Language.footers
   */
  export type Language$footersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    where?: FooterTranslationWhereInput
    orderBy?: FooterTranslationOrderByWithRelationInput | FooterTranslationOrderByWithRelationInput[]
    cursor?: FooterTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FooterTranslationScalarFieldEnum | FooterTranslationScalarFieldEnum[]
  }


  /**
   * Language.groupFooters
   */
  export type Language$groupFootersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    where?: GroupFooterTranslationWhereInput
    orderBy?: GroupFooterTranslationOrderByWithRelationInput | GroupFooterTranslationOrderByWithRelationInput[]
    cursor?: GroupFooterTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupFooterTranslationScalarFieldEnum | GroupFooterTranslationScalarFieldEnum[]
  }


  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
  }



  /**
   * Model Global
   */

  export type AggregateGlobal = {
    _count: GlobalCountAggregateOutputType | null
    _min: GlobalMinAggregateOutputType | null
    _max: GlobalMaxAggregateOutputType | null
  }

  export type GlobalMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Global to aggregate.
     */
    where?: GlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Globals to fetch.
     */
    orderBy?: GlobalOrderByWithRelationInput | GlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Globals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Globals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Globals
    **/
    _count?: true | GlobalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalMaxAggregateInputType
  }

  export type GetGlobalAggregateType<T extends GlobalAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobal[P]>
      : GetScalarType<T[P], AggregateGlobal[P]>
  }




  export type GlobalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GlobalWhereInput
    orderBy?: GlobalOrderByWithAggregationInput | GlobalOrderByWithAggregationInput[]
    by: GlobalScalarFieldEnum[] | GlobalScalarFieldEnum
    having?: GlobalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalCountAggregateInputType | true
    _min?: GlobalMinAggregateInputType
    _max?: GlobalMaxAggregateInputType
  }

  export type GlobalGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: GlobalCountAggregateOutputType | null
    _min: GlobalMinAggregateOutputType | null
    _max: GlobalMaxAggregateOutputType | null
  }

  type GetGlobalGroupByPayload<T extends GlobalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalGroupByOutputType[P]>
        }
      >
    >


  export type GlobalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Global$translationsArgs<ExtArgs>
    socialLinks?: boolean | Global$socialLinksArgs<ExtArgs>
    _count?: boolean | GlobalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["global"]>

  export type GlobalSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GlobalInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Global$translationsArgs<ExtArgs>
    socialLinks?: boolean | Global$socialLinksArgs<ExtArgs>
    _count?: boolean | GlobalCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GlobalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Global"
    objects: {
      translations: Prisma.$GlobalTranslationPayload<ExtArgs>[]
      socialLinks: Prisma.$SocialLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["global"]>
    composites: {}
  }


  type GlobalGetPayload<S extends boolean | null | undefined | GlobalDefaultArgs> = $Result.GetResult<Prisma.$GlobalPayload, S>

  type GlobalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GlobalFindManyArgs, 'select' | 'include'> & {
      select?: GlobalCountAggregateInputType | true
    }

  export interface GlobalDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Global'], meta: { name: 'Global' } }
    /**
     * Find zero or one Global that matches the filter.
     * @param {GlobalFindUniqueArgs} args - Arguments to find a Global
     * @example
     * // Get one Global
     * const global = await prisma.global.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GlobalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalFindUniqueArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Global that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GlobalFindUniqueOrThrowArgs} args - Arguments to find a Global
     * @example
     * // Get one Global
     * const global = await prisma.global.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GlobalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Global that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalFindFirstArgs} args - Arguments to find a Global
     * @example
     * // Get one Global
     * const global = await prisma.global.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GlobalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalFindFirstArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Global that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalFindFirstOrThrowArgs} args - Arguments to find a Global
     * @example
     * // Get one Global
     * const global = await prisma.global.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GlobalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Globals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Globals
     * const globals = await prisma.global.findMany()
     * 
     * // Get first 10 Globals
     * const globals = await prisma.global.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalWithIdOnly = await prisma.global.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GlobalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Global.
     * @param {GlobalCreateArgs} args - Arguments to create a Global.
     * @example
     * // Create one Global
     * const Global = await prisma.global.create({
     *   data: {
     *     // ... data to create a Global
     *   }
     * })
     * 
    **/
    create<T extends GlobalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalCreateArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Globals.
     *     @param {GlobalCreateManyArgs} args - Arguments to create many Globals.
     *     @example
     *     // Create many Globals
     *     const global = await prisma.global.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GlobalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Global.
     * @param {GlobalDeleteArgs} args - Arguments to delete one Global.
     * @example
     * // Delete one Global
     * const Global = await prisma.global.delete({
     *   where: {
     *     // ... filter to delete one Global
     *   }
     * })
     * 
    **/
    delete<T extends GlobalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalDeleteArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Global.
     * @param {GlobalUpdateArgs} args - Arguments to update one Global.
     * @example
     * // Update one Global
     * const global = await prisma.global.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GlobalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalUpdateArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Globals.
     * @param {GlobalDeleteManyArgs} args - Arguments to filter Globals to delete.
     * @example
     * // Delete a few Globals
     * const { count } = await prisma.global.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GlobalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Globals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Globals
     * const global = await prisma.global.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GlobalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Global.
     * @param {GlobalUpsertArgs} args - Arguments to update or create a Global.
     * @example
     * // Update or create a Global
     * const global = await prisma.global.upsert({
     *   create: {
     *     // ... data to create a Global
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Global we want to update
     *   }
     * })
    **/
    upsert<T extends GlobalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalUpsertArgs<ExtArgs>>
    ): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Globals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalCountArgs} args - Arguments to filter Globals to count.
     * @example
     * // Count the number of Globals
     * const count = await prisma.global.count({
     *   where: {
     *     // ... the filter for the Globals we want to count
     *   }
     * })
    **/
    count<T extends GlobalCountArgs>(
      args?: Subset<T, GlobalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Global.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalAggregateArgs>(args: Subset<T, GlobalAggregateArgs>): Prisma.PrismaPromise<GetGlobalAggregateType<T>>

    /**
     * Group by Global.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalGroupByArgs['orderBy'] }
        : { orderBy?: GlobalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Global model
   */
  readonly fields: GlobalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Global.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Global$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Global$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    socialLinks<T extends Global$socialLinksArgs<ExtArgs> = {}>(args?: Subset<T, Global$socialLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Global model
   */ 
  interface GlobalFieldRefs {
    readonly id: FieldRef<"Global", 'String'>
    readonly createdAt: FieldRef<"Global", 'DateTime'>
    readonly updatedAt: FieldRef<"Global", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Global findUnique
   */
  export type GlobalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * Filter, which Global to fetch.
     */
    where: GlobalWhereUniqueInput
  }


  /**
   * Global findUniqueOrThrow
   */
  export type GlobalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * Filter, which Global to fetch.
     */
    where: GlobalWhereUniqueInput
  }


  /**
   * Global findFirst
   */
  export type GlobalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * Filter, which Global to fetch.
     */
    where?: GlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Globals to fetch.
     */
    orderBy?: GlobalOrderByWithRelationInput | GlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Globals.
     */
    cursor?: GlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Globals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Globals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Globals.
     */
    distinct?: GlobalScalarFieldEnum | GlobalScalarFieldEnum[]
  }


  /**
   * Global findFirstOrThrow
   */
  export type GlobalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * Filter, which Global to fetch.
     */
    where?: GlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Globals to fetch.
     */
    orderBy?: GlobalOrderByWithRelationInput | GlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Globals.
     */
    cursor?: GlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Globals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Globals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Globals.
     */
    distinct?: GlobalScalarFieldEnum | GlobalScalarFieldEnum[]
  }


  /**
   * Global findMany
   */
  export type GlobalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * Filter, which Globals to fetch.
     */
    where?: GlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Globals to fetch.
     */
    orderBy?: GlobalOrderByWithRelationInput | GlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Globals.
     */
    cursor?: GlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Globals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Globals.
     */
    skip?: number
    distinct?: GlobalScalarFieldEnum | GlobalScalarFieldEnum[]
  }


  /**
   * Global create
   */
  export type GlobalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * The data needed to create a Global.
     */
    data: XOR<GlobalCreateInput, GlobalUncheckedCreateInput>
  }


  /**
   * Global createMany
   */
  export type GlobalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Globals.
     */
    data: GlobalCreateManyInput | GlobalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Global update
   */
  export type GlobalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * The data needed to update a Global.
     */
    data: XOR<GlobalUpdateInput, GlobalUncheckedUpdateInput>
    /**
     * Choose, which Global to update.
     */
    where: GlobalWhereUniqueInput
  }


  /**
   * Global updateMany
   */
  export type GlobalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Globals.
     */
    data: XOR<GlobalUpdateManyMutationInput, GlobalUncheckedUpdateManyInput>
    /**
     * Filter which Globals to update
     */
    where?: GlobalWhereInput
  }


  /**
   * Global upsert
   */
  export type GlobalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * The filter to search for the Global to update in case it exists.
     */
    where: GlobalWhereUniqueInput
    /**
     * In case the Global found by the `where` argument doesn't exist, create a new Global with this data.
     */
    create: XOR<GlobalCreateInput, GlobalUncheckedCreateInput>
    /**
     * In case the Global was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalUpdateInput, GlobalUncheckedUpdateInput>
  }


  /**
   * Global delete
   */
  export type GlobalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    /**
     * Filter which Global to delete.
     */
    where: GlobalWhereUniqueInput
  }


  /**
   * Global deleteMany
   */
  export type GlobalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Globals to delete
     */
    where?: GlobalWhereInput
  }


  /**
   * Global.translations
   */
  export type Global$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    where?: GlobalTranslationWhereInput
    orderBy?: GlobalTranslationOrderByWithRelationInput | GlobalTranslationOrderByWithRelationInput[]
    cursor?: GlobalTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlobalTranslationScalarFieldEnum | GlobalTranslationScalarFieldEnum[]
  }


  /**
   * Global.socialLinks
   */
  export type Global$socialLinksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    cursor?: SocialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }


  /**
   * Global without action
   */
  export type GlobalDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
  }



  /**
   * Model GlobalTranslation
   */

  export type AggregateGlobalTranslation = {
    _count: GlobalTranslationCountAggregateOutputType | null
    _min: GlobalTranslationMinAggregateOutputType | null
    _max: GlobalTranslationMaxAggregateOutputType | null
  }

  export type GlobalTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    logo: string | null
    favicon: string | null
    description: string | null
    globalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    logo: string | null
    favicon: string | null
    description: string | null
    globalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalTranslationCountAggregateOutputType = {
    id: number
    lang: number
    name: number
    logo: number
    favicon: number
    images: number
    description: number
    globalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    logo?: true
    favicon?: true
    description?: true
    globalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    logo?: true
    favicon?: true
    description?: true
    globalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    logo?: true
    favicon?: true
    images?: true
    description?: true
    globalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalTranslation to aggregate.
     */
    where?: GlobalTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalTranslations to fetch.
     */
    orderBy?: GlobalTranslationOrderByWithRelationInput | GlobalTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalTranslations
    **/
    _count?: true | GlobalTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalTranslationMaxAggregateInputType
  }

  export type GetGlobalTranslationAggregateType<T extends GlobalTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalTranslation[P]>
      : GetScalarType<T[P], AggregateGlobalTranslation[P]>
  }




  export type GlobalTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GlobalTranslationWhereInput
    orderBy?: GlobalTranslationOrderByWithAggregationInput | GlobalTranslationOrderByWithAggregationInput[]
    by: GlobalTranslationScalarFieldEnum[] | GlobalTranslationScalarFieldEnum
    having?: GlobalTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalTranslationCountAggregateInputType | true
    _min?: GlobalTranslationMinAggregateInputType
    _max?: GlobalTranslationMaxAggregateInputType
  }

  export type GlobalTranslationGroupByOutputType = {
    id: string
    lang: string
    name: string | null
    logo: string | null
    favicon: string | null
    images: string[]
    description: string | null
    globalId: string
    createdAt: Date
    updatedAt: Date
    _count: GlobalTranslationCountAggregateOutputType | null
    _min: GlobalTranslationMinAggregateOutputType | null
    _max: GlobalTranslationMaxAggregateOutputType | null
  }

  type GetGlobalTranslationGroupByPayload<T extends GlobalTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalTranslationGroupByOutputType[P]>
        }
      >
    >


  export type GlobalTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    name?: boolean
    logo?: boolean
    favicon?: boolean
    images?: boolean
    description?: boolean
    globalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    global?: boolean | GlobalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["globalTranslation"]>

  export type GlobalTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    name?: boolean
    logo?: boolean
    favicon?: boolean
    images?: boolean
    description?: boolean
    globalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GlobalTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    global?: boolean | GlobalDefaultArgs<ExtArgs>
  }


  export type $GlobalTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "GlobalTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      global: Prisma.$GlobalPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      name: string | null
      logo: string | null
      favicon: string | null
      images: string[]
      description: string | null
      globalId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["globalTranslation"]>
    composites: {}
  }


  type GlobalTranslationGetPayload<S extends boolean | null | undefined | GlobalTranslationDefaultArgs> = $Result.GetResult<Prisma.$GlobalTranslationPayload, S>

  type GlobalTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GlobalTranslationFindManyArgs, 'select' | 'include'> & {
      select?: GlobalTranslationCountAggregateInputType | true
    }

  export interface GlobalTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalTranslation'], meta: { name: 'GlobalTranslation' } }
    /**
     * Find zero or one GlobalTranslation that matches the filter.
     * @param {GlobalTranslationFindUniqueArgs} args - Arguments to find a GlobalTranslation
     * @example
     * // Get one GlobalTranslation
     * const globalTranslation = await prisma.globalTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GlobalTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GlobalTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GlobalTranslationFindUniqueOrThrowArgs} args - Arguments to find a GlobalTranslation
     * @example
     * // Get one GlobalTranslation
     * const globalTranslation = await prisma.globalTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GlobalTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GlobalTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationFindFirstArgs} args - Arguments to find a GlobalTranslation
     * @example
     * // Get one GlobalTranslation
     * const globalTranslation = await prisma.globalTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GlobalTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GlobalTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationFindFirstOrThrowArgs} args - Arguments to find a GlobalTranslation
     * @example
     * // Get one GlobalTranslation
     * const globalTranslation = await prisma.globalTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GlobalTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GlobalTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalTranslations
     * const globalTranslations = await prisma.globalTranslation.findMany()
     * 
     * // Get first 10 GlobalTranslations
     * const globalTranslations = await prisma.globalTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalTranslationWithIdOnly = await prisma.globalTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GlobalTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GlobalTranslation.
     * @param {GlobalTranslationCreateArgs} args - Arguments to create a GlobalTranslation.
     * @example
     * // Create one GlobalTranslation
     * const GlobalTranslation = await prisma.globalTranslation.create({
     *   data: {
     *     // ... data to create a GlobalTranslation
     *   }
     * })
     * 
    **/
    create<T extends GlobalTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalTranslationCreateArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GlobalTranslations.
     *     @param {GlobalTranslationCreateManyArgs} args - Arguments to create many GlobalTranslations.
     *     @example
     *     // Create many GlobalTranslations
     *     const globalTranslation = await prisma.globalTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GlobalTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GlobalTranslation.
     * @param {GlobalTranslationDeleteArgs} args - Arguments to delete one GlobalTranslation.
     * @example
     * // Delete one GlobalTranslation
     * const GlobalTranslation = await prisma.globalTranslation.delete({
     *   where: {
     *     // ... filter to delete one GlobalTranslation
     *   }
     * })
     * 
    **/
    delete<T extends GlobalTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalTranslationDeleteArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GlobalTranslation.
     * @param {GlobalTranslationUpdateArgs} args - Arguments to update one GlobalTranslation.
     * @example
     * // Update one GlobalTranslation
     * const globalTranslation = await prisma.globalTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GlobalTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalTranslationUpdateArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GlobalTranslations.
     * @param {GlobalTranslationDeleteManyArgs} args - Arguments to filter GlobalTranslations to delete.
     * @example
     * // Delete a few GlobalTranslations
     * const { count } = await prisma.globalTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GlobalTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GlobalTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalTranslations
     * const globalTranslation = await prisma.globalTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GlobalTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GlobalTranslation.
     * @param {GlobalTranslationUpsertArgs} args - Arguments to update or create a GlobalTranslation.
     * @example
     * // Update or create a GlobalTranslation
     * const globalTranslation = await prisma.globalTranslation.upsert({
     *   create: {
     *     // ... data to create a GlobalTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends GlobalTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GlobalTranslationUpsertArgs<ExtArgs>>
    ): Prisma__GlobalTranslationClient<$Result.GetResult<Prisma.$GlobalTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GlobalTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationCountArgs} args - Arguments to filter GlobalTranslations to count.
     * @example
     * // Count the number of GlobalTranslations
     * const count = await prisma.globalTranslation.count({
     *   where: {
     *     // ... the filter for the GlobalTranslations we want to count
     *   }
     * })
    **/
    count<T extends GlobalTranslationCountArgs>(
      args?: Subset<T, GlobalTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalTranslationAggregateArgs>(args: Subset<T, GlobalTranslationAggregateArgs>): Prisma.PrismaPromise<GetGlobalTranslationAggregateType<T>>

    /**
     * Group by GlobalTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalTranslationGroupByArgs['orderBy'] }
        : { orderBy?: GlobalTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalTranslation model
   */
  readonly fields: GlobalTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    global<T extends GlobalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GlobalDefaultArgs<ExtArgs>>): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GlobalTranslation model
   */ 
  interface GlobalTranslationFieldRefs {
    readonly id: FieldRef<"GlobalTranslation", 'String'>
    readonly lang: FieldRef<"GlobalTranslation", 'String'>
    readonly name: FieldRef<"GlobalTranslation", 'String'>
    readonly logo: FieldRef<"GlobalTranslation", 'String'>
    readonly favicon: FieldRef<"GlobalTranslation", 'String'>
    readonly images: FieldRef<"GlobalTranslation", 'String[]'>
    readonly description: FieldRef<"GlobalTranslation", 'String'>
    readonly globalId: FieldRef<"GlobalTranslation", 'String'>
    readonly createdAt: FieldRef<"GlobalTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * GlobalTranslation findUnique
   */
  export type GlobalTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GlobalTranslation to fetch.
     */
    where: GlobalTranslationWhereUniqueInput
  }


  /**
   * GlobalTranslation findUniqueOrThrow
   */
  export type GlobalTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GlobalTranslation to fetch.
     */
    where: GlobalTranslationWhereUniqueInput
  }


  /**
   * GlobalTranslation findFirst
   */
  export type GlobalTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GlobalTranslation to fetch.
     */
    where?: GlobalTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalTranslations to fetch.
     */
    orderBy?: GlobalTranslationOrderByWithRelationInput | GlobalTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalTranslations.
     */
    cursor?: GlobalTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalTranslations.
     */
    distinct?: GlobalTranslationScalarFieldEnum | GlobalTranslationScalarFieldEnum[]
  }


  /**
   * GlobalTranslation findFirstOrThrow
   */
  export type GlobalTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GlobalTranslation to fetch.
     */
    where?: GlobalTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalTranslations to fetch.
     */
    orderBy?: GlobalTranslationOrderByWithRelationInput | GlobalTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalTranslations.
     */
    cursor?: GlobalTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalTranslations.
     */
    distinct?: GlobalTranslationScalarFieldEnum | GlobalTranslationScalarFieldEnum[]
  }


  /**
   * GlobalTranslation findMany
   */
  export type GlobalTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GlobalTranslations to fetch.
     */
    where?: GlobalTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalTranslations to fetch.
     */
    orderBy?: GlobalTranslationOrderByWithRelationInput | GlobalTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalTranslations.
     */
    cursor?: GlobalTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalTranslations.
     */
    skip?: number
    distinct?: GlobalTranslationScalarFieldEnum | GlobalTranslationScalarFieldEnum[]
  }


  /**
   * GlobalTranslation create
   */
  export type GlobalTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a GlobalTranslation.
     */
    data: XOR<GlobalTranslationCreateInput, GlobalTranslationUncheckedCreateInput>
  }


  /**
   * GlobalTranslation createMany
   */
  export type GlobalTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalTranslations.
     */
    data: GlobalTranslationCreateManyInput | GlobalTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GlobalTranslation update
   */
  export type GlobalTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a GlobalTranslation.
     */
    data: XOR<GlobalTranslationUpdateInput, GlobalTranslationUncheckedUpdateInput>
    /**
     * Choose, which GlobalTranslation to update.
     */
    where: GlobalTranslationWhereUniqueInput
  }


  /**
   * GlobalTranslation updateMany
   */
  export type GlobalTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalTranslations.
     */
    data: XOR<GlobalTranslationUpdateManyMutationInput, GlobalTranslationUncheckedUpdateManyInput>
    /**
     * Filter which GlobalTranslations to update
     */
    where?: GlobalTranslationWhereInput
  }


  /**
   * GlobalTranslation upsert
   */
  export type GlobalTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the GlobalTranslation to update in case it exists.
     */
    where: GlobalTranslationWhereUniqueInput
    /**
     * In case the GlobalTranslation found by the `where` argument doesn't exist, create a new GlobalTranslation with this data.
     */
    create: XOR<GlobalTranslationCreateInput, GlobalTranslationUncheckedCreateInput>
    /**
     * In case the GlobalTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalTranslationUpdateInput, GlobalTranslationUncheckedUpdateInput>
  }


  /**
   * GlobalTranslation delete
   */
  export type GlobalTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
    /**
     * Filter which GlobalTranslation to delete.
     */
    where: GlobalTranslationWhereUniqueInput
  }


  /**
   * GlobalTranslation deleteMany
   */
  export type GlobalTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalTranslations to delete
     */
    where?: GlobalTranslationWhereInput
  }


  /**
   * GlobalTranslation without action
   */
  export type GlobalTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalTranslation
     */
    select?: GlobalTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalTranslationInclude<ExtArgs> | null
  }



  /**
   * Model SocialLink
   */

  export type AggregateSocialLink = {
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  export type SocialLinkMinAggregateOutputType = {
    id: string | null
    social: string | null
    url: string | null
    globalId: string | null
  }

  export type SocialLinkMaxAggregateOutputType = {
    id: string | null
    social: string | null
    url: string | null
    globalId: string | null
  }

  export type SocialLinkCountAggregateOutputType = {
    id: number
    social: number
    url: number
    globalId: number
    _all: number
  }


  export type SocialLinkMinAggregateInputType = {
    id?: true
    social?: true
    url?: true
    globalId?: true
  }

  export type SocialLinkMaxAggregateInputType = {
    id?: true
    social?: true
    url?: true
    globalId?: true
  }

  export type SocialLinkCountAggregateInputType = {
    id?: true
    social?: true
    url?: true
    globalId?: true
    _all?: true
  }

  export type SocialLinkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLink to aggregate.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLinks
    **/
    _count?: true | SocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinkMaxAggregateInputType
  }

  export type GetSocialLinkAggregateType<T extends SocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLink[P]>
      : GetScalarType<T[P], AggregateSocialLink[P]>
  }




  export type SocialLinkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithAggregationInput | SocialLinkOrderByWithAggregationInput[]
    by: SocialLinkScalarFieldEnum[] | SocialLinkScalarFieldEnum
    having?: SocialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinkCountAggregateInputType | true
    _min?: SocialLinkMinAggregateInputType
    _max?: SocialLinkMaxAggregateInputType
  }

  export type SocialLinkGroupByOutputType = {
    id: string
    social: string
    url: string
    globalId: string | null
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  type GetSocialLinkGroupByPayload<T extends SocialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type SocialLinkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    social?: boolean
    url?: boolean
    globalId?: boolean
    global?: boolean | SocialLink$globalArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type SocialLinkSelectScalar = {
    id?: boolean
    social?: boolean
    url?: boolean
    globalId?: boolean
  }

  export type SocialLinkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    global?: boolean | SocialLink$globalArgs<ExtArgs>
  }


  export type $SocialLinkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "SocialLink"
    objects: {
      global: Prisma.$GlobalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      social: string
      url: string
      globalId: string | null
    }, ExtArgs["result"]["socialLink"]>
    composites: {}
  }


  type SocialLinkGetPayload<S extends boolean | null | undefined | SocialLinkDefaultArgs> = $Result.GetResult<Prisma.$SocialLinkPayload, S>

  type SocialLinkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SocialLinkFindManyArgs, 'select' | 'include'> & {
      select?: SocialLinkCountAggregateInputType | true
    }

  export interface SocialLinkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLink'], meta: { name: 'SocialLink' } }
    /**
     * Find zero or one SocialLink that matches the filter.
     * @param {SocialLinkFindUniqueArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SocialLinkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLinkFindUniqueArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SocialLink that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SocialLinkFindUniqueOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SocialLinkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLinkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SocialLinkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLinkFindFirstArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SocialLinkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLinkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLink.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SocialLinkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLinkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SocialLink.
     * @param {SocialLinkCreateArgs} args - Arguments to create a SocialLink.
     * @example
     * // Create one SocialLink
     * const SocialLink = await prisma.socialLink.create({
     *   data: {
     *     // ... data to create a SocialLink
     *   }
     * })
     * 
    **/
    create<T extends SocialLinkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLinkCreateArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SocialLinks.
     *     @param {SocialLinkCreateManyArgs} args - Arguments to create many SocialLinks.
     *     @example
     *     // Create many SocialLinks
     *     const socialLink = await prisma.socialLink.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SocialLinkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLinkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialLink.
     * @param {SocialLinkDeleteArgs} args - Arguments to delete one SocialLink.
     * @example
     * // Delete one SocialLink
     * const SocialLink = await prisma.socialLink.delete({
     *   where: {
     *     // ... filter to delete one SocialLink
     *   }
     * })
     * 
    **/
    delete<T extends SocialLinkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLinkDeleteArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SocialLink.
     * @param {SocialLinkUpdateArgs} args - Arguments to update one SocialLink.
     * @example
     * // Update one SocialLink
     * const socialLink = await prisma.socialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SocialLinkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLinkUpdateArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SocialLinks.
     * @param {SocialLinkDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SocialLinkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLinkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SocialLinkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLinkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialLink.
     * @param {SocialLinkUpsertArgs} args - Arguments to update or create a SocialLink.
     * @example
     * // Update or create a SocialLink
     * const socialLink = await prisma.socialLink.upsert({
     *   create: {
     *     // ... data to create a SocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLink we want to update
     *   }
     * })
    **/
    upsert<T extends SocialLinkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLinkUpsertArgs<ExtArgs>>
    ): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLink.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends SocialLinkCountArgs>(
      args?: Subset<T, SocialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinkAggregateArgs>(args: Subset<T, SocialLinkAggregateArgs>): Prisma.PrismaPromise<GetSocialLinkAggregateType<T>>

    /**
     * Group by SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLinkGroupByArgs['orderBy'] }
        : { orderBy?: SocialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLink model
   */
  readonly fields: SocialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLinkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    global<T extends SocialLink$globalArgs<ExtArgs> = {}>(args?: Subset<T, SocialLink$globalArgs<ExtArgs>>): Prisma__GlobalClient<$Result.GetResult<Prisma.$GlobalPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SocialLink model
   */ 
  interface SocialLinkFieldRefs {
    readonly id: FieldRef<"SocialLink", 'String'>
    readonly social: FieldRef<"SocialLink", 'String'>
    readonly url: FieldRef<"SocialLink", 'String'>
    readonly globalId: FieldRef<"SocialLink", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SocialLink findUnique
   */
  export type SocialLinkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }


  /**
   * SocialLink findUniqueOrThrow
   */
  export type SocialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }


  /**
   * SocialLink findFirst
   */
  export type SocialLinkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }


  /**
   * SocialLink findFirstOrThrow
   */
  export type SocialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }


  /**
   * SocialLink findMany
   */
  export type SocialLinkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }


  /**
   * SocialLink create
   */
  export type SocialLinkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLink.
     */
    data: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
  }


  /**
   * SocialLink createMany
   */
  export type SocialLinkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinkCreateManyInput | SocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SocialLink update
   */
  export type SocialLinkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLink.
     */
    data: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
    /**
     * Choose, which SocialLink to update.
     */
    where: SocialLinkWhereUniqueInput
  }


  /**
   * SocialLink updateMany
   */
  export type SocialLinkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinkWhereInput
  }


  /**
   * SocialLink upsert
   */
  export type SocialLinkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLink to update in case it exists.
     */
    where: SocialLinkWhereUniqueInput
    /**
     * In case the SocialLink found by the `where` argument doesn't exist, create a new SocialLink with this data.
     */
    create: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
    /**
     * In case the SocialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
  }


  /**
   * SocialLink delete
   */
  export type SocialLinkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter which SocialLink to delete.
     */
    where: SocialLinkWhereUniqueInput
  }


  /**
   * SocialLink deleteMany
   */
  export type SocialLinkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to delete
     */
    where?: SocialLinkWhereInput
  }


  /**
   * SocialLink.global
   */
  export type SocialLink$globalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Global
     */
    select?: GlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GlobalInclude<ExtArgs> | null
    where?: GlobalWhereInput
  }


  /**
   * SocialLink without action
   */
  export type SocialLinkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLinkInclude<ExtArgs> | null
  }



  /**
   * Model NavbarItem
   */

  export type AggregateNavbarItem = {
    _count: NavbarItemCountAggregateOutputType | null
    _min: NavbarItemMinAggregateOutputType | null
    _max: NavbarItemMaxAggregateOutputType | null
  }

  export type NavbarItemMinAggregateOutputType = {
    id: string | null
    isDropdown: boolean | null
    forArticle: boolean | null
    forPage: boolean | null
    pageId: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavbarItemMaxAggregateOutputType = {
    id: string | null
    isDropdown: boolean | null
    forArticle: boolean | null
    forPage: boolean | null
    pageId: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavbarItemCountAggregateOutputType = {
    id: number
    isDropdown: number
    forArticle: number
    forPage: number
    pageId: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NavbarItemMinAggregateInputType = {
    id?: true
    isDropdown?: true
    forArticle?: true
    forPage?: true
    pageId?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavbarItemMaxAggregateInputType = {
    id?: true
    isDropdown?: true
    forArticle?: true
    forPage?: true
    pageId?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavbarItemCountAggregateInputType = {
    id?: true
    isDropdown?: true
    forArticle?: true
    forPage?: true
    pageId?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NavbarItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavbarItem to aggregate.
     */
    where?: NavbarItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItems to fetch.
     */
    orderBy?: NavbarItemOrderByWithRelationInput | NavbarItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavbarItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavbarItems
    **/
    _count?: true | NavbarItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavbarItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavbarItemMaxAggregateInputType
  }

  export type GetNavbarItemAggregateType<T extends NavbarItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNavbarItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavbarItem[P]>
      : GetScalarType<T[P], AggregateNavbarItem[P]>
  }




  export type NavbarItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NavbarItemWhereInput
    orderBy?: NavbarItemOrderByWithAggregationInput | NavbarItemOrderByWithAggregationInput[]
    by: NavbarItemScalarFieldEnum[] | NavbarItemScalarFieldEnum
    having?: NavbarItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavbarItemCountAggregateInputType | true
    _min?: NavbarItemMinAggregateInputType
    _max?: NavbarItemMaxAggregateInputType
  }

  export type NavbarItemGroupByOutputType = {
    id: string
    isDropdown: boolean
    forArticle: boolean
    forPage: boolean
    pageId: string | null
    articleId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NavbarItemCountAggregateOutputType | null
    _min: NavbarItemMinAggregateOutputType | null
    _max: NavbarItemMaxAggregateOutputType | null
  }

  type GetNavbarItemGroupByPayload<T extends NavbarItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavbarItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavbarItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavbarItemGroupByOutputType[P]>
            : GetScalarType<T[P], NavbarItemGroupByOutputType[P]>
        }
      >
    >


  export type NavbarItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | NavbarItem$translationsArgs<ExtArgs>
    dropdownGroups?: boolean | NavbarItem$dropdownGroupsArgs<ExtArgs>
    dropdownItems?: boolean | NavbarItem$dropdownItemsArgs<ExtArgs>
    page?: boolean | NavbarItem$pageArgs<ExtArgs>
    article?: boolean | NavbarItem$articleArgs<ExtArgs>
    _count?: boolean | NavbarItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["navbarItem"]>

  export type NavbarItemSelectScalar = {
    id?: boolean
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NavbarItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | NavbarItem$translationsArgs<ExtArgs>
    dropdownGroups?: boolean | NavbarItem$dropdownGroupsArgs<ExtArgs>
    dropdownItems?: boolean | NavbarItem$dropdownItemsArgs<ExtArgs>
    page?: boolean | NavbarItem$pageArgs<ExtArgs>
    article?: boolean | NavbarItem$articleArgs<ExtArgs>
    _count?: boolean | NavbarItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NavbarItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "NavbarItem"
    objects: {
      translations: Prisma.$NavbarItemTranslationPayload<ExtArgs>[]
      dropdownGroups: Prisma.$DropDownGroupPayload<ExtArgs>[]
      dropdownItems: Prisma.$DropdownItemPayload<ExtArgs>[]
      page: Prisma.$PagePayload<ExtArgs> | null
      article: Prisma.$ArticlePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      isDropdown: boolean
      forArticle: boolean
      forPage: boolean
      pageId: string | null
      articleId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["navbarItem"]>
    composites: {}
  }


  type NavbarItemGetPayload<S extends boolean | null | undefined | NavbarItemDefaultArgs> = $Result.GetResult<Prisma.$NavbarItemPayload, S>

  type NavbarItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NavbarItemFindManyArgs, 'select' | 'include'> & {
      select?: NavbarItemCountAggregateInputType | true
    }

  export interface NavbarItemDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavbarItem'], meta: { name: 'NavbarItem' } }
    /**
     * Find zero or one NavbarItem that matches the filter.
     * @param {NavbarItemFindUniqueArgs} args - Arguments to find a NavbarItem
     * @example
     * // Get one NavbarItem
     * const navbarItem = await prisma.navbarItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NavbarItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemFindUniqueArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NavbarItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NavbarItemFindUniqueOrThrowArgs} args - Arguments to find a NavbarItem
     * @example
     * // Get one NavbarItem
     * const navbarItem = await prisma.navbarItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NavbarItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NavbarItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemFindFirstArgs} args - Arguments to find a NavbarItem
     * @example
     * // Get one NavbarItem
     * const navbarItem = await prisma.navbarItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NavbarItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemFindFirstArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NavbarItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemFindFirstOrThrowArgs} args - Arguments to find a NavbarItem
     * @example
     * // Get one NavbarItem
     * const navbarItem = await prisma.navbarItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NavbarItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NavbarItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavbarItems
     * const navbarItems = await prisma.navbarItem.findMany()
     * 
     * // Get first 10 NavbarItems
     * const navbarItems = await prisma.navbarItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const navbarItemWithIdOnly = await prisma.navbarItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NavbarItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NavbarItem.
     * @param {NavbarItemCreateArgs} args - Arguments to create a NavbarItem.
     * @example
     * // Create one NavbarItem
     * const NavbarItem = await prisma.navbarItem.create({
     *   data: {
     *     // ... data to create a NavbarItem
     *   }
     * })
     * 
    **/
    create<T extends NavbarItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemCreateArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NavbarItems.
     *     @param {NavbarItemCreateManyArgs} args - Arguments to create many NavbarItems.
     *     @example
     *     // Create many NavbarItems
     *     const navbarItem = await prisma.navbarItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NavbarItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavbarItem.
     * @param {NavbarItemDeleteArgs} args - Arguments to delete one NavbarItem.
     * @example
     * // Delete one NavbarItem
     * const NavbarItem = await prisma.navbarItem.delete({
     *   where: {
     *     // ... filter to delete one NavbarItem
     *   }
     * })
     * 
    **/
    delete<T extends NavbarItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemDeleteArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NavbarItem.
     * @param {NavbarItemUpdateArgs} args - Arguments to update one NavbarItem.
     * @example
     * // Update one NavbarItem
     * const navbarItem = await prisma.navbarItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NavbarItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemUpdateArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NavbarItems.
     * @param {NavbarItemDeleteManyArgs} args - Arguments to filter NavbarItems to delete.
     * @example
     * // Delete a few NavbarItems
     * const { count } = await prisma.navbarItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NavbarItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavbarItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavbarItems
     * const navbarItem = await prisma.navbarItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NavbarItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavbarItem.
     * @param {NavbarItemUpsertArgs} args - Arguments to update or create a NavbarItem.
     * @example
     * // Update or create a NavbarItem
     * const navbarItem = await prisma.navbarItem.upsert({
     *   create: {
     *     // ... data to create a NavbarItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavbarItem we want to update
     *   }
     * })
    **/
    upsert<T extends NavbarItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemUpsertArgs<ExtArgs>>
    ): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NavbarItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemCountArgs} args - Arguments to filter NavbarItems to count.
     * @example
     * // Count the number of NavbarItems
     * const count = await prisma.navbarItem.count({
     *   where: {
     *     // ... the filter for the NavbarItems we want to count
     *   }
     * })
    **/
    count<T extends NavbarItemCountArgs>(
      args?: Subset<T, NavbarItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavbarItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavbarItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavbarItemAggregateArgs>(args: Subset<T, NavbarItemAggregateArgs>): Prisma.PrismaPromise<GetNavbarItemAggregateType<T>>

    /**
     * Group by NavbarItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavbarItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavbarItemGroupByArgs['orderBy'] }
        : { orderBy?: NavbarItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavbarItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavbarItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavbarItem model
   */
  readonly fields: NavbarItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavbarItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavbarItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends NavbarItem$translationsArgs<ExtArgs> = {}>(args?: Subset<T, NavbarItem$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    dropdownGroups<T extends NavbarItem$dropdownGroupsArgs<ExtArgs> = {}>(args?: Subset<T, NavbarItem$dropdownGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findMany'> | Null>;

    dropdownItems<T extends NavbarItem$dropdownItemsArgs<ExtArgs> = {}>(args?: Subset<T, NavbarItem$dropdownItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    page<T extends NavbarItem$pageArgs<ExtArgs> = {}>(args?: Subset<T, NavbarItem$pageArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    article<T extends NavbarItem$articleArgs<ExtArgs> = {}>(args?: Subset<T, NavbarItem$articleArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NavbarItem model
   */ 
  interface NavbarItemFieldRefs {
    readonly id: FieldRef<"NavbarItem", 'String'>
    readonly isDropdown: FieldRef<"NavbarItem", 'Boolean'>
    readonly forArticle: FieldRef<"NavbarItem", 'Boolean'>
    readonly forPage: FieldRef<"NavbarItem", 'Boolean'>
    readonly pageId: FieldRef<"NavbarItem", 'String'>
    readonly articleId: FieldRef<"NavbarItem", 'String'>
    readonly createdAt: FieldRef<"NavbarItem", 'DateTime'>
    readonly updatedAt: FieldRef<"NavbarItem", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * NavbarItem findUnique
   */
  export type NavbarItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItem to fetch.
     */
    where: NavbarItemWhereUniqueInput
  }


  /**
   * NavbarItem findUniqueOrThrow
   */
  export type NavbarItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItem to fetch.
     */
    where: NavbarItemWhereUniqueInput
  }


  /**
   * NavbarItem findFirst
   */
  export type NavbarItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItem to fetch.
     */
    where?: NavbarItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItems to fetch.
     */
    orderBy?: NavbarItemOrderByWithRelationInput | NavbarItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavbarItems.
     */
    cursor?: NavbarItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavbarItems.
     */
    distinct?: NavbarItemScalarFieldEnum | NavbarItemScalarFieldEnum[]
  }


  /**
   * NavbarItem findFirstOrThrow
   */
  export type NavbarItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItem to fetch.
     */
    where?: NavbarItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItems to fetch.
     */
    orderBy?: NavbarItemOrderByWithRelationInput | NavbarItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavbarItems.
     */
    cursor?: NavbarItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavbarItems.
     */
    distinct?: NavbarItemScalarFieldEnum | NavbarItemScalarFieldEnum[]
  }


  /**
   * NavbarItem findMany
   */
  export type NavbarItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItems to fetch.
     */
    where?: NavbarItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItems to fetch.
     */
    orderBy?: NavbarItemOrderByWithRelationInput | NavbarItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavbarItems.
     */
    cursor?: NavbarItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItems.
     */
    skip?: number
    distinct?: NavbarItemScalarFieldEnum | NavbarItemScalarFieldEnum[]
  }


  /**
   * NavbarItem create
   */
  export type NavbarItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NavbarItem.
     */
    data: XOR<NavbarItemCreateInput, NavbarItemUncheckedCreateInput>
  }


  /**
   * NavbarItem createMany
   */
  export type NavbarItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavbarItems.
     */
    data: NavbarItemCreateManyInput | NavbarItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NavbarItem update
   */
  export type NavbarItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NavbarItem.
     */
    data: XOR<NavbarItemUpdateInput, NavbarItemUncheckedUpdateInput>
    /**
     * Choose, which NavbarItem to update.
     */
    where: NavbarItemWhereUniqueInput
  }


  /**
   * NavbarItem updateMany
   */
  export type NavbarItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavbarItems.
     */
    data: XOR<NavbarItemUpdateManyMutationInput, NavbarItemUncheckedUpdateManyInput>
    /**
     * Filter which NavbarItems to update
     */
    where?: NavbarItemWhereInput
  }


  /**
   * NavbarItem upsert
   */
  export type NavbarItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NavbarItem to update in case it exists.
     */
    where: NavbarItemWhereUniqueInput
    /**
     * In case the NavbarItem found by the `where` argument doesn't exist, create a new NavbarItem with this data.
     */
    create: XOR<NavbarItemCreateInput, NavbarItemUncheckedCreateInput>
    /**
     * In case the NavbarItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavbarItemUpdateInput, NavbarItemUncheckedUpdateInput>
  }


  /**
   * NavbarItem delete
   */
  export type NavbarItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    /**
     * Filter which NavbarItem to delete.
     */
    where: NavbarItemWhereUniqueInput
  }


  /**
   * NavbarItem deleteMany
   */
  export type NavbarItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavbarItems to delete
     */
    where?: NavbarItemWhereInput
  }


  /**
   * NavbarItem.translations
   */
  export type NavbarItem$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    where?: NavbarItemTranslationWhereInput
    orderBy?: NavbarItemTranslationOrderByWithRelationInput | NavbarItemTranslationOrderByWithRelationInput[]
    cursor?: NavbarItemTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NavbarItemTranslationScalarFieldEnum | NavbarItemTranslationScalarFieldEnum[]
  }


  /**
   * NavbarItem.dropdownGroups
   */
  export type NavbarItem$dropdownGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    where?: DropDownGroupWhereInput
    orderBy?: DropDownGroupOrderByWithRelationInput | DropDownGroupOrderByWithRelationInput[]
    cursor?: DropDownGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropDownGroupScalarFieldEnum | DropDownGroupScalarFieldEnum[]
  }


  /**
   * NavbarItem.dropdownItems
   */
  export type NavbarItem$dropdownItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    where?: DropdownItemWhereInput
    orderBy?: DropdownItemOrderByWithRelationInput | DropdownItemOrderByWithRelationInput[]
    cursor?: DropdownItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropdownItemScalarFieldEnum | DropdownItemScalarFieldEnum[]
  }


  /**
   * NavbarItem.page
   */
  export type NavbarItem$pageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }


  /**
   * NavbarItem.article
   */
  export type NavbarItem$articleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
  }


  /**
   * NavbarItem without action
   */
  export type NavbarItemDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
  }



  /**
   * Model NavbarItemTranslation
   */

  export type AggregateNavbarItemTranslation = {
    _count: NavbarItemTranslationCountAggregateOutputType | null
    _min: NavbarItemTranslationMinAggregateOutputType | null
    _max: NavbarItemTranslationMaxAggregateOutputType | null
  }

  export type NavbarItemTranslationMinAggregateOutputType = {
    id: string | null
    name: string | null
    lang: string | null
    navbarItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavbarItemTranslationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    lang: string | null
    navbarItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavbarItemTranslationCountAggregateOutputType = {
    id: number
    name: number
    lang: number
    navbarItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NavbarItemTranslationMinAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    navbarItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavbarItemTranslationMaxAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    navbarItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavbarItemTranslationCountAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    navbarItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NavbarItemTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavbarItemTranslation to aggregate.
     */
    where?: NavbarItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItemTranslations to fetch.
     */
    orderBy?: NavbarItemTranslationOrderByWithRelationInput | NavbarItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavbarItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavbarItemTranslations
    **/
    _count?: true | NavbarItemTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavbarItemTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavbarItemTranslationMaxAggregateInputType
  }

  export type GetNavbarItemTranslationAggregateType<T extends NavbarItemTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateNavbarItemTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavbarItemTranslation[P]>
      : GetScalarType<T[P], AggregateNavbarItemTranslation[P]>
  }




  export type NavbarItemTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NavbarItemTranslationWhereInput
    orderBy?: NavbarItemTranslationOrderByWithAggregationInput | NavbarItemTranslationOrderByWithAggregationInput[]
    by: NavbarItemTranslationScalarFieldEnum[] | NavbarItemTranslationScalarFieldEnum
    having?: NavbarItemTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavbarItemTranslationCountAggregateInputType | true
    _min?: NavbarItemTranslationMinAggregateInputType
    _max?: NavbarItemTranslationMaxAggregateInputType
  }

  export type NavbarItemTranslationGroupByOutputType = {
    id: string
    name: string
    lang: string
    navbarItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NavbarItemTranslationCountAggregateOutputType | null
    _min: NavbarItemTranslationMinAggregateOutputType | null
    _max: NavbarItemTranslationMaxAggregateOutputType | null
  }

  type GetNavbarItemTranslationGroupByPayload<T extends NavbarItemTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavbarItemTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavbarItemTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavbarItemTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], NavbarItemTranslationGroupByOutputType[P]>
        }
      >
    >


  export type NavbarItemTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lang?: boolean
    navbarItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    navbarItem?: boolean | NavbarItemTranslation$navbarItemArgs<ExtArgs>
  }, ExtArgs["result"]["navbarItemTranslation"]>

  export type NavbarItemTranslationSelectScalar = {
    id?: boolean
    name?: boolean
    lang?: boolean
    navbarItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NavbarItemTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    navbarItem?: boolean | NavbarItemTranslation$navbarItemArgs<ExtArgs>
  }


  export type $NavbarItemTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "NavbarItemTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      navbarItem: Prisma.$NavbarItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      lang: string
      navbarItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["navbarItemTranslation"]>
    composites: {}
  }


  type NavbarItemTranslationGetPayload<S extends boolean | null | undefined | NavbarItemTranslationDefaultArgs> = $Result.GetResult<Prisma.$NavbarItemTranslationPayload, S>

  type NavbarItemTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NavbarItemTranslationFindManyArgs, 'select' | 'include'> & {
      select?: NavbarItemTranslationCountAggregateInputType | true
    }

  export interface NavbarItemTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavbarItemTranslation'], meta: { name: 'NavbarItemTranslation' } }
    /**
     * Find zero or one NavbarItemTranslation that matches the filter.
     * @param {NavbarItemTranslationFindUniqueArgs} args - Arguments to find a NavbarItemTranslation
     * @example
     * // Get one NavbarItemTranslation
     * const navbarItemTranslation = await prisma.navbarItemTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NavbarItemTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NavbarItemTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NavbarItemTranslationFindUniqueOrThrowArgs} args - Arguments to find a NavbarItemTranslation
     * @example
     * // Get one NavbarItemTranslation
     * const navbarItemTranslation = await prisma.navbarItemTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NavbarItemTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NavbarItemTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationFindFirstArgs} args - Arguments to find a NavbarItemTranslation
     * @example
     * // Get one NavbarItemTranslation
     * const navbarItemTranslation = await prisma.navbarItemTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NavbarItemTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NavbarItemTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationFindFirstOrThrowArgs} args - Arguments to find a NavbarItemTranslation
     * @example
     * // Get one NavbarItemTranslation
     * const navbarItemTranslation = await prisma.navbarItemTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NavbarItemTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NavbarItemTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavbarItemTranslations
     * const navbarItemTranslations = await prisma.navbarItemTranslation.findMany()
     * 
     * // Get first 10 NavbarItemTranslations
     * const navbarItemTranslations = await prisma.navbarItemTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const navbarItemTranslationWithIdOnly = await prisma.navbarItemTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NavbarItemTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NavbarItemTranslation.
     * @param {NavbarItemTranslationCreateArgs} args - Arguments to create a NavbarItemTranslation.
     * @example
     * // Create one NavbarItemTranslation
     * const NavbarItemTranslation = await prisma.navbarItemTranslation.create({
     *   data: {
     *     // ... data to create a NavbarItemTranslation
     *   }
     * })
     * 
    **/
    create<T extends NavbarItemTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemTranslationCreateArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NavbarItemTranslations.
     *     @param {NavbarItemTranslationCreateManyArgs} args - Arguments to create many NavbarItemTranslations.
     *     @example
     *     // Create many NavbarItemTranslations
     *     const navbarItemTranslation = await prisma.navbarItemTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NavbarItemTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavbarItemTranslation.
     * @param {NavbarItemTranslationDeleteArgs} args - Arguments to delete one NavbarItemTranslation.
     * @example
     * // Delete one NavbarItemTranslation
     * const NavbarItemTranslation = await prisma.navbarItemTranslation.delete({
     *   where: {
     *     // ... filter to delete one NavbarItemTranslation
     *   }
     * })
     * 
    **/
    delete<T extends NavbarItemTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemTranslationDeleteArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NavbarItemTranslation.
     * @param {NavbarItemTranslationUpdateArgs} args - Arguments to update one NavbarItemTranslation.
     * @example
     * // Update one NavbarItemTranslation
     * const navbarItemTranslation = await prisma.navbarItemTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NavbarItemTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemTranslationUpdateArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NavbarItemTranslations.
     * @param {NavbarItemTranslationDeleteManyArgs} args - Arguments to filter NavbarItemTranslations to delete.
     * @example
     * // Delete a few NavbarItemTranslations
     * const { count } = await prisma.navbarItemTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NavbarItemTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavbarItemTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavbarItemTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavbarItemTranslations
     * const navbarItemTranslation = await prisma.navbarItemTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NavbarItemTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavbarItemTranslation.
     * @param {NavbarItemTranslationUpsertArgs} args - Arguments to update or create a NavbarItemTranslation.
     * @example
     * // Update or create a NavbarItemTranslation
     * const navbarItemTranslation = await prisma.navbarItemTranslation.upsert({
     *   create: {
     *     // ... data to create a NavbarItemTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavbarItemTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends NavbarItemTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NavbarItemTranslationUpsertArgs<ExtArgs>>
    ): Prisma__NavbarItemTranslationClient<$Result.GetResult<Prisma.$NavbarItemTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NavbarItemTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationCountArgs} args - Arguments to filter NavbarItemTranslations to count.
     * @example
     * // Count the number of NavbarItemTranslations
     * const count = await prisma.navbarItemTranslation.count({
     *   where: {
     *     // ... the filter for the NavbarItemTranslations we want to count
     *   }
     * })
    **/
    count<T extends NavbarItemTranslationCountArgs>(
      args?: Subset<T, NavbarItemTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavbarItemTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavbarItemTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavbarItemTranslationAggregateArgs>(args: Subset<T, NavbarItemTranslationAggregateArgs>): Prisma.PrismaPromise<GetNavbarItemTranslationAggregateType<T>>

    /**
     * Group by NavbarItemTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavbarItemTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavbarItemTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavbarItemTranslationGroupByArgs['orderBy'] }
        : { orderBy?: NavbarItemTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavbarItemTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavbarItemTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavbarItemTranslation model
   */
  readonly fields: NavbarItemTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavbarItemTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavbarItemTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    navbarItem<T extends NavbarItemTranslation$navbarItemArgs<ExtArgs> = {}>(args?: Subset<T, NavbarItemTranslation$navbarItemArgs<ExtArgs>>): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NavbarItemTranslation model
   */ 
  interface NavbarItemTranslationFieldRefs {
    readonly id: FieldRef<"NavbarItemTranslation", 'String'>
    readonly name: FieldRef<"NavbarItemTranslation", 'String'>
    readonly lang: FieldRef<"NavbarItemTranslation", 'String'>
    readonly navbarItemId: FieldRef<"NavbarItemTranslation", 'String'>
    readonly createdAt: FieldRef<"NavbarItemTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"NavbarItemTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * NavbarItemTranslation findUnique
   */
  export type NavbarItemTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItemTranslation to fetch.
     */
    where: NavbarItemTranslationWhereUniqueInput
  }


  /**
   * NavbarItemTranslation findUniqueOrThrow
   */
  export type NavbarItemTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItemTranslation to fetch.
     */
    where: NavbarItemTranslationWhereUniqueInput
  }


  /**
   * NavbarItemTranslation findFirst
   */
  export type NavbarItemTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItemTranslation to fetch.
     */
    where?: NavbarItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItemTranslations to fetch.
     */
    orderBy?: NavbarItemTranslationOrderByWithRelationInput | NavbarItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavbarItemTranslations.
     */
    cursor?: NavbarItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavbarItemTranslations.
     */
    distinct?: NavbarItemTranslationScalarFieldEnum | NavbarItemTranslationScalarFieldEnum[]
  }


  /**
   * NavbarItemTranslation findFirstOrThrow
   */
  export type NavbarItemTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItemTranslation to fetch.
     */
    where?: NavbarItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItemTranslations to fetch.
     */
    orderBy?: NavbarItemTranslationOrderByWithRelationInput | NavbarItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavbarItemTranslations.
     */
    cursor?: NavbarItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavbarItemTranslations.
     */
    distinct?: NavbarItemTranslationScalarFieldEnum | NavbarItemTranslationScalarFieldEnum[]
  }


  /**
   * NavbarItemTranslation findMany
   */
  export type NavbarItemTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavbarItemTranslations to fetch.
     */
    where?: NavbarItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavbarItemTranslations to fetch.
     */
    orderBy?: NavbarItemTranslationOrderByWithRelationInput | NavbarItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavbarItemTranslations.
     */
    cursor?: NavbarItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavbarItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavbarItemTranslations.
     */
    skip?: number
    distinct?: NavbarItemTranslationScalarFieldEnum | NavbarItemTranslationScalarFieldEnum[]
  }


  /**
   * NavbarItemTranslation create
   */
  export type NavbarItemTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a NavbarItemTranslation.
     */
    data: XOR<NavbarItemTranslationCreateInput, NavbarItemTranslationUncheckedCreateInput>
  }


  /**
   * NavbarItemTranslation createMany
   */
  export type NavbarItemTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavbarItemTranslations.
     */
    data: NavbarItemTranslationCreateManyInput | NavbarItemTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NavbarItemTranslation update
   */
  export type NavbarItemTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a NavbarItemTranslation.
     */
    data: XOR<NavbarItemTranslationUpdateInput, NavbarItemTranslationUncheckedUpdateInput>
    /**
     * Choose, which NavbarItemTranslation to update.
     */
    where: NavbarItemTranslationWhereUniqueInput
  }


  /**
   * NavbarItemTranslation updateMany
   */
  export type NavbarItemTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavbarItemTranslations.
     */
    data: XOR<NavbarItemTranslationUpdateManyMutationInput, NavbarItemTranslationUncheckedUpdateManyInput>
    /**
     * Filter which NavbarItemTranslations to update
     */
    where?: NavbarItemTranslationWhereInput
  }


  /**
   * NavbarItemTranslation upsert
   */
  export type NavbarItemTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the NavbarItemTranslation to update in case it exists.
     */
    where: NavbarItemTranslationWhereUniqueInput
    /**
     * In case the NavbarItemTranslation found by the `where` argument doesn't exist, create a new NavbarItemTranslation with this data.
     */
    create: XOR<NavbarItemTranslationCreateInput, NavbarItemTranslationUncheckedCreateInput>
    /**
     * In case the NavbarItemTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavbarItemTranslationUpdateInput, NavbarItemTranslationUncheckedUpdateInput>
  }


  /**
   * NavbarItemTranslation delete
   */
  export type NavbarItemTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
    /**
     * Filter which NavbarItemTranslation to delete.
     */
    where: NavbarItemTranslationWhereUniqueInput
  }


  /**
   * NavbarItemTranslation deleteMany
   */
  export type NavbarItemTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavbarItemTranslations to delete
     */
    where?: NavbarItemTranslationWhereInput
  }


  /**
   * NavbarItemTranslation.navbarItem
   */
  export type NavbarItemTranslation$navbarItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    where?: NavbarItemWhereInput
  }


  /**
   * NavbarItemTranslation without action
   */
  export type NavbarItemTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItemTranslation
     */
    select?: NavbarItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemTranslationInclude<ExtArgs> | null
  }



  /**
   * Model DropDownGroup
   */

  export type AggregateDropDownGroup = {
    _count: DropDownGroupCountAggregateOutputType | null
    _min: DropDownGroupMinAggregateOutputType | null
    _max: DropDownGroupMaxAggregateOutputType | null
  }

  export type DropDownGroupMinAggregateOutputType = {
    id: string | null
    navItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropDownGroupMaxAggregateOutputType = {
    id: string | null
    navItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropDownGroupCountAggregateOutputType = {
    id: number
    navItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DropDownGroupMinAggregateInputType = {
    id?: true
    navItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropDownGroupMaxAggregateInputType = {
    id?: true
    navItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropDownGroupCountAggregateInputType = {
    id?: true
    navItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DropDownGroupAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropDownGroup to aggregate.
     */
    where?: DropDownGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroups to fetch.
     */
    orderBy?: DropDownGroupOrderByWithRelationInput | DropDownGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropDownGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropDownGroups
    **/
    _count?: true | DropDownGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropDownGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropDownGroupMaxAggregateInputType
  }

  export type GetDropDownGroupAggregateType<T extends DropDownGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateDropDownGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropDownGroup[P]>
      : GetScalarType<T[P], AggregateDropDownGroup[P]>
  }




  export type DropDownGroupGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropDownGroupWhereInput
    orderBy?: DropDownGroupOrderByWithAggregationInput | DropDownGroupOrderByWithAggregationInput[]
    by: DropDownGroupScalarFieldEnum[] | DropDownGroupScalarFieldEnum
    having?: DropDownGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropDownGroupCountAggregateInputType | true
    _min?: DropDownGroupMinAggregateInputType
    _max?: DropDownGroupMaxAggregateInputType
  }

  export type DropDownGroupGroupByOutputType = {
    id: string
    navItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DropDownGroupCountAggregateOutputType | null
    _min: DropDownGroupMinAggregateOutputType | null
    _max: DropDownGroupMaxAggregateOutputType | null
  }

  type GetDropDownGroupGroupByPayload<T extends DropDownGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropDownGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropDownGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropDownGroupGroupByOutputType[P]>
            : GetScalarType<T[P], DropDownGroupGroupByOutputType[P]>
        }
      >
    >


  export type DropDownGroupSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    navItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | DropDownGroup$translationsArgs<ExtArgs>
    navItem?: boolean | DropDownGroup$navItemArgs<ExtArgs>
    dropdownItems?: boolean | DropDownGroup$dropdownItemsArgs<ExtArgs>
    _count?: boolean | DropDownGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dropDownGroup"]>

  export type DropDownGroupSelectScalar = {
    id?: boolean
    navItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DropDownGroupInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | DropDownGroup$translationsArgs<ExtArgs>
    navItem?: boolean | DropDownGroup$navItemArgs<ExtArgs>
    dropdownItems?: boolean | DropDownGroup$dropdownItemsArgs<ExtArgs>
    _count?: boolean | DropDownGroupCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DropDownGroupPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DropDownGroup"
    objects: {
      translations: Prisma.$DropDownGroupTranslationPayload<ExtArgs>[]
      navItem: Prisma.$NavbarItemPayload<ExtArgs> | null
      dropdownItems: Prisma.$DropdownItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      navItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dropDownGroup"]>
    composites: {}
  }


  type DropDownGroupGetPayload<S extends boolean | null | undefined | DropDownGroupDefaultArgs> = $Result.GetResult<Prisma.$DropDownGroupPayload, S>

  type DropDownGroupCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DropDownGroupFindManyArgs, 'select' | 'include'> & {
      select?: DropDownGroupCountAggregateInputType | true
    }

  export interface DropDownGroupDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropDownGroup'], meta: { name: 'DropDownGroup' } }
    /**
     * Find zero or one DropDownGroup that matches the filter.
     * @param {DropDownGroupFindUniqueArgs} args - Arguments to find a DropDownGroup
     * @example
     * // Get one DropDownGroup
     * const dropDownGroup = await prisma.dropDownGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DropDownGroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupFindUniqueArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DropDownGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DropDownGroupFindUniqueOrThrowArgs} args - Arguments to find a DropDownGroup
     * @example
     * // Get one DropDownGroup
     * const dropDownGroup = await prisma.dropDownGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DropDownGroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DropDownGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupFindFirstArgs} args - Arguments to find a DropDownGroup
     * @example
     * // Get one DropDownGroup
     * const dropDownGroup = await prisma.dropDownGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DropDownGroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupFindFirstArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DropDownGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupFindFirstOrThrowArgs} args - Arguments to find a DropDownGroup
     * @example
     * // Get one DropDownGroup
     * const dropDownGroup = await prisma.dropDownGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DropDownGroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DropDownGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropDownGroups
     * const dropDownGroups = await prisma.dropDownGroup.findMany()
     * 
     * // Get first 10 DropDownGroups
     * const dropDownGroups = await prisma.dropDownGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropDownGroupWithIdOnly = await prisma.dropDownGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DropDownGroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DropDownGroup.
     * @param {DropDownGroupCreateArgs} args - Arguments to create a DropDownGroup.
     * @example
     * // Create one DropDownGroup
     * const DropDownGroup = await prisma.dropDownGroup.create({
     *   data: {
     *     // ... data to create a DropDownGroup
     *   }
     * })
     * 
    **/
    create<T extends DropDownGroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupCreateArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DropDownGroups.
     *     @param {DropDownGroupCreateManyArgs} args - Arguments to create many DropDownGroups.
     *     @example
     *     // Create many DropDownGroups
     *     const dropDownGroup = await prisma.dropDownGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DropDownGroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropDownGroup.
     * @param {DropDownGroupDeleteArgs} args - Arguments to delete one DropDownGroup.
     * @example
     * // Delete one DropDownGroup
     * const DropDownGroup = await prisma.dropDownGroup.delete({
     *   where: {
     *     // ... filter to delete one DropDownGroup
     *   }
     * })
     * 
    **/
    delete<T extends DropDownGroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupDeleteArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DropDownGroup.
     * @param {DropDownGroupUpdateArgs} args - Arguments to update one DropDownGroup.
     * @example
     * // Update one DropDownGroup
     * const dropDownGroup = await prisma.dropDownGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DropDownGroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupUpdateArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DropDownGroups.
     * @param {DropDownGroupDeleteManyArgs} args - Arguments to filter DropDownGroups to delete.
     * @example
     * // Delete a few DropDownGroups
     * const { count } = await prisma.dropDownGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DropDownGroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropDownGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropDownGroups
     * const dropDownGroup = await prisma.dropDownGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DropDownGroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropDownGroup.
     * @param {DropDownGroupUpsertArgs} args - Arguments to update or create a DropDownGroup.
     * @example
     * // Update or create a DropDownGroup
     * const dropDownGroup = await prisma.dropDownGroup.upsert({
     *   create: {
     *     // ... data to create a DropDownGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropDownGroup we want to update
     *   }
     * })
    **/
    upsert<T extends DropDownGroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupUpsertArgs<ExtArgs>>
    ): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DropDownGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupCountArgs} args - Arguments to filter DropDownGroups to count.
     * @example
     * // Count the number of DropDownGroups
     * const count = await prisma.dropDownGroup.count({
     *   where: {
     *     // ... the filter for the DropDownGroups we want to count
     *   }
     * })
    **/
    count<T extends DropDownGroupCountArgs>(
      args?: Subset<T, DropDownGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropDownGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropDownGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropDownGroupAggregateArgs>(args: Subset<T, DropDownGroupAggregateArgs>): Prisma.PrismaPromise<GetDropDownGroupAggregateType<T>>

    /**
     * Group by DropDownGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropDownGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropDownGroupGroupByArgs['orderBy'] }
        : { orderBy?: DropDownGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropDownGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropDownGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropDownGroup model
   */
  readonly fields: DropDownGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropDownGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropDownGroupClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends DropDownGroup$translationsArgs<ExtArgs> = {}>(args?: Subset<T, DropDownGroup$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    navItem<T extends DropDownGroup$navItemArgs<ExtArgs> = {}>(args?: Subset<T, DropDownGroup$navItemArgs<ExtArgs>>): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    dropdownItems<T extends DropDownGroup$dropdownItemsArgs<ExtArgs> = {}>(args?: Subset<T, DropDownGroup$dropdownItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DropDownGroup model
   */ 
  interface DropDownGroupFieldRefs {
    readonly id: FieldRef<"DropDownGroup", 'String'>
    readonly navItemId: FieldRef<"DropDownGroup", 'String'>
    readonly createdAt: FieldRef<"DropDownGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"DropDownGroup", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DropDownGroup findUnique
   */
  export type DropDownGroupFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroup to fetch.
     */
    where: DropDownGroupWhereUniqueInput
  }


  /**
   * DropDownGroup findUniqueOrThrow
   */
  export type DropDownGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroup to fetch.
     */
    where: DropDownGroupWhereUniqueInput
  }


  /**
   * DropDownGroup findFirst
   */
  export type DropDownGroupFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroup to fetch.
     */
    where?: DropDownGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroups to fetch.
     */
    orderBy?: DropDownGroupOrderByWithRelationInput | DropDownGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropDownGroups.
     */
    cursor?: DropDownGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropDownGroups.
     */
    distinct?: DropDownGroupScalarFieldEnum | DropDownGroupScalarFieldEnum[]
  }


  /**
   * DropDownGroup findFirstOrThrow
   */
  export type DropDownGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroup to fetch.
     */
    where?: DropDownGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroups to fetch.
     */
    orderBy?: DropDownGroupOrderByWithRelationInput | DropDownGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropDownGroups.
     */
    cursor?: DropDownGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropDownGroups.
     */
    distinct?: DropDownGroupScalarFieldEnum | DropDownGroupScalarFieldEnum[]
  }


  /**
   * DropDownGroup findMany
   */
  export type DropDownGroupFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroups to fetch.
     */
    where?: DropDownGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroups to fetch.
     */
    orderBy?: DropDownGroupOrderByWithRelationInput | DropDownGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropDownGroups.
     */
    cursor?: DropDownGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroups.
     */
    skip?: number
    distinct?: DropDownGroupScalarFieldEnum | DropDownGroupScalarFieldEnum[]
  }


  /**
   * DropDownGroup create
   */
  export type DropDownGroupCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a DropDownGroup.
     */
    data: XOR<DropDownGroupCreateInput, DropDownGroupUncheckedCreateInput>
  }


  /**
   * DropDownGroup createMany
   */
  export type DropDownGroupCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropDownGroups.
     */
    data: DropDownGroupCreateManyInput | DropDownGroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DropDownGroup update
   */
  export type DropDownGroupUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a DropDownGroup.
     */
    data: XOR<DropDownGroupUpdateInput, DropDownGroupUncheckedUpdateInput>
    /**
     * Choose, which DropDownGroup to update.
     */
    where: DropDownGroupWhereUniqueInput
  }


  /**
   * DropDownGroup updateMany
   */
  export type DropDownGroupUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropDownGroups.
     */
    data: XOR<DropDownGroupUpdateManyMutationInput, DropDownGroupUncheckedUpdateManyInput>
    /**
     * Filter which DropDownGroups to update
     */
    where?: DropDownGroupWhereInput
  }


  /**
   * DropDownGroup upsert
   */
  export type DropDownGroupUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the DropDownGroup to update in case it exists.
     */
    where: DropDownGroupWhereUniqueInput
    /**
     * In case the DropDownGroup found by the `where` argument doesn't exist, create a new DropDownGroup with this data.
     */
    create: XOR<DropDownGroupCreateInput, DropDownGroupUncheckedCreateInput>
    /**
     * In case the DropDownGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropDownGroupUpdateInput, DropDownGroupUncheckedUpdateInput>
  }


  /**
   * DropDownGroup delete
   */
  export type DropDownGroupDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    /**
     * Filter which DropDownGroup to delete.
     */
    where: DropDownGroupWhereUniqueInput
  }


  /**
   * DropDownGroup deleteMany
   */
  export type DropDownGroupDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropDownGroups to delete
     */
    where?: DropDownGroupWhereInput
  }


  /**
   * DropDownGroup.translations
   */
  export type DropDownGroup$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    where?: DropDownGroupTranslationWhereInput
    orderBy?: DropDownGroupTranslationOrderByWithRelationInput | DropDownGroupTranslationOrderByWithRelationInput[]
    cursor?: DropDownGroupTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropDownGroupTranslationScalarFieldEnum | DropDownGroupTranslationScalarFieldEnum[]
  }


  /**
   * DropDownGroup.navItem
   */
  export type DropDownGroup$navItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    where?: NavbarItemWhereInput
  }


  /**
   * DropDownGroup.dropdownItems
   */
  export type DropDownGroup$dropdownItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    where?: DropdownItemWhereInput
    orderBy?: DropdownItemOrderByWithRelationInput | DropdownItemOrderByWithRelationInput[]
    cursor?: DropdownItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropdownItemScalarFieldEnum | DropdownItemScalarFieldEnum[]
  }


  /**
   * DropDownGroup without action
   */
  export type DropDownGroupDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
  }



  /**
   * Model DropDownGroupTranslation
   */

  export type AggregateDropDownGroupTranslation = {
    _count: DropDownGroupTranslationCountAggregateOutputType | null
    _min: DropDownGroupTranslationMinAggregateOutputType | null
    _max: DropDownGroupTranslationMaxAggregateOutputType | null
  }

  export type DropDownGroupTranslationMinAggregateOutputType = {
    id: string | null
    name: string | null
    lang: string | null
    dropdownGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropDownGroupTranslationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    lang: string | null
    dropdownGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropDownGroupTranslationCountAggregateOutputType = {
    id: number
    name: number
    lang: number
    dropdownGroupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DropDownGroupTranslationMinAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    dropdownGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropDownGroupTranslationMaxAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    dropdownGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropDownGroupTranslationCountAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    dropdownGroupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DropDownGroupTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropDownGroupTranslation to aggregate.
     */
    where?: DropDownGroupTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroupTranslations to fetch.
     */
    orderBy?: DropDownGroupTranslationOrderByWithRelationInput | DropDownGroupTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropDownGroupTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroupTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroupTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropDownGroupTranslations
    **/
    _count?: true | DropDownGroupTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropDownGroupTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropDownGroupTranslationMaxAggregateInputType
  }

  export type GetDropDownGroupTranslationAggregateType<T extends DropDownGroupTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateDropDownGroupTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropDownGroupTranslation[P]>
      : GetScalarType<T[P], AggregateDropDownGroupTranslation[P]>
  }




  export type DropDownGroupTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropDownGroupTranslationWhereInput
    orderBy?: DropDownGroupTranslationOrderByWithAggregationInput | DropDownGroupTranslationOrderByWithAggregationInput[]
    by: DropDownGroupTranslationScalarFieldEnum[] | DropDownGroupTranslationScalarFieldEnum
    having?: DropDownGroupTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropDownGroupTranslationCountAggregateInputType | true
    _min?: DropDownGroupTranslationMinAggregateInputType
    _max?: DropDownGroupTranslationMaxAggregateInputType
  }

  export type DropDownGroupTranslationGroupByOutputType = {
    id: string
    name: string
    lang: string
    dropdownGroupId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DropDownGroupTranslationCountAggregateOutputType | null
    _min: DropDownGroupTranslationMinAggregateOutputType | null
    _max: DropDownGroupTranslationMaxAggregateOutputType | null
  }

  type GetDropDownGroupTranslationGroupByPayload<T extends DropDownGroupTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropDownGroupTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropDownGroupTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropDownGroupTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], DropDownGroupTranslationGroupByOutputType[P]>
        }
      >
    >


  export type DropDownGroupTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lang?: boolean
    dropdownGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    dropdownGroup?: boolean | DropDownGroupTranslation$dropdownGroupArgs<ExtArgs>
  }, ExtArgs["result"]["dropDownGroupTranslation"]>

  export type DropDownGroupTranslationSelectScalar = {
    id?: boolean
    name?: boolean
    lang?: boolean
    dropdownGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DropDownGroupTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    dropdownGroup?: boolean | DropDownGroupTranslation$dropdownGroupArgs<ExtArgs>
  }


  export type $DropDownGroupTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DropDownGroupTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      dropdownGroup: Prisma.$DropDownGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      lang: string
      dropdownGroupId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dropDownGroupTranslation"]>
    composites: {}
  }


  type DropDownGroupTranslationGetPayload<S extends boolean | null | undefined | DropDownGroupTranslationDefaultArgs> = $Result.GetResult<Prisma.$DropDownGroupTranslationPayload, S>

  type DropDownGroupTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DropDownGroupTranslationFindManyArgs, 'select' | 'include'> & {
      select?: DropDownGroupTranslationCountAggregateInputType | true
    }

  export interface DropDownGroupTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropDownGroupTranslation'], meta: { name: 'DropDownGroupTranslation' } }
    /**
     * Find zero or one DropDownGroupTranslation that matches the filter.
     * @param {DropDownGroupTranslationFindUniqueArgs} args - Arguments to find a DropDownGroupTranslation
     * @example
     * // Get one DropDownGroupTranslation
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DropDownGroupTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DropDownGroupTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DropDownGroupTranslationFindUniqueOrThrowArgs} args - Arguments to find a DropDownGroupTranslation
     * @example
     * // Get one DropDownGroupTranslation
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DropDownGroupTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DropDownGroupTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationFindFirstArgs} args - Arguments to find a DropDownGroupTranslation
     * @example
     * // Get one DropDownGroupTranslation
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DropDownGroupTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DropDownGroupTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationFindFirstOrThrowArgs} args - Arguments to find a DropDownGroupTranslation
     * @example
     * // Get one DropDownGroupTranslation
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DropDownGroupTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DropDownGroupTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropDownGroupTranslations
     * const dropDownGroupTranslations = await prisma.dropDownGroupTranslation.findMany()
     * 
     * // Get first 10 DropDownGroupTranslations
     * const dropDownGroupTranslations = await prisma.dropDownGroupTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropDownGroupTranslationWithIdOnly = await prisma.dropDownGroupTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DropDownGroupTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DropDownGroupTranslation.
     * @param {DropDownGroupTranslationCreateArgs} args - Arguments to create a DropDownGroupTranslation.
     * @example
     * // Create one DropDownGroupTranslation
     * const DropDownGroupTranslation = await prisma.dropDownGroupTranslation.create({
     *   data: {
     *     // ... data to create a DropDownGroupTranslation
     *   }
     * })
     * 
    **/
    create<T extends DropDownGroupTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupTranslationCreateArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DropDownGroupTranslations.
     *     @param {DropDownGroupTranslationCreateManyArgs} args - Arguments to create many DropDownGroupTranslations.
     *     @example
     *     // Create many DropDownGroupTranslations
     *     const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DropDownGroupTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropDownGroupTranslation.
     * @param {DropDownGroupTranslationDeleteArgs} args - Arguments to delete one DropDownGroupTranslation.
     * @example
     * // Delete one DropDownGroupTranslation
     * const DropDownGroupTranslation = await prisma.dropDownGroupTranslation.delete({
     *   where: {
     *     // ... filter to delete one DropDownGroupTranslation
     *   }
     * })
     * 
    **/
    delete<T extends DropDownGroupTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupTranslationDeleteArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DropDownGroupTranslation.
     * @param {DropDownGroupTranslationUpdateArgs} args - Arguments to update one DropDownGroupTranslation.
     * @example
     * // Update one DropDownGroupTranslation
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DropDownGroupTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupTranslationUpdateArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DropDownGroupTranslations.
     * @param {DropDownGroupTranslationDeleteManyArgs} args - Arguments to filter DropDownGroupTranslations to delete.
     * @example
     * // Delete a few DropDownGroupTranslations
     * const { count } = await prisma.dropDownGroupTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DropDownGroupTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropDownGroupTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropDownGroupTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropDownGroupTranslations
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DropDownGroupTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropDownGroupTranslation.
     * @param {DropDownGroupTranslationUpsertArgs} args - Arguments to update or create a DropDownGroupTranslation.
     * @example
     * // Update or create a DropDownGroupTranslation
     * const dropDownGroupTranslation = await prisma.dropDownGroupTranslation.upsert({
     *   create: {
     *     // ... data to create a DropDownGroupTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropDownGroupTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends DropDownGroupTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DropDownGroupTranslationUpsertArgs<ExtArgs>>
    ): Prisma__DropDownGroupTranslationClient<$Result.GetResult<Prisma.$DropDownGroupTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DropDownGroupTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationCountArgs} args - Arguments to filter DropDownGroupTranslations to count.
     * @example
     * // Count the number of DropDownGroupTranslations
     * const count = await prisma.dropDownGroupTranslation.count({
     *   where: {
     *     // ... the filter for the DropDownGroupTranslations we want to count
     *   }
     * })
    **/
    count<T extends DropDownGroupTranslationCountArgs>(
      args?: Subset<T, DropDownGroupTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropDownGroupTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropDownGroupTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropDownGroupTranslationAggregateArgs>(args: Subset<T, DropDownGroupTranslationAggregateArgs>): Prisma.PrismaPromise<GetDropDownGroupTranslationAggregateType<T>>

    /**
     * Group by DropDownGroupTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropDownGroupTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropDownGroupTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropDownGroupTranslationGroupByArgs['orderBy'] }
        : { orderBy?: DropDownGroupTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropDownGroupTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropDownGroupTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropDownGroupTranslation model
   */
  readonly fields: DropDownGroupTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropDownGroupTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropDownGroupTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dropdownGroup<T extends DropDownGroupTranslation$dropdownGroupArgs<ExtArgs> = {}>(args?: Subset<T, DropDownGroupTranslation$dropdownGroupArgs<ExtArgs>>): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DropDownGroupTranslation model
   */ 
  interface DropDownGroupTranslationFieldRefs {
    readonly id: FieldRef<"DropDownGroupTranslation", 'String'>
    readonly name: FieldRef<"DropDownGroupTranslation", 'String'>
    readonly lang: FieldRef<"DropDownGroupTranslation", 'String'>
    readonly dropdownGroupId: FieldRef<"DropDownGroupTranslation", 'String'>
    readonly createdAt: FieldRef<"DropDownGroupTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"DropDownGroupTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DropDownGroupTranslation findUnique
   */
  export type DropDownGroupTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroupTranslation to fetch.
     */
    where: DropDownGroupTranslationWhereUniqueInput
  }


  /**
   * DropDownGroupTranslation findUniqueOrThrow
   */
  export type DropDownGroupTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroupTranslation to fetch.
     */
    where: DropDownGroupTranslationWhereUniqueInput
  }


  /**
   * DropDownGroupTranslation findFirst
   */
  export type DropDownGroupTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroupTranslation to fetch.
     */
    where?: DropDownGroupTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroupTranslations to fetch.
     */
    orderBy?: DropDownGroupTranslationOrderByWithRelationInput | DropDownGroupTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropDownGroupTranslations.
     */
    cursor?: DropDownGroupTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroupTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroupTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropDownGroupTranslations.
     */
    distinct?: DropDownGroupTranslationScalarFieldEnum | DropDownGroupTranslationScalarFieldEnum[]
  }


  /**
   * DropDownGroupTranslation findFirstOrThrow
   */
  export type DropDownGroupTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroupTranslation to fetch.
     */
    where?: DropDownGroupTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroupTranslations to fetch.
     */
    orderBy?: DropDownGroupTranslationOrderByWithRelationInput | DropDownGroupTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropDownGroupTranslations.
     */
    cursor?: DropDownGroupTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroupTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroupTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropDownGroupTranslations.
     */
    distinct?: DropDownGroupTranslationScalarFieldEnum | DropDownGroupTranslationScalarFieldEnum[]
  }


  /**
   * DropDownGroupTranslation findMany
   */
  export type DropDownGroupTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropDownGroupTranslations to fetch.
     */
    where?: DropDownGroupTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropDownGroupTranslations to fetch.
     */
    orderBy?: DropDownGroupTranslationOrderByWithRelationInput | DropDownGroupTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropDownGroupTranslations.
     */
    cursor?: DropDownGroupTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropDownGroupTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropDownGroupTranslations.
     */
    skip?: number
    distinct?: DropDownGroupTranslationScalarFieldEnum | DropDownGroupTranslationScalarFieldEnum[]
  }


  /**
   * DropDownGroupTranslation create
   */
  export type DropDownGroupTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a DropDownGroupTranslation.
     */
    data: XOR<DropDownGroupTranslationCreateInput, DropDownGroupTranslationUncheckedCreateInput>
  }


  /**
   * DropDownGroupTranslation createMany
   */
  export type DropDownGroupTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropDownGroupTranslations.
     */
    data: DropDownGroupTranslationCreateManyInput | DropDownGroupTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DropDownGroupTranslation update
   */
  export type DropDownGroupTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a DropDownGroupTranslation.
     */
    data: XOR<DropDownGroupTranslationUpdateInput, DropDownGroupTranslationUncheckedUpdateInput>
    /**
     * Choose, which DropDownGroupTranslation to update.
     */
    where: DropDownGroupTranslationWhereUniqueInput
  }


  /**
   * DropDownGroupTranslation updateMany
   */
  export type DropDownGroupTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropDownGroupTranslations.
     */
    data: XOR<DropDownGroupTranslationUpdateManyMutationInput, DropDownGroupTranslationUncheckedUpdateManyInput>
    /**
     * Filter which DropDownGroupTranslations to update
     */
    where?: DropDownGroupTranslationWhereInput
  }


  /**
   * DropDownGroupTranslation upsert
   */
  export type DropDownGroupTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the DropDownGroupTranslation to update in case it exists.
     */
    where: DropDownGroupTranslationWhereUniqueInput
    /**
     * In case the DropDownGroupTranslation found by the `where` argument doesn't exist, create a new DropDownGroupTranslation with this data.
     */
    create: XOR<DropDownGroupTranslationCreateInput, DropDownGroupTranslationUncheckedCreateInput>
    /**
     * In case the DropDownGroupTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropDownGroupTranslationUpdateInput, DropDownGroupTranslationUncheckedUpdateInput>
  }


  /**
   * DropDownGroupTranslation delete
   */
  export type DropDownGroupTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
    /**
     * Filter which DropDownGroupTranslation to delete.
     */
    where: DropDownGroupTranslationWhereUniqueInput
  }


  /**
   * DropDownGroupTranslation deleteMany
   */
  export type DropDownGroupTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropDownGroupTranslations to delete
     */
    where?: DropDownGroupTranslationWhereInput
  }


  /**
   * DropDownGroupTranslation.dropdownGroup
   */
  export type DropDownGroupTranslation$dropdownGroupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    where?: DropDownGroupWhereInput
  }


  /**
   * DropDownGroupTranslation without action
   */
  export type DropDownGroupTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroupTranslation
     */
    select?: DropDownGroupTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupTranslationInclude<ExtArgs> | null
  }



  /**
   * Model DropdownItem
   */

  export type AggregateDropdownItem = {
    _count: DropdownItemCountAggregateOutputType | null
    _min: DropdownItemMinAggregateOutputType | null
    _max: DropdownItemMaxAggregateOutputType | null
  }

  export type DropdownItemMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    pageId: string | null
    forGroup: boolean | null
    forArticle: boolean | null
    forPage: boolean | null
    articleId: string | null
    navItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropdownItemMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    pageId: string | null
    forGroup: boolean | null
    forArticle: boolean | null
    forPage: boolean | null
    articleId: string | null
    navItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropdownItemCountAggregateOutputType = {
    id: number
    groupId: number
    pageId: number
    forGroup: number
    forArticle: number
    forPage: number
    articleId: number
    navItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DropdownItemMinAggregateInputType = {
    id?: true
    groupId?: true
    pageId?: true
    forGroup?: true
    forArticle?: true
    forPage?: true
    articleId?: true
    navItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropdownItemMaxAggregateInputType = {
    id?: true
    groupId?: true
    pageId?: true
    forGroup?: true
    forArticle?: true
    forPage?: true
    articleId?: true
    navItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropdownItemCountAggregateInputType = {
    id?: true
    groupId?: true
    pageId?: true
    forGroup?: true
    forArticle?: true
    forPage?: true
    articleId?: true
    navItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DropdownItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropdownItem to aggregate.
     */
    where?: DropdownItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItems to fetch.
     */
    orderBy?: DropdownItemOrderByWithRelationInput | DropdownItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropdownItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropdownItems
    **/
    _count?: true | DropdownItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropdownItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropdownItemMaxAggregateInputType
  }

  export type GetDropdownItemAggregateType<T extends DropdownItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDropdownItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropdownItem[P]>
      : GetScalarType<T[P], AggregateDropdownItem[P]>
  }




  export type DropdownItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropdownItemWhereInput
    orderBy?: DropdownItemOrderByWithAggregationInput | DropdownItemOrderByWithAggregationInput[]
    by: DropdownItemScalarFieldEnum[] | DropdownItemScalarFieldEnum
    having?: DropdownItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropdownItemCountAggregateInputType | true
    _min?: DropdownItemMinAggregateInputType
    _max?: DropdownItemMaxAggregateInputType
  }

  export type DropdownItemGroupByOutputType = {
    id: string
    groupId: string | null
    pageId: string | null
    forGroup: boolean
    forArticle: boolean
    forPage: boolean
    articleId: string | null
    navItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DropdownItemCountAggregateOutputType | null
    _min: DropdownItemMinAggregateOutputType | null
    _max: DropdownItemMaxAggregateOutputType | null
  }

  type GetDropdownItemGroupByPayload<T extends DropdownItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropdownItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropdownItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropdownItemGroupByOutputType[P]>
            : GetScalarType<T[P], DropdownItemGroupByOutputType[P]>
        }
      >
    >


  export type DropdownItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    pageId?: boolean
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: boolean
    navItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | DropdownItem$translationsArgs<ExtArgs>
    group?: boolean | DropdownItem$groupArgs<ExtArgs>
    page?: boolean | DropdownItem$pageArgs<ExtArgs>
    article?: boolean | DropdownItem$articleArgs<ExtArgs>
    navItem?: boolean | DropdownItem$navItemArgs<ExtArgs>
    _count?: boolean | DropdownItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dropdownItem"]>

  export type DropdownItemSelectScalar = {
    id?: boolean
    groupId?: boolean
    pageId?: boolean
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: boolean
    navItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DropdownItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | DropdownItem$translationsArgs<ExtArgs>
    group?: boolean | DropdownItem$groupArgs<ExtArgs>
    page?: boolean | DropdownItem$pageArgs<ExtArgs>
    article?: boolean | DropdownItem$articleArgs<ExtArgs>
    navItem?: boolean | DropdownItem$navItemArgs<ExtArgs>
    _count?: boolean | DropdownItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DropdownItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DropdownItem"
    objects: {
      translations: Prisma.$DropdownItemTranslationPayload<ExtArgs>[]
      group: Prisma.$DropDownGroupPayload<ExtArgs> | null
      page: Prisma.$PagePayload<ExtArgs> | null
      article: Prisma.$ArticlePayload<ExtArgs> | null
      navItem: Prisma.$NavbarItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      groupId: string | null
      pageId: string | null
      forGroup: boolean
      forArticle: boolean
      forPage: boolean
      articleId: string | null
      navItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dropdownItem"]>
    composites: {}
  }


  type DropdownItemGetPayload<S extends boolean | null | undefined | DropdownItemDefaultArgs> = $Result.GetResult<Prisma.$DropdownItemPayload, S>

  type DropdownItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DropdownItemFindManyArgs, 'select' | 'include'> & {
      select?: DropdownItemCountAggregateInputType | true
    }

  export interface DropdownItemDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropdownItem'], meta: { name: 'DropdownItem' } }
    /**
     * Find zero or one DropdownItem that matches the filter.
     * @param {DropdownItemFindUniqueArgs} args - Arguments to find a DropdownItem
     * @example
     * // Get one DropdownItem
     * const dropdownItem = await prisma.dropdownItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DropdownItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemFindUniqueArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DropdownItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DropdownItemFindUniqueOrThrowArgs} args - Arguments to find a DropdownItem
     * @example
     * // Get one DropdownItem
     * const dropdownItem = await prisma.dropdownItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DropdownItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DropdownItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemFindFirstArgs} args - Arguments to find a DropdownItem
     * @example
     * // Get one DropdownItem
     * const dropdownItem = await prisma.dropdownItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DropdownItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemFindFirstArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DropdownItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemFindFirstOrThrowArgs} args - Arguments to find a DropdownItem
     * @example
     * // Get one DropdownItem
     * const dropdownItem = await prisma.dropdownItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DropdownItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DropdownItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropdownItems
     * const dropdownItems = await prisma.dropdownItem.findMany()
     * 
     * // Get first 10 DropdownItems
     * const dropdownItems = await prisma.dropdownItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropdownItemWithIdOnly = await prisma.dropdownItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DropdownItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DropdownItem.
     * @param {DropdownItemCreateArgs} args - Arguments to create a DropdownItem.
     * @example
     * // Create one DropdownItem
     * const DropdownItem = await prisma.dropdownItem.create({
     *   data: {
     *     // ... data to create a DropdownItem
     *   }
     * })
     * 
    **/
    create<T extends DropdownItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemCreateArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DropdownItems.
     *     @param {DropdownItemCreateManyArgs} args - Arguments to create many DropdownItems.
     *     @example
     *     // Create many DropdownItems
     *     const dropdownItem = await prisma.dropdownItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DropdownItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropdownItem.
     * @param {DropdownItemDeleteArgs} args - Arguments to delete one DropdownItem.
     * @example
     * // Delete one DropdownItem
     * const DropdownItem = await prisma.dropdownItem.delete({
     *   where: {
     *     // ... filter to delete one DropdownItem
     *   }
     * })
     * 
    **/
    delete<T extends DropdownItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemDeleteArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DropdownItem.
     * @param {DropdownItemUpdateArgs} args - Arguments to update one DropdownItem.
     * @example
     * // Update one DropdownItem
     * const dropdownItem = await prisma.dropdownItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DropdownItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemUpdateArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DropdownItems.
     * @param {DropdownItemDeleteManyArgs} args - Arguments to filter DropdownItems to delete.
     * @example
     * // Delete a few DropdownItems
     * const { count } = await prisma.dropdownItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DropdownItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropdownItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropdownItems
     * const dropdownItem = await prisma.dropdownItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DropdownItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropdownItem.
     * @param {DropdownItemUpsertArgs} args - Arguments to update or create a DropdownItem.
     * @example
     * // Update or create a DropdownItem
     * const dropdownItem = await prisma.dropdownItem.upsert({
     *   create: {
     *     // ... data to create a DropdownItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropdownItem we want to update
     *   }
     * })
    **/
    upsert<T extends DropdownItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemUpsertArgs<ExtArgs>>
    ): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DropdownItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemCountArgs} args - Arguments to filter DropdownItems to count.
     * @example
     * // Count the number of DropdownItems
     * const count = await prisma.dropdownItem.count({
     *   where: {
     *     // ... the filter for the DropdownItems we want to count
     *   }
     * })
    **/
    count<T extends DropdownItemCountArgs>(
      args?: Subset<T, DropdownItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropdownItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropdownItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropdownItemAggregateArgs>(args: Subset<T, DropdownItemAggregateArgs>): Prisma.PrismaPromise<GetDropdownItemAggregateType<T>>

    /**
     * Group by DropdownItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropdownItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropdownItemGroupByArgs['orderBy'] }
        : { orderBy?: DropdownItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropdownItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropdownItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropdownItem model
   */
  readonly fields: DropdownItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropdownItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropdownItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends DropdownItem$translationsArgs<ExtArgs> = {}>(args?: Subset<T, DropdownItem$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    group<T extends DropdownItem$groupArgs<ExtArgs> = {}>(args?: Subset<T, DropdownItem$groupArgs<ExtArgs>>): Prisma__DropDownGroupClient<$Result.GetResult<Prisma.$DropDownGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    page<T extends DropdownItem$pageArgs<ExtArgs> = {}>(args?: Subset<T, DropdownItem$pageArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    article<T extends DropdownItem$articleArgs<ExtArgs> = {}>(args?: Subset<T, DropdownItem$articleArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    navItem<T extends DropdownItem$navItemArgs<ExtArgs> = {}>(args?: Subset<T, DropdownItem$navItemArgs<ExtArgs>>): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DropdownItem model
   */ 
  interface DropdownItemFieldRefs {
    readonly id: FieldRef<"DropdownItem", 'String'>
    readonly groupId: FieldRef<"DropdownItem", 'String'>
    readonly pageId: FieldRef<"DropdownItem", 'String'>
    readonly forGroup: FieldRef<"DropdownItem", 'Boolean'>
    readonly forArticle: FieldRef<"DropdownItem", 'Boolean'>
    readonly forPage: FieldRef<"DropdownItem", 'Boolean'>
    readonly articleId: FieldRef<"DropdownItem", 'String'>
    readonly navItemId: FieldRef<"DropdownItem", 'String'>
    readonly createdAt: FieldRef<"DropdownItem", 'DateTime'>
    readonly updatedAt: FieldRef<"DropdownItem", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DropdownItem findUnique
   */
  export type DropdownItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItem to fetch.
     */
    where: DropdownItemWhereUniqueInput
  }


  /**
   * DropdownItem findUniqueOrThrow
   */
  export type DropdownItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItem to fetch.
     */
    where: DropdownItemWhereUniqueInput
  }


  /**
   * DropdownItem findFirst
   */
  export type DropdownItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItem to fetch.
     */
    where?: DropdownItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItems to fetch.
     */
    orderBy?: DropdownItemOrderByWithRelationInput | DropdownItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropdownItems.
     */
    cursor?: DropdownItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropdownItems.
     */
    distinct?: DropdownItemScalarFieldEnum | DropdownItemScalarFieldEnum[]
  }


  /**
   * DropdownItem findFirstOrThrow
   */
  export type DropdownItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItem to fetch.
     */
    where?: DropdownItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItems to fetch.
     */
    orderBy?: DropdownItemOrderByWithRelationInput | DropdownItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropdownItems.
     */
    cursor?: DropdownItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropdownItems.
     */
    distinct?: DropdownItemScalarFieldEnum | DropdownItemScalarFieldEnum[]
  }


  /**
   * DropdownItem findMany
   */
  export type DropdownItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItems to fetch.
     */
    where?: DropdownItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItems to fetch.
     */
    orderBy?: DropdownItemOrderByWithRelationInput | DropdownItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropdownItems.
     */
    cursor?: DropdownItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItems.
     */
    skip?: number
    distinct?: DropdownItemScalarFieldEnum | DropdownItemScalarFieldEnum[]
  }


  /**
   * DropdownItem create
   */
  export type DropdownItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * The data needed to create a DropdownItem.
     */
    data: XOR<DropdownItemCreateInput, DropdownItemUncheckedCreateInput>
  }


  /**
   * DropdownItem createMany
   */
  export type DropdownItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropdownItems.
     */
    data: DropdownItemCreateManyInput | DropdownItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DropdownItem update
   */
  export type DropdownItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * The data needed to update a DropdownItem.
     */
    data: XOR<DropdownItemUpdateInput, DropdownItemUncheckedUpdateInput>
    /**
     * Choose, which DropdownItem to update.
     */
    where: DropdownItemWhereUniqueInput
  }


  /**
   * DropdownItem updateMany
   */
  export type DropdownItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropdownItems.
     */
    data: XOR<DropdownItemUpdateManyMutationInput, DropdownItemUncheckedUpdateManyInput>
    /**
     * Filter which DropdownItems to update
     */
    where?: DropdownItemWhereInput
  }


  /**
   * DropdownItem upsert
   */
  export type DropdownItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * The filter to search for the DropdownItem to update in case it exists.
     */
    where: DropdownItemWhereUniqueInput
    /**
     * In case the DropdownItem found by the `where` argument doesn't exist, create a new DropdownItem with this data.
     */
    create: XOR<DropdownItemCreateInput, DropdownItemUncheckedCreateInput>
    /**
     * In case the DropdownItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropdownItemUpdateInput, DropdownItemUncheckedUpdateInput>
  }


  /**
   * DropdownItem delete
   */
  export type DropdownItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    /**
     * Filter which DropdownItem to delete.
     */
    where: DropdownItemWhereUniqueInput
  }


  /**
   * DropdownItem deleteMany
   */
  export type DropdownItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropdownItems to delete
     */
    where?: DropdownItemWhereInput
  }


  /**
   * DropdownItem.translations
   */
  export type DropdownItem$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    where?: DropdownItemTranslationWhereInput
    orderBy?: DropdownItemTranslationOrderByWithRelationInput | DropdownItemTranslationOrderByWithRelationInput[]
    cursor?: DropdownItemTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropdownItemTranslationScalarFieldEnum | DropdownItemTranslationScalarFieldEnum[]
  }


  /**
   * DropdownItem.group
   */
  export type DropdownItem$groupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropDownGroup
     */
    select?: DropDownGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropDownGroupInclude<ExtArgs> | null
    where?: DropDownGroupWhereInput
  }


  /**
   * DropdownItem.page
   */
  export type DropdownItem$pageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }


  /**
   * DropdownItem.article
   */
  export type DropdownItem$articleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
  }


  /**
   * DropdownItem.navItem
   */
  export type DropdownItem$navItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    where?: NavbarItemWhereInput
  }


  /**
   * DropdownItem without action
   */
  export type DropdownItemDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
  }



  /**
   * Model DropdownItemTranslation
   */

  export type AggregateDropdownItemTranslation = {
    _count: DropdownItemTranslationCountAggregateOutputType | null
    _min: DropdownItemTranslationMinAggregateOutputType | null
    _max: DropdownItemTranslationMaxAggregateOutputType | null
  }

  export type DropdownItemTranslationMinAggregateOutputType = {
    id: string | null
    name: string | null
    lang: string | null
    dropdownItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropdownItemTranslationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    lang: string | null
    dropdownItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropdownItemTranslationCountAggregateOutputType = {
    id: number
    name: number
    lang: number
    dropdownItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DropdownItemTranslationMinAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    dropdownItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropdownItemTranslationMaxAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    dropdownItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropdownItemTranslationCountAggregateInputType = {
    id?: true
    name?: true
    lang?: true
    dropdownItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DropdownItemTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropdownItemTranslation to aggregate.
     */
    where?: DropdownItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItemTranslations to fetch.
     */
    orderBy?: DropdownItemTranslationOrderByWithRelationInput | DropdownItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropdownItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropdownItemTranslations
    **/
    _count?: true | DropdownItemTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropdownItemTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropdownItemTranslationMaxAggregateInputType
  }

  export type GetDropdownItemTranslationAggregateType<T extends DropdownItemTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateDropdownItemTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropdownItemTranslation[P]>
      : GetScalarType<T[P], AggregateDropdownItemTranslation[P]>
  }




  export type DropdownItemTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropdownItemTranslationWhereInput
    orderBy?: DropdownItemTranslationOrderByWithAggregationInput | DropdownItemTranslationOrderByWithAggregationInput[]
    by: DropdownItemTranslationScalarFieldEnum[] | DropdownItemTranslationScalarFieldEnum
    having?: DropdownItemTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropdownItemTranslationCountAggregateInputType | true
    _min?: DropdownItemTranslationMinAggregateInputType
    _max?: DropdownItemTranslationMaxAggregateInputType
  }

  export type DropdownItemTranslationGroupByOutputType = {
    id: string
    name: string
    lang: string
    dropdownItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DropdownItemTranslationCountAggregateOutputType | null
    _min: DropdownItemTranslationMinAggregateOutputType | null
    _max: DropdownItemTranslationMaxAggregateOutputType | null
  }

  type GetDropdownItemTranslationGroupByPayload<T extends DropdownItemTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropdownItemTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropdownItemTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropdownItemTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], DropdownItemTranslationGroupByOutputType[P]>
        }
      >
    >


  export type DropdownItemTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lang?: boolean
    dropdownItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    dropdownItem?: boolean | DropdownItemTranslation$dropdownItemArgs<ExtArgs>
  }, ExtArgs["result"]["dropdownItemTranslation"]>

  export type DropdownItemTranslationSelectScalar = {
    id?: boolean
    name?: boolean
    lang?: boolean
    dropdownItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DropdownItemTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    dropdownItem?: boolean | DropdownItemTranslation$dropdownItemArgs<ExtArgs>
  }


  export type $DropdownItemTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DropdownItemTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      dropdownItem: Prisma.$DropdownItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      lang: string
      dropdownItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dropdownItemTranslation"]>
    composites: {}
  }


  type DropdownItemTranslationGetPayload<S extends boolean | null | undefined | DropdownItemTranslationDefaultArgs> = $Result.GetResult<Prisma.$DropdownItemTranslationPayload, S>

  type DropdownItemTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DropdownItemTranslationFindManyArgs, 'select' | 'include'> & {
      select?: DropdownItemTranslationCountAggregateInputType | true
    }

  export interface DropdownItemTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropdownItemTranslation'], meta: { name: 'DropdownItemTranslation' } }
    /**
     * Find zero or one DropdownItemTranslation that matches the filter.
     * @param {DropdownItemTranslationFindUniqueArgs} args - Arguments to find a DropdownItemTranslation
     * @example
     * // Get one DropdownItemTranslation
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DropdownItemTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DropdownItemTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DropdownItemTranslationFindUniqueOrThrowArgs} args - Arguments to find a DropdownItemTranslation
     * @example
     * // Get one DropdownItemTranslation
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DropdownItemTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DropdownItemTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationFindFirstArgs} args - Arguments to find a DropdownItemTranslation
     * @example
     * // Get one DropdownItemTranslation
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DropdownItemTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DropdownItemTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationFindFirstOrThrowArgs} args - Arguments to find a DropdownItemTranslation
     * @example
     * // Get one DropdownItemTranslation
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DropdownItemTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DropdownItemTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropdownItemTranslations
     * const dropdownItemTranslations = await prisma.dropdownItemTranslation.findMany()
     * 
     * // Get first 10 DropdownItemTranslations
     * const dropdownItemTranslations = await prisma.dropdownItemTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropdownItemTranslationWithIdOnly = await prisma.dropdownItemTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DropdownItemTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DropdownItemTranslation.
     * @param {DropdownItemTranslationCreateArgs} args - Arguments to create a DropdownItemTranslation.
     * @example
     * // Create one DropdownItemTranslation
     * const DropdownItemTranslation = await prisma.dropdownItemTranslation.create({
     *   data: {
     *     // ... data to create a DropdownItemTranslation
     *   }
     * })
     * 
    **/
    create<T extends DropdownItemTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemTranslationCreateArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DropdownItemTranslations.
     *     @param {DropdownItemTranslationCreateManyArgs} args - Arguments to create many DropdownItemTranslations.
     *     @example
     *     // Create many DropdownItemTranslations
     *     const dropdownItemTranslation = await prisma.dropdownItemTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DropdownItemTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropdownItemTranslation.
     * @param {DropdownItemTranslationDeleteArgs} args - Arguments to delete one DropdownItemTranslation.
     * @example
     * // Delete one DropdownItemTranslation
     * const DropdownItemTranslation = await prisma.dropdownItemTranslation.delete({
     *   where: {
     *     // ... filter to delete one DropdownItemTranslation
     *   }
     * })
     * 
    **/
    delete<T extends DropdownItemTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemTranslationDeleteArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DropdownItemTranslation.
     * @param {DropdownItemTranslationUpdateArgs} args - Arguments to update one DropdownItemTranslation.
     * @example
     * // Update one DropdownItemTranslation
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DropdownItemTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemTranslationUpdateArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DropdownItemTranslations.
     * @param {DropdownItemTranslationDeleteManyArgs} args - Arguments to filter DropdownItemTranslations to delete.
     * @example
     * // Delete a few DropdownItemTranslations
     * const { count } = await prisma.dropdownItemTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DropdownItemTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropdownItemTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropdownItemTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropdownItemTranslations
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DropdownItemTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropdownItemTranslation.
     * @param {DropdownItemTranslationUpsertArgs} args - Arguments to update or create a DropdownItemTranslation.
     * @example
     * // Update or create a DropdownItemTranslation
     * const dropdownItemTranslation = await prisma.dropdownItemTranslation.upsert({
     *   create: {
     *     // ... data to create a DropdownItemTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropdownItemTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends DropdownItemTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DropdownItemTranslationUpsertArgs<ExtArgs>>
    ): Prisma__DropdownItemTranslationClient<$Result.GetResult<Prisma.$DropdownItemTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DropdownItemTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationCountArgs} args - Arguments to filter DropdownItemTranslations to count.
     * @example
     * // Count the number of DropdownItemTranslations
     * const count = await prisma.dropdownItemTranslation.count({
     *   where: {
     *     // ... the filter for the DropdownItemTranslations we want to count
     *   }
     * })
    **/
    count<T extends DropdownItemTranslationCountArgs>(
      args?: Subset<T, DropdownItemTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropdownItemTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropdownItemTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropdownItemTranslationAggregateArgs>(args: Subset<T, DropdownItemTranslationAggregateArgs>): Prisma.PrismaPromise<GetDropdownItemTranslationAggregateType<T>>

    /**
     * Group by DropdownItemTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownItemTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropdownItemTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropdownItemTranslationGroupByArgs['orderBy'] }
        : { orderBy?: DropdownItemTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropdownItemTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropdownItemTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropdownItemTranslation model
   */
  readonly fields: DropdownItemTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropdownItemTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropdownItemTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dropdownItem<T extends DropdownItemTranslation$dropdownItemArgs<ExtArgs> = {}>(args?: Subset<T, DropdownItemTranslation$dropdownItemArgs<ExtArgs>>): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DropdownItemTranslation model
   */ 
  interface DropdownItemTranslationFieldRefs {
    readonly id: FieldRef<"DropdownItemTranslation", 'String'>
    readonly name: FieldRef<"DropdownItemTranslation", 'String'>
    readonly lang: FieldRef<"DropdownItemTranslation", 'String'>
    readonly dropdownItemId: FieldRef<"DropdownItemTranslation", 'String'>
    readonly createdAt: FieldRef<"DropdownItemTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"DropdownItemTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DropdownItemTranslation findUnique
   */
  export type DropdownItemTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItemTranslation to fetch.
     */
    where: DropdownItemTranslationWhereUniqueInput
  }


  /**
   * DropdownItemTranslation findUniqueOrThrow
   */
  export type DropdownItemTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItemTranslation to fetch.
     */
    where: DropdownItemTranslationWhereUniqueInput
  }


  /**
   * DropdownItemTranslation findFirst
   */
  export type DropdownItemTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItemTranslation to fetch.
     */
    where?: DropdownItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItemTranslations to fetch.
     */
    orderBy?: DropdownItemTranslationOrderByWithRelationInput | DropdownItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropdownItemTranslations.
     */
    cursor?: DropdownItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropdownItemTranslations.
     */
    distinct?: DropdownItemTranslationScalarFieldEnum | DropdownItemTranslationScalarFieldEnum[]
  }


  /**
   * DropdownItemTranslation findFirstOrThrow
   */
  export type DropdownItemTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItemTranslation to fetch.
     */
    where?: DropdownItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItemTranslations to fetch.
     */
    orderBy?: DropdownItemTranslationOrderByWithRelationInput | DropdownItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropdownItemTranslations.
     */
    cursor?: DropdownItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropdownItemTranslations.
     */
    distinct?: DropdownItemTranslationScalarFieldEnum | DropdownItemTranslationScalarFieldEnum[]
  }


  /**
   * DropdownItemTranslation findMany
   */
  export type DropdownItemTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DropdownItemTranslations to fetch.
     */
    where?: DropdownItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownItemTranslations to fetch.
     */
    orderBy?: DropdownItemTranslationOrderByWithRelationInput | DropdownItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropdownItemTranslations.
     */
    cursor?: DropdownItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownItemTranslations.
     */
    skip?: number
    distinct?: DropdownItemTranslationScalarFieldEnum | DropdownItemTranslationScalarFieldEnum[]
  }


  /**
   * DropdownItemTranslation create
   */
  export type DropdownItemTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a DropdownItemTranslation.
     */
    data: XOR<DropdownItemTranslationCreateInput, DropdownItemTranslationUncheckedCreateInput>
  }


  /**
   * DropdownItemTranslation createMany
   */
  export type DropdownItemTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropdownItemTranslations.
     */
    data: DropdownItemTranslationCreateManyInput | DropdownItemTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DropdownItemTranslation update
   */
  export type DropdownItemTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a DropdownItemTranslation.
     */
    data: XOR<DropdownItemTranslationUpdateInput, DropdownItemTranslationUncheckedUpdateInput>
    /**
     * Choose, which DropdownItemTranslation to update.
     */
    where: DropdownItemTranslationWhereUniqueInput
  }


  /**
   * DropdownItemTranslation updateMany
   */
  export type DropdownItemTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropdownItemTranslations.
     */
    data: XOR<DropdownItemTranslationUpdateManyMutationInput, DropdownItemTranslationUncheckedUpdateManyInput>
    /**
     * Filter which DropdownItemTranslations to update
     */
    where?: DropdownItemTranslationWhereInput
  }


  /**
   * DropdownItemTranslation upsert
   */
  export type DropdownItemTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the DropdownItemTranslation to update in case it exists.
     */
    where: DropdownItemTranslationWhereUniqueInput
    /**
     * In case the DropdownItemTranslation found by the `where` argument doesn't exist, create a new DropdownItemTranslation with this data.
     */
    create: XOR<DropdownItemTranslationCreateInput, DropdownItemTranslationUncheckedCreateInput>
    /**
     * In case the DropdownItemTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropdownItemTranslationUpdateInput, DropdownItemTranslationUncheckedUpdateInput>
  }


  /**
   * DropdownItemTranslation delete
   */
  export type DropdownItemTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
    /**
     * Filter which DropdownItemTranslation to delete.
     */
    where: DropdownItemTranslationWhereUniqueInput
  }


  /**
   * DropdownItemTranslation deleteMany
   */
  export type DropdownItemTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropdownItemTranslations to delete
     */
    where?: DropdownItemTranslationWhereInput
  }


  /**
   * DropdownItemTranslation.dropdownItem
   */
  export type DropdownItemTranslation$dropdownItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    where?: DropdownItemWhereInput
  }


  /**
   * DropdownItemTranslation without action
   */
  export type DropdownItemTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItemTranslation
     */
    select?: DropdownItemTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Footer
   */

  export type AggregateFooter = {
    _count: FooterCountAggregateOutputType | null
    _min: FooterMinAggregateOutputType | null
    _max: FooterMaxAggregateOutputType | null
  }

  export type FooterMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FooterMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FooterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Footer to aggregate.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Footers
    **/
    _count?: true | FooterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FooterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FooterMaxAggregateInputType
  }

  export type GetFooterAggregateType<T extends FooterAggregateArgs> = {
        [P in keyof T & keyof AggregateFooter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFooter[P]>
      : GetScalarType<T[P], AggregateFooter[P]>
  }




  export type FooterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FooterWhereInput
    orderBy?: FooterOrderByWithAggregationInput | FooterOrderByWithAggregationInput[]
    by: FooterScalarFieldEnum[] | FooterScalarFieldEnum
    having?: FooterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FooterCountAggregateInputType | true
    _min?: FooterMinAggregateInputType
    _max?: FooterMaxAggregateInputType
  }

  export type FooterGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: FooterCountAggregateOutputType | null
    _min: FooterMinAggregateOutputType | null
    _max: FooterMaxAggregateOutputType | null
  }

  type GetFooterGroupByPayload<T extends FooterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FooterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FooterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FooterGroupByOutputType[P]>
            : GetScalarType<T[P], FooterGroupByOutputType[P]>
        }
      >
    >


  export type FooterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Footer$translationsArgs<ExtArgs>
    groups?: boolean | Footer$groupsArgs<ExtArgs>
    articles?: boolean | Footer$articlesArgs<ExtArgs>
    _count?: boolean | FooterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["footer"]>

  export type FooterSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FooterInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Footer$translationsArgs<ExtArgs>
    groups?: boolean | Footer$groupsArgs<ExtArgs>
    articles?: boolean | Footer$articlesArgs<ExtArgs>
    _count?: boolean | FooterCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FooterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Footer"
    objects: {
      translations: Prisma.$FooterTranslationPayload<ExtArgs>[]
      groups: Prisma.$GroupFooterPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["footer"]>
    composites: {}
  }


  type FooterGetPayload<S extends boolean | null | undefined | FooterDefaultArgs> = $Result.GetResult<Prisma.$FooterPayload, S>

  type FooterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FooterFindManyArgs, 'select' | 'include'> & {
      select?: FooterCountAggregateInputType | true
    }

  export interface FooterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Footer'], meta: { name: 'Footer' } }
    /**
     * Find zero or one Footer that matches the filter.
     * @param {FooterFindUniqueArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FooterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FooterFindUniqueArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Footer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FooterFindUniqueOrThrowArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FooterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Footer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterFindFirstArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FooterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterFindFirstArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Footer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterFindFirstOrThrowArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FooterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Footers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Footers
     * const footers = await prisma.footer.findMany()
     * 
     * // Get first 10 Footers
     * const footers = await prisma.footer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footerWithIdOnly = await prisma.footer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FooterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Footer.
     * @param {FooterCreateArgs} args - Arguments to create a Footer.
     * @example
     * // Create one Footer
     * const Footer = await prisma.footer.create({
     *   data: {
     *     // ... data to create a Footer
     *   }
     * })
     * 
    **/
    create<T extends FooterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FooterCreateArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Footers.
     *     @param {FooterCreateManyArgs} args - Arguments to create many Footers.
     *     @example
     *     // Create many Footers
     *     const footer = await prisma.footer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FooterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Footer.
     * @param {FooterDeleteArgs} args - Arguments to delete one Footer.
     * @example
     * // Delete one Footer
     * const Footer = await prisma.footer.delete({
     *   where: {
     *     // ... filter to delete one Footer
     *   }
     * })
     * 
    **/
    delete<T extends FooterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FooterDeleteArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Footer.
     * @param {FooterUpdateArgs} args - Arguments to update one Footer.
     * @example
     * // Update one Footer
     * const footer = await prisma.footer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FooterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FooterUpdateArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Footers.
     * @param {FooterDeleteManyArgs} args - Arguments to filter Footers to delete.
     * @example
     * // Delete a few Footers
     * const { count } = await prisma.footer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FooterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Footers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Footers
     * const footer = await prisma.footer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FooterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FooterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Footer.
     * @param {FooterUpsertArgs} args - Arguments to update or create a Footer.
     * @example
     * // Update or create a Footer
     * const footer = await prisma.footer.upsert({
     *   create: {
     *     // ... data to create a Footer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Footer we want to update
     *   }
     * })
    **/
    upsert<T extends FooterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FooterUpsertArgs<ExtArgs>>
    ): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Footers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterCountArgs} args - Arguments to filter Footers to count.
     * @example
     * // Count the number of Footers
     * const count = await prisma.footer.count({
     *   where: {
     *     // ... the filter for the Footers we want to count
     *   }
     * })
    **/
    count<T extends FooterCountArgs>(
      args?: Subset<T, FooterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FooterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Footer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FooterAggregateArgs>(args: Subset<T, FooterAggregateArgs>): Prisma.PrismaPromise<GetFooterAggregateType<T>>

    /**
     * Group by Footer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FooterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FooterGroupByArgs['orderBy'] }
        : { orderBy?: FooterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FooterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFooterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Footer model
   */
  readonly fields: FooterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Footer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FooterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Footer$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Footer$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    groups<T extends Footer$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Footer$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findMany'> | Null>;

    articles<T extends Footer$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Footer$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Footer model
   */ 
  interface FooterFieldRefs {
    readonly id: FieldRef<"Footer", 'String'>
    readonly createdAt: FieldRef<"Footer", 'DateTime'>
    readonly updatedAt: FieldRef<"Footer", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Footer findUnique
   */
  export type FooterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where: FooterWhereUniqueInput
  }


  /**
   * Footer findUniqueOrThrow
   */
  export type FooterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where: FooterWhereUniqueInput
  }


  /**
   * Footer findFirst
   */
  export type FooterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Footers.
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Footers.
     */
    distinct?: FooterScalarFieldEnum | FooterScalarFieldEnum[]
  }


  /**
   * Footer findFirstOrThrow
   */
  export type FooterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Footers.
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Footers.
     */
    distinct?: FooterScalarFieldEnum | FooterScalarFieldEnum[]
  }


  /**
   * Footer findMany
   */
  export type FooterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * Filter, which Footers to fetch.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Footers.
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    distinct?: FooterScalarFieldEnum | FooterScalarFieldEnum[]
  }


  /**
   * Footer create
   */
  export type FooterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * The data needed to create a Footer.
     */
    data: XOR<FooterCreateInput, FooterUncheckedCreateInput>
  }


  /**
   * Footer createMany
   */
  export type FooterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Footers.
     */
    data: FooterCreateManyInput | FooterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Footer update
   */
  export type FooterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * The data needed to update a Footer.
     */
    data: XOR<FooterUpdateInput, FooterUncheckedUpdateInput>
    /**
     * Choose, which Footer to update.
     */
    where: FooterWhereUniqueInput
  }


  /**
   * Footer updateMany
   */
  export type FooterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Footers.
     */
    data: XOR<FooterUpdateManyMutationInput, FooterUncheckedUpdateManyInput>
    /**
     * Filter which Footers to update
     */
    where?: FooterWhereInput
  }


  /**
   * Footer upsert
   */
  export type FooterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * The filter to search for the Footer to update in case it exists.
     */
    where: FooterWhereUniqueInput
    /**
     * In case the Footer found by the `where` argument doesn't exist, create a new Footer with this data.
     */
    create: XOR<FooterCreateInput, FooterUncheckedCreateInput>
    /**
     * In case the Footer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FooterUpdateInput, FooterUncheckedUpdateInput>
  }


  /**
   * Footer delete
   */
  export type FooterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    /**
     * Filter which Footer to delete.
     */
    where: FooterWhereUniqueInput
  }


  /**
   * Footer deleteMany
   */
  export type FooterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Footers to delete
     */
    where?: FooterWhereInput
  }


  /**
   * Footer.translations
   */
  export type Footer$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    where?: FooterTranslationWhereInput
    orderBy?: FooterTranslationOrderByWithRelationInput | FooterTranslationOrderByWithRelationInput[]
    cursor?: FooterTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FooterTranslationScalarFieldEnum | FooterTranslationScalarFieldEnum[]
  }


  /**
   * Footer.groups
   */
  export type Footer$groupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    where?: GroupFooterWhereInput
    orderBy?: GroupFooterOrderByWithRelationInput | GroupFooterOrderByWithRelationInput[]
    cursor?: GroupFooterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupFooterScalarFieldEnum | GroupFooterScalarFieldEnum[]
  }


  /**
   * Footer.articles
   */
  export type Footer$articlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Footer without action
   */
  export type FooterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
  }



  /**
   * Model FooterTranslation
   */

  export type AggregateFooterTranslation = {
    _count: FooterTranslationCountAggregateOutputType | null
    _min: FooterTranslationMinAggregateOutputType | null
    _max: FooterTranslationMaxAggregateOutputType | null
  }

  export type FooterTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    footerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    footerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterTranslationCountAggregateOutputType = {
    id: number
    lang: number
    footerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FooterTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    footerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    footerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    footerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FooterTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterTranslation to aggregate.
     */
    where?: FooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterTranslations to fetch.
     */
    orderBy?: FooterTranslationOrderByWithRelationInput | FooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FooterTranslations
    **/
    _count?: true | FooterTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FooterTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FooterTranslationMaxAggregateInputType
  }

  export type GetFooterTranslationAggregateType<T extends FooterTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateFooterTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFooterTranslation[P]>
      : GetScalarType<T[P], AggregateFooterTranslation[P]>
  }




  export type FooterTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FooterTranslationWhereInput
    orderBy?: FooterTranslationOrderByWithAggregationInput | FooterTranslationOrderByWithAggregationInput[]
    by: FooterTranslationScalarFieldEnum[] | FooterTranslationScalarFieldEnum
    having?: FooterTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FooterTranslationCountAggregateInputType | true
    _min?: FooterTranslationMinAggregateInputType
    _max?: FooterTranslationMaxAggregateInputType
  }

  export type FooterTranslationGroupByOutputType = {
    id: string
    lang: string
    footerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FooterTranslationCountAggregateOutputType | null
    _min: FooterTranslationMinAggregateOutputType | null
    _max: FooterTranslationMaxAggregateOutputType | null
  }

  type GetFooterTranslationGroupByPayload<T extends FooterTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FooterTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FooterTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FooterTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], FooterTranslationGroupByOutputType[P]>
        }
      >
    >


  export type FooterTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    footerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    footer?: boolean | FooterTranslation$footerArgs<ExtArgs>
  }, ExtArgs["result"]["footerTranslation"]>

  export type FooterTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    footerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FooterTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    footer?: boolean | FooterTranslation$footerArgs<ExtArgs>
  }


  export type $FooterTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "FooterTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      footer: Prisma.$FooterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      footerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["footerTranslation"]>
    composites: {}
  }


  type FooterTranslationGetPayload<S extends boolean | null | undefined | FooterTranslationDefaultArgs> = $Result.GetResult<Prisma.$FooterTranslationPayload, S>

  type FooterTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FooterTranslationFindManyArgs, 'select' | 'include'> & {
      select?: FooterTranslationCountAggregateInputType | true
    }

  export interface FooterTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FooterTranslation'], meta: { name: 'FooterTranslation' } }
    /**
     * Find zero or one FooterTranslation that matches the filter.
     * @param {FooterTranslationFindUniqueArgs} args - Arguments to find a FooterTranslation
     * @example
     * // Get one FooterTranslation
     * const footerTranslation = await prisma.footerTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FooterTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FooterTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FooterTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FooterTranslationFindUniqueOrThrowArgs} args - Arguments to find a FooterTranslation
     * @example
     * // Get one FooterTranslation
     * const footerTranslation = await prisma.footerTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FooterTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FooterTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationFindFirstArgs} args - Arguments to find a FooterTranslation
     * @example
     * // Get one FooterTranslation
     * const footerTranslation = await prisma.footerTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FooterTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FooterTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationFindFirstOrThrowArgs} args - Arguments to find a FooterTranslation
     * @example
     * // Get one FooterTranslation
     * const footerTranslation = await prisma.footerTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FooterTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FooterTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FooterTranslations
     * const footerTranslations = await prisma.footerTranslation.findMany()
     * 
     * // Get first 10 FooterTranslations
     * const footerTranslations = await prisma.footerTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footerTranslationWithIdOnly = await prisma.footerTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FooterTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FooterTranslation.
     * @param {FooterTranslationCreateArgs} args - Arguments to create a FooterTranslation.
     * @example
     * // Create one FooterTranslation
     * const FooterTranslation = await prisma.footerTranslation.create({
     *   data: {
     *     // ... data to create a FooterTranslation
     *   }
     * })
     * 
    **/
    create<T extends FooterTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FooterTranslationCreateArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FooterTranslations.
     *     @param {FooterTranslationCreateManyArgs} args - Arguments to create many FooterTranslations.
     *     @example
     *     // Create many FooterTranslations
     *     const footerTranslation = await prisma.footerTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FooterTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FooterTranslation.
     * @param {FooterTranslationDeleteArgs} args - Arguments to delete one FooterTranslation.
     * @example
     * // Delete one FooterTranslation
     * const FooterTranslation = await prisma.footerTranslation.delete({
     *   where: {
     *     // ... filter to delete one FooterTranslation
     *   }
     * })
     * 
    **/
    delete<T extends FooterTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FooterTranslationDeleteArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FooterTranslation.
     * @param {FooterTranslationUpdateArgs} args - Arguments to update one FooterTranslation.
     * @example
     * // Update one FooterTranslation
     * const footerTranslation = await prisma.footerTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FooterTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FooterTranslationUpdateArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FooterTranslations.
     * @param {FooterTranslationDeleteManyArgs} args - Arguments to filter FooterTranslations to delete.
     * @example
     * // Delete a few FooterTranslations
     * const { count } = await prisma.footerTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FooterTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FooterTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FooterTranslations
     * const footerTranslation = await prisma.footerTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FooterTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FooterTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FooterTranslation.
     * @param {FooterTranslationUpsertArgs} args - Arguments to update or create a FooterTranslation.
     * @example
     * // Update or create a FooterTranslation
     * const footerTranslation = await prisma.footerTranslation.upsert({
     *   create: {
     *     // ... data to create a FooterTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FooterTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends FooterTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FooterTranslationUpsertArgs<ExtArgs>>
    ): Prisma__FooterTranslationClient<$Result.GetResult<Prisma.$FooterTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FooterTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationCountArgs} args - Arguments to filter FooterTranslations to count.
     * @example
     * // Count the number of FooterTranslations
     * const count = await prisma.footerTranslation.count({
     *   where: {
     *     // ... the filter for the FooterTranslations we want to count
     *   }
     * })
    **/
    count<T extends FooterTranslationCountArgs>(
      args?: Subset<T, FooterTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FooterTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FooterTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FooterTranslationAggregateArgs>(args: Subset<T, FooterTranslationAggregateArgs>): Prisma.PrismaPromise<GetFooterTranslationAggregateType<T>>

    /**
     * Group by FooterTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FooterTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FooterTranslationGroupByArgs['orderBy'] }
        : { orderBy?: FooterTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FooterTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFooterTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FooterTranslation model
   */
  readonly fields: FooterTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FooterTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FooterTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    footer<T extends FooterTranslation$footerArgs<ExtArgs> = {}>(args?: Subset<T, FooterTranslation$footerArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FooterTranslation model
   */ 
  interface FooterTranslationFieldRefs {
    readonly id: FieldRef<"FooterTranslation", 'String'>
    readonly lang: FieldRef<"FooterTranslation", 'String'>
    readonly footerId: FieldRef<"FooterTranslation", 'String'>
    readonly createdAt: FieldRef<"FooterTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"FooterTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FooterTranslation findUnique
   */
  export type FooterTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FooterTranslation to fetch.
     */
    where: FooterTranslationWhereUniqueInput
  }


  /**
   * FooterTranslation findUniqueOrThrow
   */
  export type FooterTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FooterTranslation to fetch.
     */
    where: FooterTranslationWhereUniqueInput
  }


  /**
   * FooterTranslation findFirst
   */
  export type FooterTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FooterTranslation to fetch.
     */
    where?: FooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterTranslations to fetch.
     */
    orderBy?: FooterTranslationOrderByWithRelationInput | FooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterTranslations.
     */
    cursor?: FooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterTranslations.
     */
    distinct?: FooterTranslationScalarFieldEnum | FooterTranslationScalarFieldEnum[]
  }


  /**
   * FooterTranslation findFirstOrThrow
   */
  export type FooterTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FooterTranslation to fetch.
     */
    where?: FooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterTranslations to fetch.
     */
    orderBy?: FooterTranslationOrderByWithRelationInput | FooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterTranslations.
     */
    cursor?: FooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterTranslations.
     */
    distinct?: FooterTranslationScalarFieldEnum | FooterTranslationScalarFieldEnum[]
  }


  /**
   * FooterTranslation findMany
   */
  export type FooterTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FooterTranslations to fetch.
     */
    where?: FooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterTranslations to fetch.
     */
    orderBy?: FooterTranslationOrderByWithRelationInput | FooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FooterTranslations.
     */
    cursor?: FooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterTranslations.
     */
    skip?: number
    distinct?: FooterTranslationScalarFieldEnum | FooterTranslationScalarFieldEnum[]
  }


  /**
   * FooterTranslation create
   */
  export type FooterTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a FooterTranslation.
     */
    data: XOR<FooterTranslationCreateInput, FooterTranslationUncheckedCreateInput>
  }


  /**
   * FooterTranslation createMany
   */
  export type FooterTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FooterTranslations.
     */
    data: FooterTranslationCreateManyInput | FooterTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FooterTranslation update
   */
  export type FooterTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a FooterTranslation.
     */
    data: XOR<FooterTranslationUpdateInput, FooterTranslationUncheckedUpdateInput>
    /**
     * Choose, which FooterTranslation to update.
     */
    where: FooterTranslationWhereUniqueInput
  }


  /**
   * FooterTranslation updateMany
   */
  export type FooterTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FooterTranslations.
     */
    data: XOR<FooterTranslationUpdateManyMutationInput, FooterTranslationUncheckedUpdateManyInput>
    /**
     * Filter which FooterTranslations to update
     */
    where?: FooterTranslationWhereInput
  }


  /**
   * FooterTranslation upsert
   */
  export type FooterTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the FooterTranslation to update in case it exists.
     */
    where: FooterTranslationWhereUniqueInput
    /**
     * In case the FooterTranslation found by the `where` argument doesn't exist, create a new FooterTranslation with this data.
     */
    create: XOR<FooterTranslationCreateInput, FooterTranslationUncheckedCreateInput>
    /**
     * In case the FooterTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FooterTranslationUpdateInput, FooterTranslationUncheckedUpdateInput>
  }


  /**
   * FooterTranslation delete
   */
  export type FooterTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
    /**
     * Filter which FooterTranslation to delete.
     */
    where: FooterTranslationWhereUniqueInput
  }


  /**
   * FooterTranslation deleteMany
   */
  export type FooterTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterTranslations to delete
     */
    where?: FooterTranslationWhereInput
  }


  /**
   * FooterTranslation.footer
   */
  export type FooterTranslation$footerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    where?: FooterWhereInput
  }


  /**
   * FooterTranslation without action
   */
  export type FooterTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterTranslation
     */
    select?: FooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterTranslationInclude<ExtArgs> | null
  }



  /**
   * Model GroupFooter
   */

  export type AggregateGroupFooter = {
    _count: GroupFooterCountAggregateOutputType | null
    _min: GroupFooterMinAggregateOutputType | null
    _max: GroupFooterMaxAggregateOutputType | null
  }

  export type GroupFooterMinAggregateOutputType = {
    id: string | null
    footerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupFooterMaxAggregateOutputType = {
    id: string | null
    footerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupFooterCountAggregateOutputType = {
    id: number
    footerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupFooterMinAggregateInputType = {
    id?: true
    footerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupFooterMaxAggregateInputType = {
    id?: true
    footerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupFooterCountAggregateInputType = {
    id?: true
    footerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupFooterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupFooter to aggregate.
     */
    where?: GroupFooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooters to fetch.
     */
    orderBy?: GroupFooterOrderByWithRelationInput | GroupFooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupFooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupFooters
    **/
    _count?: true | GroupFooterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupFooterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupFooterMaxAggregateInputType
  }

  export type GetGroupFooterAggregateType<T extends GroupFooterAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupFooter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupFooter[P]>
      : GetScalarType<T[P], AggregateGroupFooter[P]>
  }




  export type GroupFooterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GroupFooterWhereInput
    orderBy?: GroupFooterOrderByWithAggregationInput | GroupFooterOrderByWithAggregationInput[]
    by: GroupFooterScalarFieldEnum[] | GroupFooterScalarFieldEnum
    having?: GroupFooterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupFooterCountAggregateInputType | true
    _min?: GroupFooterMinAggregateInputType
    _max?: GroupFooterMaxAggregateInputType
  }

  export type GroupFooterGroupByOutputType = {
    id: string
    footerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GroupFooterCountAggregateOutputType | null
    _min: GroupFooterMinAggregateOutputType | null
    _max: GroupFooterMaxAggregateOutputType | null
  }

  type GetGroupFooterGroupByPayload<T extends GroupFooterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupFooterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupFooterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupFooterGroupByOutputType[P]>
            : GetScalarType<T[P], GroupFooterGroupByOutputType[P]>
        }
      >
    >


  export type GroupFooterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    footerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | GroupFooter$translationsArgs<ExtArgs>
    footer?: boolean | GroupFooter$footerArgs<ExtArgs>
    articles?: boolean | GroupFooter$articlesArgs<ExtArgs>
    pages?: boolean | GroupFooter$pagesArgs<ExtArgs>
    _count?: boolean | GroupFooterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupFooter"]>

  export type GroupFooterSelectScalar = {
    id?: boolean
    footerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupFooterInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | GroupFooter$translationsArgs<ExtArgs>
    footer?: boolean | GroupFooter$footerArgs<ExtArgs>
    articles?: boolean | GroupFooter$articlesArgs<ExtArgs>
    pages?: boolean | GroupFooter$pagesArgs<ExtArgs>
    _count?: boolean | GroupFooterCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GroupFooterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "GroupFooter"
    objects: {
      translations: Prisma.$GroupFooterTranslationPayload<ExtArgs>[]
      footer: Prisma.$FooterPayload<ExtArgs> | null
      articles: Prisma.$ArticlePayload<ExtArgs>[]
      pages: Prisma.$PagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      footerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupFooter"]>
    composites: {}
  }


  type GroupFooterGetPayload<S extends boolean | null | undefined | GroupFooterDefaultArgs> = $Result.GetResult<Prisma.$GroupFooterPayload, S>

  type GroupFooterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GroupFooterFindManyArgs, 'select' | 'include'> & {
      select?: GroupFooterCountAggregateInputType | true
    }

  export interface GroupFooterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupFooter'], meta: { name: 'GroupFooter' } }
    /**
     * Find zero or one GroupFooter that matches the filter.
     * @param {GroupFooterFindUniqueArgs} args - Arguments to find a GroupFooter
     * @example
     * // Get one GroupFooter
     * const groupFooter = await prisma.groupFooter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFooterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterFindUniqueArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GroupFooter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupFooterFindUniqueOrThrowArgs} args - Arguments to find a GroupFooter
     * @example
     * // Get one GroupFooter
     * const groupFooter = await prisma.groupFooter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupFooterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GroupFooter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterFindFirstArgs} args - Arguments to find a GroupFooter
     * @example
     * // Get one GroupFooter
     * const groupFooter = await prisma.groupFooter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFooterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterFindFirstArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GroupFooter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterFindFirstOrThrowArgs} args - Arguments to find a GroupFooter
     * @example
     * // Get one GroupFooter
     * const groupFooter = await prisma.groupFooter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupFooterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GroupFooters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupFooters
     * const groupFooters = await prisma.groupFooter.findMany()
     * 
     * // Get first 10 GroupFooters
     * const groupFooters = await prisma.groupFooter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupFooterWithIdOnly = await prisma.groupFooter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFooterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GroupFooter.
     * @param {GroupFooterCreateArgs} args - Arguments to create a GroupFooter.
     * @example
     * // Create one GroupFooter
     * const GroupFooter = await prisma.groupFooter.create({
     *   data: {
     *     // ... data to create a GroupFooter
     *   }
     * })
     * 
    **/
    create<T extends GroupFooterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterCreateArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GroupFooters.
     *     @param {GroupFooterCreateManyArgs} args - Arguments to create many GroupFooters.
     *     @example
     *     // Create many GroupFooters
     *     const groupFooter = await prisma.groupFooter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupFooterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupFooter.
     * @param {GroupFooterDeleteArgs} args - Arguments to delete one GroupFooter.
     * @example
     * // Delete one GroupFooter
     * const GroupFooter = await prisma.groupFooter.delete({
     *   where: {
     *     // ... filter to delete one GroupFooter
     *   }
     * })
     * 
    **/
    delete<T extends GroupFooterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterDeleteArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GroupFooter.
     * @param {GroupFooterUpdateArgs} args - Arguments to update one GroupFooter.
     * @example
     * // Update one GroupFooter
     * const groupFooter = await prisma.groupFooter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupFooterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterUpdateArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GroupFooters.
     * @param {GroupFooterDeleteManyArgs} args - Arguments to filter GroupFooters to delete.
     * @example
     * // Delete a few GroupFooters
     * const { count } = await prisma.groupFooter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupFooterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupFooters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupFooters
     * const groupFooter = await prisma.groupFooter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupFooterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupFooter.
     * @param {GroupFooterUpsertArgs} args - Arguments to update or create a GroupFooter.
     * @example
     * // Update or create a GroupFooter
     * const groupFooter = await prisma.groupFooter.upsert({
     *   create: {
     *     // ... data to create a GroupFooter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupFooter we want to update
     *   }
     * })
    **/
    upsert<T extends GroupFooterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterUpsertArgs<ExtArgs>>
    ): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GroupFooters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterCountArgs} args - Arguments to filter GroupFooters to count.
     * @example
     * // Count the number of GroupFooters
     * const count = await prisma.groupFooter.count({
     *   where: {
     *     // ... the filter for the GroupFooters we want to count
     *   }
     * })
    **/
    count<T extends GroupFooterCountArgs>(
      args?: Subset<T, GroupFooterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupFooterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupFooter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupFooterAggregateArgs>(args: Subset<T, GroupFooterAggregateArgs>): Prisma.PrismaPromise<GetGroupFooterAggregateType<T>>

    /**
     * Group by GroupFooter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupFooterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupFooterGroupByArgs['orderBy'] }
        : { orderBy?: GroupFooterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupFooterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupFooterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupFooter model
   */
  readonly fields: GroupFooterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupFooter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupFooterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends GroupFooter$translationsArgs<ExtArgs> = {}>(args?: Subset<T, GroupFooter$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    footer<T extends GroupFooter$footerArgs<ExtArgs> = {}>(args?: Subset<T, GroupFooter$footerArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    articles<T extends GroupFooter$articlesArgs<ExtArgs> = {}>(args?: Subset<T, GroupFooter$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'> | Null>;

    pages<T extends GroupFooter$pagesArgs<ExtArgs> = {}>(args?: Subset<T, GroupFooter$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GroupFooter model
   */ 
  interface GroupFooterFieldRefs {
    readonly id: FieldRef<"GroupFooter", 'String'>
    readonly footerId: FieldRef<"GroupFooter", 'String'>
    readonly createdAt: FieldRef<"GroupFooter", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupFooter", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * GroupFooter findUnique
   */
  export type GroupFooterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooter to fetch.
     */
    where: GroupFooterWhereUniqueInput
  }


  /**
   * GroupFooter findUniqueOrThrow
   */
  export type GroupFooterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooter to fetch.
     */
    where: GroupFooterWhereUniqueInput
  }


  /**
   * GroupFooter findFirst
   */
  export type GroupFooterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooter to fetch.
     */
    where?: GroupFooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooters to fetch.
     */
    orderBy?: GroupFooterOrderByWithRelationInput | GroupFooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupFooters.
     */
    cursor?: GroupFooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupFooters.
     */
    distinct?: GroupFooterScalarFieldEnum | GroupFooterScalarFieldEnum[]
  }


  /**
   * GroupFooter findFirstOrThrow
   */
  export type GroupFooterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooter to fetch.
     */
    where?: GroupFooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooters to fetch.
     */
    orderBy?: GroupFooterOrderByWithRelationInput | GroupFooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupFooters.
     */
    cursor?: GroupFooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupFooters.
     */
    distinct?: GroupFooterScalarFieldEnum | GroupFooterScalarFieldEnum[]
  }


  /**
   * GroupFooter findMany
   */
  export type GroupFooterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooters to fetch.
     */
    where?: GroupFooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooters to fetch.
     */
    orderBy?: GroupFooterOrderByWithRelationInput | GroupFooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupFooters.
     */
    cursor?: GroupFooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooters.
     */
    skip?: number
    distinct?: GroupFooterScalarFieldEnum | GroupFooterScalarFieldEnum[]
  }


  /**
   * GroupFooter create
   */
  export type GroupFooterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupFooter.
     */
    data: XOR<GroupFooterCreateInput, GroupFooterUncheckedCreateInput>
  }


  /**
   * GroupFooter createMany
   */
  export type GroupFooterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupFooters.
     */
    data: GroupFooterCreateManyInput | GroupFooterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GroupFooter update
   */
  export type GroupFooterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupFooter.
     */
    data: XOR<GroupFooterUpdateInput, GroupFooterUncheckedUpdateInput>
    /**
     * Choose, which GroupFooter to update.
     */
    where: GroupFooterWhereUniqueInput
  }


  /**
   * GroupFooter updateMany
   */
  export type GroupFooterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupFooters.
     */
    data: XOR<GroupFooterUpdateManyMutationInput, GroupFooterUncheckedUpdateManyInput>
    /**
     * Filter which GroupFooters to update
     */
    where?: GroupFooterWhereInput
  }


  /**
   * GroupFooter upsert
   */
  export type GroupFooterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupFooter to update in case it exists.
     */
    where: GroupFooterWhereUniqueInput
    /**
     * In case the GroupFooter found by the `where` argument doesn't exist, create a new GroupFooter with this data.
     */
    create: XOR<GroupFooterCreateInput, GroupFooterUncheckedCreateInput>
    /**
     * In case the GroupFooter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupFooterUpdateInput, GroupFooterUncheckedUpdateInput>
  }


  /**
   * GroupFooter delete
   */
  export type GroupFooterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    /**
     * Filter which GroupFooter to delete.
     */
    where: GroupFooterWhereUniqueInput
  }


  /**
   * GroupFooter deleteMany
   */
  export type GroupFooterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupFooters to delete
     */
    where?: GroupFooterWhereInput
  }


  /**
   * GroupFooter.translations
   */
  export type GroupFooter$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    where?: GroupFooterTranslationWhereInput
    orderBy?: GroupFooterTranslationOrderByWithRelationInput | GroupFooterTranslationOrderByWithRelationInput[]
    cursor?: GroupFooterTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupFooterTranslationScalarFieldEnum | GroupFooterTranslationScalarFieldEnum[]
  }


  /**
   * GroupFooter.footer
   */
  export type GroupFooter$footerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    where?: FooterWhereInput
  }


  /**
   * GroupFooter.articles
   */
  export type GroupFooter$articlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * GroupFooter.pages
   */
  export type GroupFooter$pagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }


  /**
   * GroupFooter without action
   */
  export type GroupFooterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
  }



  /**
   * Model GroupFooterTranslation
   */

  export type AggregateGroupFooterTranslation = {
    _count: GroupFooterTranslationCountAggregateOutputType | null
    _min: GroupFooterTranslationMinAggregateOutputType | null
    _max: GroupFooterTranslationMaxAggregateOutputType | null
  }

  export type GroupFooterTranslationMinAggregateOutputType = {
    id: string | null
    title: string | null
    groupfooterId: string | null
    lang: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupFooterTranslationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    groupfooterId: string | null
    lang: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupFooterTranslationCountAggregateOutputType = {
    id: number
    title: number
    groupfooterId: number
    lang: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupFooterTranslationMinAggregateInputType = {
    id?: true
    title?: true
    groupfooterId?: true
    lang?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupFooterTranslationMaxAggregateInputType = {
    id?: true
    title?: true
    groupfooterId?: true
    lang?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupFooterTranslationCountAggregateInputType = {
    id?: true
    title?: true
    groupfooterId?: true
    lang?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupFooterTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupFooterTranslation to aggregate.
     */
    where?: GroupFooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooterTranslations to fetch.
     */
    orderBy?: GroupFooterTranslationOrderByWithRelationInput | GroupFooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupFooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooterTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupFooterTranslations
    **/
    _count?: true | GroupFooterTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupFooterTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupFooterTranslationMaxAggregateInputType
  }

  export type GetGroupFooterTranslationAggregateType<T extends GroupFooterTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupFooterTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupFooterTranslation[P]>
      : GetScalarType<T[P], AggregateGroupFooterTranslation[P]>
  }




  export type GroupFooterTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GroupFooterTranslationWhereInput
    orderBy?: GroupFooterTranslationOrderByWithAggregationInput | GroupFooterTranslationOrderByWithAggregationInput[]
    by: GroupFooterTranslationScalarFieldEnum[] | GroupFooterTranslationScalarFieldEnum
    having?: GroupFooterTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupFooterTranslationCountAggregateInputType | true
    _min?: GroupFooterTranslationMinAggregateInputType
    _max?: GroupFooterTranslationMaxAggregateInputType
  }

  export type GroupFooterTranslationGroupByOutputType = {
    id: string
    title: string | null
    groupfooterId: string | null
    lang: string
    createdAt: Date
    updatedAt: Date
    _count: GroupFooterTranslationCountAggregateOutputType | null
    _min: GroupFooterTranslationMinAggregateOutputType | null
    _max: GroupFooterTranslationMaxAggregateOutputType | null
  }

  type GetGroupFooterTranslationGroupByPayload<T extends GroupFooterTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupFooterTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupFooterTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupFooterTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], GroupFooterTranslationGroupByOutputType[P]>
        }
      >
    >


  export type GroupFooterTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    groupfooterId?: boolean
    lang?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupfooter?: boolean | GroupFooterTranslation$groupfooterArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupFooterTranslation"]>

  export type GroupFooterTranslationSelectScalar = {
    id?: boolean
    title?: boolean
    groupfooterId?: boolean
    lang?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupFooterTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    groupfooter?: boolean | GroupFooterTranslation$groupfooterArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }


  export type $GroupFooterTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "GroupFooterTranslation"
    objects: {
      groupfooter: Prisma.$GroupFooterPayload<ExtArgs> | null
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string | null
      groupfooterId: string | null
      lang: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupFooterTranslation"]>
    composites: {}
  }


  type GroupFooterTranslationGetPayload<S extends boolean | null | undefined | GroupFooterTranslationDefaultArgs> = $Result.GetResult<Prisma.$GroupFooterTranslationPayload, S>

  type GroupFooterTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GroupFooterTranslationFindManyArgs, 'select' | 'include'> & {
      select?: GroupFooterTranslationCountAggregateInputType | true
    }

  export interface GroupFooterTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupFooterTranslation'], meta: { name: 'GroupFooterTranslation' } }
    /**
     * Find zero or one GroupFooterTranslation that matches the filter.
     * @param {GroupFooterTranslationFindUniqueArgs} args - Arguments to find a GroupFooterTranslation
     * @example
     * // Get one GroupFooterTranslation
     * const groupFooterTranslation = await prisma.groupFooterTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFooterTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GroupFooterTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupFooterTranslationFindUniqueOrThrowArgs} args - Arguments to find a GroupFooterTranslation
     * @example
     * // Get one GroupFooterTranslation
     * const groupFooterTranslation = await prisma.groupFooterTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupFooterTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GroupFooterTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationFindFirstArgs} args - Arguments to find a GroupFooterTranslation
     * @example
     * // Get one GroupFooterTranslation
     * const groupFooterTranslation = await prisma.groupFooterTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFooterTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GroupFooterTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationFindFirstOrThrowArgs} args - Arguments to find a GroupFooterTranslation
     * @example
     * // Get one GroupFooterTranslation
     * const groupFooterTranslation = await prisma.groupFooterTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupFooterTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GroupFooterTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupFooterTranslations
     * const groupFooterTranslations = await prisma.groupFooterTranslation.findMany()
     * 
     * // Get first 10 GroupFooterTranslations
     * const groupFooterTranslations = await prisma.groupFooterTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupFooterTranslationWithIdOnly = await prisma.groupFooterTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFooterTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GroupFooterTranslation.
     * @param {GroupFooterTranslationCreateArgs} args - Arguments to create a GroupFooterTranslation.
     * @example
     * // Create one GroupFooterTranslation
     * const GroupFooterTranslation = await prisma.groupFooterTranslation.create({
     *   data: {
     *     // ... data to create a GroupFooterTranslation
     *   }
     * })
     * 
    **/
    create<T extends GroupFooterTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterTranslationCreateArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GroupFooterTranslations.
     *     @param {GroupFooterTranslationCreateManyArgs} args - Arguments to create many GroupFooterTranslations.
     *     @example
     *     // Create many GroupFooterTranslations
     *     const groupFooterTranslation = await prisma.groupFooterTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupFooterTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupFooterTranslation.
     * @param {GroupFooterTranslationDeleteArgs} args - Arguments to delete one GroupFooterTranslation.
     * @example
     * // Delete one GroupFooterTranslation
     * const GroupFooterTranslation = await prisma.groupFooterTranslation.delete({
     *   where: {
     *     // ... filter to delete one GroupFooterTranslation
     *   }
     * })
     * 
    **/
    delete<T extends GroupFooterTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterTranslationDeleteArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GroupFooterTranslation.
     * @param {GroupFooterTranslationUpdateArgs} args - Arguments to update one GroupFooterTranslation.
     * @example
     * // Update one GroupFooterTranslation
     * const groupFooterTranslation = await prisma.groupFooterTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupFooterTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterTranslationUpdateArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GroupFooterTranslations.
     * @param {GroupFooterTranslationDeleteManyArgs} args - Arguments to filter GroupFooterTranslations to delete.
     * @example
     * // Delete a few GroupFooterTranslations
     * const { count } = await prisma.groupFooterTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupFooterTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFooterTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupFooterTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupFooterTranslations
     * const groupFooterTranslation = await prisma.groupFooterTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupFooterTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupFooterTranslation.
     * @param {GroupFooterTranslationUpsertArgs} args - Arguments to update or create a GroupFooterTranslation.
     * @example
     * // Update or create a GroupFooterTranslation
     * const groupFooterTranslation = await prisma.groupFooterTranslation.upsert({
     *   create: {
     *     // ... data to create a GroupFooterTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupFooterTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends GroupFooterTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFooterTranslationUpsertArgs<ExtArgs>>
    ): Prisma__GroupFooterTranslationClient<$Result.GetResult<Prisma.$GroupFooterTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GroupFooterTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationCountArgs} args - Arguments to filter GroupFooterTranslations to count.
     * @example
     * // Count the number of GroupFooterTranslations
     * const count = await prisma.groupFooterTranslation.count({
     *   where: {
     *     // ... the filter for the GroupFooterTranslations we want to count
     *   }
     * })
    **/
    count<T extends GroupFooterTranslationCountArgs>(
      args?: Subset<T, GroupFooterTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupFooterTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupFooterTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupFooterTranslationAggregateArgs>(args: Subset<T, GroupFooterTranslationAggregateArgs>): Prisma.PrismaPromise<GetGroupFooterTranslationAggregateType<T>>

    /**
     * Group by GroupFooterTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFooterTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupFooterTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupFooterTranslationGroupByArgs['orderBy'] }
        : { orderBy?: GroupFooterTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupFooterTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupFooterTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupFooterTranslation model
   */
  readonly fields: GroupFooterTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupFooterTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupFooterTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    groupfooter<T extends GroupFooterTranslation$groupfooterArgs<ExtArgs> = {}>(args?: Subset<T, GroupFooterTranslation$groupfooterArgs<ExtArgs>>): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GroupFooterTranslation model
   */ 
  interface GroupFooterTranslationFieldRefs {
    readonly id: FieldRef<"GroupFooterTranslation", 'String'>
    readonly title: FieldRef<"GroupFooterTranslation", 'String'>
    readonly groupfooterId: FieldRef<"GroupFooterTranslation", 'String'>
    readonly lang: FieldRef<"GroupFooterTranslation", 'String'>
    readonly createdAt: FieldRef<"GroupFooterTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupFooterTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * GroupFooterTranslation findUnique
   */
  export type GroupFooterTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooterTranslation to fetch.
     */
    where: GroupFooterTranslationWhereUniqueInput
  }


  /**
   * GroupFooterTranslation findUniqueOrThrow
   */
  export type GroupFooterTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooterTranslation to fetch.
     */
    where: GroupFooterTranslationWhereUniqueInput
  }


  /**
   * GroupFooterTranslation findFirst
   */
  export type GroupFooterTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooterTranslation to fetch.
     */
    where?: GroupFooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooterTranslations to fetch.
     */
    orderBy?: GroupFooterTranslationOrderByWithRelationInput | GroupFooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupFooterTranslations.
     */
    cursor?: GroupFooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooterTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupFooterTranslations.
     */
    distinct?: GroupFooterTranslationScalarFieldEnum | GroupFooterTranslationScalarFieldEnum[]
  }


  /**
   * GroupFooterTranslation findFirstOrThrow
   */
  export type GroupFooterTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooterTranslation to fetch.
     */
    where?: GroupFooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooterTranslations to fetch.
     */
    orderBy?: GroupFooterTranslationOrderByWithRelationInput | GroupFooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupFooterTranslations.
     */
    cursor?: GroupFooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooterTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupFooterTranslations.
     */
    distinct?: GroupFooterTranslationScalarFieldEnum | GroupFooterTranslationScalarFieldEnum[]
  }


  /**
   * GroupFooterTranslation findMany
   */
  export type GroupFooterTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GroupFooterTranslations to fetch.
     */
    where?: GroupFooterTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFooterTranslations to fetch.
     */
    orderBy?: GroupFooterTranslationOrderByWithRelationInput | GroupFooterTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupFooterTranslations.
     */
    cursor?: GroupFooterTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFooterTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFooterTranslations.
     */
    skip?: number
    distinct?: GroupFooterTranslationScalarFieldEnum | GroupFooterTranslationScalarFieldEnum[]
  }


  /**
   * GroupFooterTranslation create
   */
  export type GroupFooterTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupFooterTranslation.
     */
    data: XOR<GroupFooterTranslationCreateInput, GroupFooterTranslationUncheckedCreateInput>
  }


  /**
   * GroupFooterTranslation createMany
   */
  export type GroupFooterTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupFooterTranslations.
     */
    data: GroupFooterTranslationCreateManyInput | GroupFooterTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GroupFooterTranslation update
   */
  export type GroupFooterTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupFooterTranslation.
     */
    data: XOR<GroupFooterTranslationUpdateInput, GroupFooterTranslationUncheckedUpdateInput>
    /**
     * Choose, which GroupFooterTranslation to update.
     */
    where: GroupFooterTranslationWhereUniqueInput
  }


  /**
   * GroupFooterTranslation updateMany
   */
  export type GroupFooterTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupFooterTranslations.
     */
    data: XOR<GroupFooterTranslationUpdateManyMutationInput, GroupFooterTranslationUncheckedUpdateManyInput>
    /**
     * Filter which GroupFooterTranslations to update
     */
    where?: GroupFooterTranslationWhereInput
  }


  /**
   * GroupFooterTranslation upsert
   */
  export type GroupFooterTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupFooterTranslation to update in case it exists.
     */
    where: GroupFooterTranslationWhereUniqueInput
    /**
     * In case the GroupFooterTranslation found by the `where` argument doesn't exist, create a new GroupFooterTranslation with this data.
     */
    create: XOR<GroupFooterTranslationCreateInput, GroupFooterTranslationUncheckedCreateInput>
    /**
     * In case the GroupFooterTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupFooterTranslationUpdateInput, GroupFooterTranslationUncheckedUpdateInput>
  }


  /**
   * GroupFooterTranslation delete
   */
  export type GroupFooterTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
    /**
     * Filter which GroupFooterTranslation to delete.
     */
    where: GroupFooterTranslationWhereUniqueInput
  }


  /**
   * GroupFooterTranslation deleteMany
   */
  export type GroupFooterTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupFooterTranslations to delete
     */
    where?: GroupFooterTranslationWhereInput
  }


  /**
   * GroupFooterTranslation.groupfooter
   */
  export type GroupFooterTranslation$groupfooterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    where?: GroupFooterWhereInput
  }


  /**
   * GroupFooterTranslation without action
   */
  export type GroupFooterTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooterTranslation
     */
    select?: GroupFooterTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    groupFooterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    groupFooterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    groupFooterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageMinAggregateInputType = {
    id?: true
    groupFooterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    groupFooterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    groupFooterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    groupFooterId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupFooterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Page$translationsArgs<ExtArgs>
    navbarItem?: boolean | Page$navbarItemArgs<ExtArgs>
    dropdownItem?: boolean | Page$dropdownItemArgs<ExtArgs>
    groupFooter?: boolean | Page$groupFooterArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    groupFooterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Page$translationsArgs<ExtArgs>
    navbarItem?: boolean | Page$navbarItemArgs<ExtArgs>
    dropdownItem?: boolean | Page$dropdownItemArgs<ExtArgs>
    groupFooter?: boolean | Page$groupFooterArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      translations: Prisma.$PageTranslationPayload<ExtArgs>[]
      navbarItem: Prisma.$NavbarItemPayload<ExtArgs> | null
      dropdownItem: Prisma.$DropdownItemPayload<ExtArgs> | null
      groupFooter: Prisma.$GroupFooterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      groupFooterId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }


  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PageFindManyArgs, 'select' | 'include'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Page that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
    **/
    create<T extends PageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PageCreateArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pages.
     *     @param {PageCreateManyArgs} args - Arguments to create many Pages.
     *     @example
     *     // Create many Pages
     *     const page = await prisma.page.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
    **/
    delete<T extends PageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PageDeleteArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PageUpdateArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
    **/
    upsert<T extends PageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PageUpsertArgs<ExtArgs>>
    ): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Page$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Page$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    navbarItem<T extends Page$navbarItemArgs<ExtArgs> = {}>(args?: Subset<T, Page$navbarItemArgs<ExtArgs>>): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    dropdownItem<T extends Page$dropdownItemArgs<ExtArgs> = {}>(args?: Subset<T, Page$dropdownItemArgs<ExtArgs>>): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    groupFooter<T extends Page$groupFooterArgs<ExtArgs> = {}>(args?: Subset<T, Page$groupFooterArgs<ExtArgs>>): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Page model
   */ 
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly groupFooterId: FieldRef<"Page", 'String'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }


  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }


  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }


  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }


  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }


  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }


  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }


  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
  }


  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }


  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }


  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
  }


  /**
   * Page.translations
   */
  export type Page$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    where?: PageTranslationWhereInput
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    cursor?: PageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }


  /**
   * Page.navbarItem
   */
  export type Page$navbarItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    where?: NavbarItemWhereInput
  }


  /**
   * Page.dropdownItem
   */
  export type Page$dropdownItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    where?: DropdownItemWhereInput
  }


  /**
   * Page.groupFooter
   */
  export type Page$groupFooterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    where?: GroupFooterWhereInput
  }


  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageInclude<ExtArgs> | null
  }



  /**
   * Model PageTranslation
   */

  export type AggregatePageTranslation = {
    _count: PageTranslationCountAggregateOutputType | null
    _min: PageTranslationMinAggregateOutputType | null
    _max: PageTranslationMaxAggregateOutputType | null
  }

  export type PageTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    title: string | null
    description: string | null
    published: boolean | null
    pageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    title: string | null
    description: string | null
    published: boolean | null
    pageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTranslationCountAggregateOutputType = {
    id: number
    lang: number
    userId: number
    title: number
    description: number
    images: number
    published: number
    pageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    title?: true
    description?: true
    published?: true
    pageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    title?: true
    description?: true
    published?: true
    pageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    title?: true
    description?: true
    images?: true
    published?: true
    pageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageTranslation to aggregate.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageTranslations
    **/
    _count?: true | PageTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageTranslationMaxAggregateInputType
  }

  export type GetPageTranslationAggregateType<T extends PageTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregatePageTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageTranslation[P]>
      : GetScalarType<T[P], AggregatePageTranslation[P]>
  }




  export type PageTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PageTranslationWhereInput
    orderBy?: PageTranslationOrderByWithAggregationInput | PageTranslationOrderByWithAggregationInput[]
    by: PageTranslationScalarFieldEnum[] | PageTranslationScalarFieldEnum
    having?: PageTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageTranslationCountAggregateInputType | true
    _min?: PageTranslationMinAggregateInputType
    _max?: PageTranslationMaxAggregateInputType
  }

  export type PageTranslationGroupByOutputType = {
    id: string
    lang: string
    userId: string
    title: string
    description: string | null
    images: string[]
    published: boolean
    pageId: string
    createdAt: Date
    updatedAt: Date
    _count: PageTranslationCountAggregateOutputType | null
    _min: PageTranslationMinAggregateOutputType | null
    _max: PageTranslationMaxAggregateOutputType | null
  }

  type GetPageTranslationGroupByPayload<T extends PageTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], PageTranslationGroupByOutputType[P]>
        }
      >
    >


  export type PageTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    images?: boolean
    published?: boolean
    pageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    blocks?: boolean | PageTranslation$blocksArgs<ExtArgs>
    page?: boolean | PageDefaultArgs<ExtArgs>
    _count?: boolean | PageTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageTranslation"]>

  export type PageTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    images?: boolean
    published?: boolean
    pageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    blocks?: boolean | PageTranslation$blocksArgs<ExtArgs>
    page?: boolean | PageDefaultArgs<ExtArgs>
    _count?: boolean | PageTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PageTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "PageTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      blocks: Prisma.$BlockPayload<ExtArgs>[]
      page: Prisma.$PagePayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      userId: string
      title: string
      description: string | null
      images: string[]
      published: boolean
      pageId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pageTranslation"]>
    composites: {}
  }


  type PageTranslationGetPayload<S extends boolean | null | undefined | PageTranslationDefaultArgs> = $Result.GetResult<Prisma.$PageTranslationPayload, S>

  type PageTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PageTranslationFindManyArgs, 'select' | 'include'> & {
      select?: PageTranslationCountAggregateInputType | true
    }

  export interface PageTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageTranslation'], meta: { name: 'PageTranslation' } }
    /**
     * Find zero or one PageTranslation that matches the filter.
     * @param {PageTranslationFindUniqueArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PageTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PageTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PageTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PageTranslationFindUniqueOrThrowArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PageTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PageTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PageTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationFindFirstArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PageTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PageTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PageTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationFindFirstOrThrowArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PageTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PageTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PageTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageTranslations
     * const pageTranslations = await prisma.pageTranslation.findMany()
     * 
     * // Get first 10 PageTranslations
     * const pageTranslations = await prisma.pageTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageTranslationWithIdOnly = await prisma.pageTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PageTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PageTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PageTranslation.
     * @param {PageTranslationCreateArgs} args - Arguments to create a PageTranslation.
     * @example
     * // Create one PageTranslation
     * const PageTranslation = await prisma.pageTranslation.create({
     *   data: {
     *     // ... data to create a PageTranslation
     *   }
     * })
     * 
    **/
    create<T extends PageTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PageTranslationCreateArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PageTranslations.
     *     @param {PageTranslationCreateManyArgs} args - Arguments to create many PageTranslations.
     *     @example
     *     // Create many PageTranslations
     *     const pageTranslation = await prisma.pageTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PageTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PageTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PageTranslation.
     * @param {PageTranslationDeleteArgs} args - Arguments to delete one PageTranslation.
     * @example
     * // Delete one PageTranslation
     * const PageTranslation = await prisma.pageTranslation.delete({
     *   where: {
     *     // ... filter to delete one PageTranslation
     *   }
     * })
     * 
    **/
    delete<T extends PageTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PageTranslationDeleteArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PageTranslation.
     * @param {PageTranslationUpdateArgs} args - Arguments to update one PageTranslation.
     * @example
     * // Update one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PageTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PageTranslationUpdateArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PageTranslations.
     * @param {PageTranslationDeleteManyArgs} args - Arguments to filter PageTranslations to delete.
     * @example
     * // Delete a few PageTranslations
     * const { count } = await prisma.pageTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PageTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PageTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageTranslations
     * const pageTranslation = await prisma.pageTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PageTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PageTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PageTranslation.
     * @param {PageTranslationUpsertArgs} args - Arguments to update or create a PageTranslation.
     * @example
     * // Update or create a PageTranslation
     * const pageTranslation = await prisma.pageTranslation.upsert({
     *   create: {
     *     // ... data to create a PageTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends PageTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PageTranslationUpsertArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationCountArgs} args - Arguments to filter PageTranslations to count.
     * @example
     * // Count the number of PageTranslations
     * const count = await prisma.pageTranslation.count({
     *   where: {
     *     // ... the filter for the PageTranslations we want to count
     *   }
     * })
    **/
    count<T extends PageTranslationCountArgs>(
      args?: Subset<T, PageTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageTranslationAggregateArgs>(args: Subset<T, PageTranslationAggregateArgs>): Prisma.PrismaPromise<GetPageTranslationAggregateType<T>>

    /**
     * Group by PageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageTranslationGroupByArgs['orderBy'] }
        : { orderBy?: PageTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageTranslation model
   */
  readonly fields: PageTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    blocks<T extends PageTranslation$blocksArgs<ExtArgs> = {}>(args?: Subset<T, PageTranslation$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findMany'> | Null>;

    page<T extends PageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PageDefaultArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PageTranslation model
   */ 
  interface PageTranslationFieldRefs {
    readonly id: FieldRef<"PageTranslation", 'String'>
    readonly lang: FieldRef<"PageTranslation", 'String'>
    readonly userId: FieldRef<"PageTranslation", 'String'>
    readonly title: FieldRef<"PageTranslation", 'String'>
    readonly description: FieldRef<"PageTranslation", 'String'>
    readonly images: FieldRef<"PageTranslation", 'String[]'>
    readonly published: FieldRef<"PageTranslation", 'Boolean'>
    readonly pageId: FieldRef<"PageTranslation", 'String'>
    readonly createdAt: FieldRef<"PageTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"PageTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PageTranslation findUnique
   */
  export type PageTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where: PageTranslationWhereUniqueInput
  }


  /**
   * PageTranslation findUniqueOrThrow
   */
  export type PageTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where: PageTranslationWhereUniqueInput
  }


  /**
   * PageTranslation findFirst
   */
  export type PageTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTranslations.
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTranslations.
     */
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }


  /**
   * PageTranslation findFirstOrThrow
   */
  export type PageTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTranslations.
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTranslations.
     */
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }


  /**
   * PageTranslation findMany
   */
  export type PageTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslations to fetch.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageTranslations.
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }


  /**
   * PageTranslation create
   */
  export type PageTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a PageTranslation.
     */
    data: XOR<PageTranslationCreateInput, PageTranslationUncheckedCreateInput>
  }


  /**
   * PageTranslation createMany
   */
  export type PageTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageTranslations.
     */
    data: PageTranslationCreateManyInput | PageTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PageTranslation update
   */
  export type PageTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a PageTranslation.
     */
    data: XOR<PageTranslationUpdateInput, PageTranslationUncheckedUpdateInput>
    /**
     * Choose, which PageTranslation to update.
     */
    where: PageTranslationWhereUniqueInput
  }


  /**
   * PageTranslation updateMany
   */
  export type PageTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageTranslations.
     */
    data: XOR<PageTranslationUpdateManyMutationInput, PageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PageTranslations to update
     */
    where?: PageTranslationWhereInput
  }


  /**
   * PageTranslation upsert
   */
  export type PageTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the PageTranslation to update in case it exists.
     */
    where: PageTranslationWhereUniqueInput
    /**
     * In case the PageTranslation found by the `where` argument doesn't exist, create a new PageTranslation with this data.
     */
    create: XOR<PageTranslationCreateInput, PageTranslationUncheckedCreateInput>
    /**
     * In case the PageTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageTranslationUpdateInput, PageTranslationUncheckedUpdateInput>
  }


  /**
   * PageTranslation delete
   */
  export type PageTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter which PageTranslation to delete.
     */
    where: PageTranslationWhereUniqueInput
  }


  /**
   * PageTranslation deleteMany
   */
  export type PageTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageTranslations to delete
     */
    where?: PageTranslationWhereInput
  }


  /**
   * PageTranslation.blocks
   */
  export type PageTranslation$blocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * PageTranslation without action
   */
  export type PageTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Category$translationsArgs<ExtArgs>
    articles?: boolean | Category$articlesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Category$translationsArgs<ExtArgs>
    articles?: boolean | Category$articlesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      translations: Prisma.$CategoryTranslationPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Category$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    articles<T extends Category$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Category$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.translations
   */
  export type Category$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    cursor?: CategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }


  /**
   * Category.articles
   */
  export type Category$articlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model CategoryTranslation
   */

  export type AggregateCategoryTranslation = {
    _count: CategoryTranslationCountAggregateOutputType | null
    _min: CategoryTranslationMinAggregateOutputType | null
    _max: CategoryTranslationMaxAggregateOutputType | null
  }

  export type CategoryTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryTranslationCountAggregateOutputType = {
    id: number
    lang: number
    userId: number
    name: number
    description: number
    images: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    name?: true
    description?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    name?: true
    description?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    name?: true
    description?: true
    images?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryTranslation to aggregate.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryTranslations
    **/
    _count?: true | CategoryTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryTranslationMaxAggregateInputType
  }

  export type GetCategoryTranslationAggregateType<T extends CategoryTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryTranslation[P]>
      : GetScalarType<T[P], AggregateCategoryTranslation[P]>
  }




  export type CategoryTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithAggregationInput | CategoryTranslationOrderByWithAggregationInput[]
    by: CategoryTranslationScalarFieldEnum[] | CategoryTranslationScalarFieldEnum
    having?: CategoryTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryTranslationCountAggregateInputType | true
    _min?: CategoryTranslationMinAggregateInputType
    _max?: CategoryTranslationMaxAggregateInputType
  }

  export type CategoryTranslationGroupByOutputType = {
    id: string
    lang: string
    userId: string
    name: string
    description: string | null
    images: string[]
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryTranslationCountAggregateOutputType | null
    _min: CategoryTranslationMinAggregateOutputType | null
    _max: CategoryTranslationMaxAggregateOutputType | null
  }

  type GetCategoryTranslationGroupByPayload<T extends CategoryTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryTranslationGroupByOutputType[P]>
        }
      >
    >


  export type CategoryTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    images?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    images?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }


  export type $CategoryTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CategoryTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      userId: string
      name: string
      description: string | null
      images: string[]
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryTranslation"]>
    composites: {}
  }


  type CategoryTranslationGetPayload<S extends boolean | null | undefined | CategoryTranslationDefaultArgs> = $Result.GetResult<Prisma.$CategoryTranslationPayload, S>

  type CategoryTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryTranslationFindManyArgs, 'select' | 'include'> & {
      select?: CategoryTranslationCountAggregateInputType | true
    }

  export interface CategoryTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryTranslation'], meta: { name: 'CategoryTranslation' } }
    /**
     * Find zero or one CategoryTranslation that matches the filter.
     * @param {CategoryTranslationFindUniqueArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CategoryTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryTranslationFindUniqueOrThrowArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CategoryTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindFirstArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CategoryTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindFirstOrThrowArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CategoryTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryTranslations
     * const categoryTranslations = await prisma.categoryTranslation.findMany()
     * 
     * // Get first 10 CategoryTranslations
     * const categoryTranslations = await prisma.categoryTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CategoryTranslation.
     * @param {CategoryTranslationCreateArgs} args - Arguments to create a CategoryTranslation.
     * @example
     * // Create one CategoryTranslation
     * const CategoryTranslation = await prisma.categoryTranslation.create({
     *   data: {
     *     // ... data to create a CategoryTranslation
     *   }
     * })
     * 
    **/
    create<T extends CategoryTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryTranslationCreateArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CategoryTranslations.
     *     @param {CategoryTranslationCreateManyArgs} args - Arguments to create many CategoryTranslations.
     *     @example
     *     // Create many CategoryTranslations
     *     const categoryTranslation = await prisma.categoryTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryTranslation.
     * @param {CategoryTranslationDeleteArgs} args - Arguments to delete one CategoryTranslation.
     * @example
     * // Delete one CategoryTranslation
     * const CategoryTranslation = await prisma.categoryTranslation.delete({
     *   where: {
     *     // ... filter to delete one CategoryTranslation
     *   }
     * })
     * 
    **/
    delete<T extends CategoryTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryTranslationDeleteArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CategoryTranslation.
     * @param {CategoryTranslationUpdateArgs} args - Arguments to update one CategoryTranslation.
     * @example
     * // Update one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryTranslationUpdateArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CategoryTranslations.
     * @param {CategoryTranslationDeleteManyArgs} args - Arguments to filter CategoryTranslations to delete.
     * @example
     * // Delete a few CategoryTranslations
     * const { count } = await prisma.categoryTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryTranslation.
     * @param {CategoryTranslationUpsertArgs} args - Arguments to update or create a CategoryTranslation.
     * @example
     * // Update or create a CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.upsert({
     *   create: {
     *     // ... data to create a CategoryTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryTranslationUpsertArgs<ExtArgs>>
    ): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationCountArgs} args - Arguments to filter CategoryTranslations to count.
     * @example
     * // Count the number of CategoryTranslations
     * const count = await prisma.categoryTranslation.count({
     *   where: {
     *     // ... the filter for the CategoryTranslations we want to count
     *   }
     * })
    **/
    count<T extends CategoryTranslationCountArgs>(
      args?: Subset<T, CategoryTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryTranslationAggregateArgs>(args: Subset<T, CategoryTranslationAggregateArgs>): Prisma.PrismaPromise<GetCategoryTranslationAggregateType<T>>

    /**
     * Group by CategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryTranslationGroupByArgs['orderBy'] }
        : { orderBy?: CategoryTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryTranslation model
   */
  readonly fields: CategoryTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CategoryTranslation model
   */ 
  interface CategoryTranslationFieldRefs {
    readonly id: FieldRef<"CategoryTranslation", 'String'>
    readonly lang: FieldRef<"CategoryTranslation", 'String'>
    readonly userId: FieldRef<"CategoryTranslation", 'String'>
    readonly name: FieldRef<"CategoryTranslation", 'String'>
    readonly description: FieldRef<"CategoryTranslation", 'String'>
    readonly images: FieldRef<"CategoryTranslation", 'String[]'>
    readonly categoryId: FieldRef<"CategoryTranslation", 'String'>
    readonly createdAt: FieldRef<"CategoryTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CategoryTranslation findUnique
   */
  export type CategoryTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where: CategoryTranslationWhereUniqueInput
  }


  /**
   * CategoryTranslation findUniqueOrThrow
   */
  export type CategoryTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where: CategoryTranslationWhereUniqueInput
  }


  /**
   * CategoryTranslation findFirst
   */
  export type CategoryTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryTranslations.
     */
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }


  /**
   * CategoryTranslation findFirstOrThrow
   */
  export type CategoryTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryTranslations.
     */
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }


  /**
   * CategoryTranslation findMany
   */
  export type CategoryTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslations to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }


  /**
   * CategoryTranslation create
   */
  export type CategoryTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryTranslation.
     */
    data: XOR<CategoryTranslationCreateInput, CategoryTranslationUncheckedCreateInput>
  }


  /**
   * CategoryTranslation createMany
   */
  export type CategoryTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryTranslations.
     */
    data: CategoryTranslationCreateManyInput | CategoryTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CategoryTranslation update
   */
  export type CategoryTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryTranslation.
     */
    data: XOR<CategoryTranslationUpdateInput, CategoryTranslationUncheckedUpdateInput>
    /**
     * Choose, which CategoryTranslation to update.
     */
    where: CategoryTranslationWhereUniqueInput
  }


  /**
   * CategoryTranslation updateMany
   */
  export type CategoryTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryTranslations.
     */
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CategoryTranslations to update
     */
    where?: CategoryTranslationWhereInput
  }


  /**
   * CategoryTranslation upsert
   */
  export type CategoryTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryTranslation to update in case it exists.
     */
    where: CategoryTranslationWhereUniqueInput
    /**
     * In case the CategoryTranslation found by the `where` argument doesn't exist, create a new CategoryTranslation with this data.
     */
    create: XOR<CategoryTranslationCreateInput, CategoryTranslationUncheckedCreateInput>
    /**
     * In case the CategoryTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryTranslationUpdateInput, CategoryTranslationUncheckedUpdateInput>
  }


  /**
   * CategoryTranslation delete
   */
  export type CategoryTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter which CategoryTranslation to delete.
     */
    where: CategoryTranslationWhereUniqueInput
  }


  /**
   * CategoryTranslation deleteMany
   */
  export type CategoryTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryTranslations to delete
     */
    where?: CategoryTranslationWhereInput
  }


  /**
   * CategoryTranslation without action
   */
  export type CategoryTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    footerId: string | null
    groupfooterId: string | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    footerId: string | null
    groupfooterId: string | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    categoryId: number
    createdAt: number
    updatedAt: number
    footerId: number
    groupfooterId: number
    _all: number
  }


  export type ArticleMinAggregateInputType = {
    id?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    footerId?: true
    groupfooterId?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    footerId?: true
    groupfooterId?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    footerId?: true
    groupfooterId?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: string
    categoryId: string | null
    createdAt: Date
    updatedAt: Date
    footerId: string | null
    groupfooterId: string | null
    _count: ArticleCountAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    footerId?: boolean
    groupfooterId?: boolean
    translations?: boolean | Article$translationsArgs<ExtArgs>
    category?: boolean | Article$categoryArgs<ExtArgs>
    tags?: boolean | Article$tagsArgs<ExtArgs>
    comments?: boolean | Article$commentsArgs<ExtArgs>
    footer?: boolean | Article$footerArgs<ExtArgs>
    groupfooter?: boolean | Article$groupfooterArgs<ExtArgs>
    navbarItem?: boolean | Article$navbarItemArgs<ExtArgs>
    dropdownItem?: boolean | Article$dropdownItemArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    footerId?: boolean
    groupfooterId?: boolean
  }

  export type ArticleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Article$translationsArgs<ExtArgs>
    category?: boolean | Article$categoryArgs<ExtArgs>
    tags?: boolean | Article$tagsArgs<ExtArgs>
    comments?: boolean | Article$commentsArgs<ExtArgs>
    footer?: boolean | Article$footerArgs<ExtArgs>
    groupfooter?: boolean | Article$groupfooterArgs<ExtArgs>
    navbarItem?: boolean | Article$navbarItemArgs<ExtArgs>
    dropdownItem?: boolean | Article$dropdownItemArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ArticlePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {
      translations: Prisma.$ArticleTranslationPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      tags: Prisma.$TagPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      footer: Prisma.$FooterPayload<ExtArgs> | null
      groupfooter: Prisma.$GroupFooterPayload<ExtArgs> | null
      navbarItem: Prisma.$NavbarItemPayload<ExtArgs> | null
      dropdownItem: Prisma.$DropdownItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      categoryId: string | null
      createdAt: Date
      updatedAt: Date
      footerId: string | null
      groupfooterId: string | null
    }, ExtArgs["result"]["article"]>
    composites: {}
  }


  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ArticleFindManyArgs, 'select' | 'include'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
    **/
    create<T extends ArticleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Articles.
     *     @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const article = await prisma.article.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Article$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Article$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    category<T extends Article$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Article$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    tags<T extends Article$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Article$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'> | Null>;

    comments<T extends Article$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Article$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    footer<T extends Article$footerArgs<ExtArgs> = {}>(args?: Subset<T, Article$footerArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    groupfooter<T extends Article$groupfooterArgs<ExtArgs> = {}>(args?: Subset<T, Article$groupfooterArgs<ExtArgs>>): Prisma__GroupFooterClient<$Result.GetResult<Prisma.$GroupFooterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    navbarItem<T extends Article$navbarItemArgs<ExtArgs> = {}>(args?: Subset<T, Article$navbarItemArgs<ExtArgs>>): Prisma__NavbarItemClient<$Result.GetResult<Prisma.$NavbarItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    dropdownItem<T extends Article$dropdownItemArgs<ExtArgs> = {}>(args?: Subset<T, Article$dropdownItemArgs<ExtArgs>>): Prisma__DropdownItemClient<$Result.GetResult<Prisma.$DropdownItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Article model
   */ 
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'String'>
    readonly categoryId: FieldRef<"Article", 'String'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly updatedAt: FieldRef<"Article", 'DateTime'>
    readonly footerId: FieldRef<"Article", 'String'>
    readonly groupfooterId: FieldRef<"Article", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }


  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }


  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }


  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }


  /**
   * Article.translations
   */
  export type Article$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    where?: ArticleTranslationWhereInput
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    cursor?: ArticleTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }


  /**
   * Article.category
   */
  export type Article$categoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }


  /**
   * Article.tags
   */
  export type Article$tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Article.comments
   */
  export type Article$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Article.footer
   */
  export type Article$footerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FooterInclude<ExtArgs> | null
    where?: FooterWhereInput
  }


  /**
   * Article.groupfooter
   */
  export type Article$groupfooterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupFooter
     */
    select?: GroupFooterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupFooterInclude<ExtArgs> | null
    where?: GroupFooterWhereInput
  }


  /**
   * Article.navbarItem
   */
  export type Article$navbarItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavbarItem
     */
    select?: NavbarItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NavbarItemInclude<ExtArgs> | null
    where?: NavbarItemWhereInput
  }


  /**
   * Article.dropdownItem
   */
  export type Article$dropdownItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownItem
     */
    select?: DropdownItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropdownItemInclude<ExtArgs> | null
    where?: DropdownItemWhereInput
  }


  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
  }



  /**
   * Model ArticleTranslation
   */

  export type AggregateArticleTranslation = {
    _count: ArticleTranslationCountAggregateOutputType | null
    _min: ArticleTranslationMinAggregateOutputType | null
    _max: ArticleTranslationMaxAggregateOutputType | null
  }

  export type ArticleTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    slug: string | null
    published: boolean | null
    title: string | null
    description: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    slug: string | null
    published: boolean | null
    title: string | null
    description: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleTranslationCountAggregateOutputType = {
    id: number
    lang: number
    userId: number
    slug: number
    published: number
    title: number
    description: number
    articleId: number
    images: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    slug?: true
    published?: true
    title?: true
    description?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    slug?: true
    published?: true
    title?: true
    description?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    slug?: true
    published?: true
    title?: true
    description?: true
    articleId?: true
    images?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleTranslation to aggregate.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleTranslations
    **/
    _count?: true | ArticleTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleTranslationMaxAggregateInputType
  }

  export type GetArticleTranslationAggregateType<T extends ArticleTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleTranslation[P]>
      : GetScalarType<T[P], AggregateArticleTranslation[P]>
  }




  export type ArticleTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleTranslationWhereInput
    orderBy?: ArticleTranslationOrderByWithAggregationInput | ArticleTranslationOrderByWithAggregationInput[]
    by: ArticleTranslationScalarFieldEnum[] | ArticleTranslationScalarFieldEnum
    having?: ArticleTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleTranslationCountAggregateInputType | true
    _min?: ArticleTranslationMinAggregateInputType
    _max?: ArticleTranslationMaxAggregateInputType
  }

  export type ArticleTranslationGroupByOutputType = {
    id: string
    lang: string
    userId: string
    slug: string | null
    published: boolean
    title: string | null
    description: string | null
    articleId: string
    images: string[]
    createdAt: Date
    updatedAt: Date
    _count: ArticleTranslationCountAggregateOutputType | null
    _min: ArticleTranslationMinAggregateOutputType | null
    _max: ArticleTranslationMaxAggregateOutputType | null
  }

  type GetArticleTranslationGroupByPayload<T extends ArticleTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ArticleTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    userId?: boolean
    slug?: boolean
    published?: boolean
    title?: boolean
    description?: boolean
    articleId?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    blocks?: boolean | ArticleTranslation$blocksArgs<ExtArgs>
    _count?: boolean | ArticleTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleTranslation"]>

  export type ArticleTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    userId?: boolean
    slug?: boolean
    published?: boolean
    title?: boolean
    description?: boolean
    articleId?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArticleTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    blocks?: boolean | ArticleTranslation$blocksArgs<ExtArgs>
    _count?: boolean | ArticleTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ArticleTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ArticleTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      article: Prisma.$ArticlePayload<ExtArgs>
      blocks: Prisma.$BlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      userId: string
      slug: string | null
      published: boolean
      title: string | null
      description: string | null
      articleId: string
      images: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["articleTranslation"]>
    composites: {}
  }


  type ArticleTranslationGetPayload<S extends boolean | null | undefined | ArticleTranslationDefaultArgs> = $Result.GetResult<Prisma.$ArticleTranslationPayload, S>

  type ArticleTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ArticleTranslationFindManyArgs, 'select' | 'include'> & {
      select?: ArticleTranslationCountAggregateInputType | true
    }

  export interface ArticleTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleTranslation'], meta: { name: 'ArticleTranslation' } }
    /**
     * Find zero or one ArticleTranslation that matches the filter.
     * @param {ArticleTranslationFindUniqueArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ArticleTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleTranslationFindUniqueOrThrowArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ArticleTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationFindFirstArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ArticleTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationFindFirstOrThrowArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ArticleTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleTranslations
     * const articleTranslations = await prisma.articleTranslation.findMany()
     * 
     * // Get first 10 ArticleTranslations
     * const articleTranslations = await prisma.articleTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleTranslationWithIdOnly = await prisma.articleTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ArticleTranslation.
     * @param {ArticleTranslationCreateArgs} args - Arguments to create a ArticleTranslation.
     * @example
     * // Create one ArticleTranslation
     * const ArticleTranslation = await prisma.articleTranslation.create({
     *   data: {
     *     // ... data to create a ArticleTranslation
     *   }
     * })
     * 
    **/
    create<T extends ArticleTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleTranslationCreateArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ArticleTranslations.
     *     @param {ArticleTranslationCreateManyArgs} args - Arguments to create many ArticleTranslations.
     *     @example
     *     // Create many ArticleTranslations
     *     const articleTranslation = await prisma.articleTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleTranslation.
     * @param {ArticleTranslationDeleteArgs} args - Arguments to delete one ArticleTranslation.
     * @example
     * // Delete one ArticleTranslation
     * const ArticleTranslation = await prisma.articleTranslation.delete({
     *   where: {
     *     // ... filter to delete one ArticleTranslation
     *   }
     * })
     * 
    **/
    delete<T extends ArticleTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleTranslationDeleteArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ArticleTranslation.
     * @param {ArticleTranslationUpdateArgs} args - Arguments to update one ArticleTranslation.
     * @example
     * // Update one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleTranslationUpdateArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ArticleTranslations.
     * @param {ArticleTranslationDeleteManyArgs} args - Arguments to filter ArticleTranslations to delete.
     * @example
     * // Delete a few ArticleTranslations
     * const { count } = await prisma.articleTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleTranslations
     * const articleTranslation = await prisma.articleTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleTranslation.
     * @param {ArticleTranslationUpsertArgs} args - Arguments to update or create a ArticleTranslation.
     * @example
     * // Update or create a ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.upsert({
     *   create: {
     *     // ... data to create a ArticleTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleTranslationUpsertArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ArticleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationCountArgs} args - Arguments to filter ArticleTranslations to count.
     * @example
     * // Count the number of ArticleTranslations
     * const count = await prisma.articleTranslation.count({
     *   where: {
     *     // ... the filter for the ArticleTranslations we want to count
     *   }
     * })
    **/
    count<T extends ArticleTranslationCountArgs>(
      args?: Subset<T, ArticleTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleTranslationAggregateArgs>(args: Subset<T, ArticleTranslationAggregateArgs>): Prisma.PrismaPromise<GetArticleTranslationAggregateType<T>>

    /**
     * Group by ArticleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ArticleTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleTranslation model
   */
  readonly fields: ArticleTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    blocks<T extends ArticleTranslation$blocksArgs<ExtArgs> = {}>(args?: Subset<T, ArticleTranslation$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ArticleTranslation model
   */ 
  interface ArticleTranslationFieldRefs {
    readonly id: FieldRef<"ArticleTranslation", 'String'>
    readonly lang: FieldRef<"ArticleTranslation", 'String'>
    readonly userId: FieldRef<"ArticleTranslation", 'String'>
    readonly slug: FieldRef<"ArticleTranslation", 'String'>
    readonly published: FieldRef<"ArticleTranslation", 'Boolean'>
    readonly title: FieldRef<"ArticleTranslation", 'String'>
    readonly description: FieldRef<"ArticleTranslation", 'String'>
    readonly articleId: FieldRef<"ArticleTranslation", 'String'>
    readonly images: FieldRef<"ArticleTranslation", 'String[]'>
    readonly createdAt: FieldRef<"ArticleTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ArticleTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ArticleTranslation findUnique
   */
  export type ArticleTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where: ArticleTranslationWhereUniqueInput
  }


  /**
   * ArticleTranslation findUniqueOrThrow
   */
  export type ArticleTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where: ArticleTranslationWhereUniqueInput
  }


  /**
   * ArticleTranslation findFirst
   */
  export type ArticleTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleTranslations.
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleTranslations.
     */
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }


  /**
   * ArticleTranslation findFirstOrThrow
   */
  export type ArticleTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleTranslations.
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleTranslations.
     */
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }


  /**
   * ArticleTranslation findMany
   */
  export type ArticleTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslations to fetch.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?: ArticleTranslationOrderByWithRelationInput | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleTranslations.
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }


  /**
   * ArticleTranslation create
   */
  export type ArticleTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleTranslation.
     */
    data: XOR<ArticleTranslationCreateInput, ArticleTranslationUncheckedCreateInput>
  }


  /**
   * ArticleTranslation createMany
   */
  export type ArticleTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleTranslations.
     */
    data: ArticleTranslationCreateManyInput | ArticleTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ArticleTranslation update
   */
  export type ArticleTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleTranslation.
     */
    data: XOR<ArticleTranslationUpdateInput, ArticleTranslationUncheckedUpdateInput>
    /**
     * Choose, which ArticleTranslation to update.
     */
    where: ArticleTranslationWhereUniqueInput
  }


  /**
   * ArticleTranslation updateMany
   */
  export type ArticleTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleTranslations.
     */
    data: XOR<ArticleTranslationUpdateManyMutationInput, ArticleTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ArticleTranslations to update
     */
    where?: ArticleTranslationWhereInput
  }


  /**
   * ArticleTranslation upsert
   */
  export type ArticleTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleTranslation to update in case it exists.
     */
    where: ArticleTranslationWhereUniqueInput
    /**
     * In case the ArticleTranslation found by the `where` argument doesn't exist, create a new ArticleTranslation with this data.
     */
    create: XOR<ArticleTranslationCreateInput, ArticleTranslationUncheckedCreateInput>
    /**
     * In case the ArticleTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleTranslationUpdateInput, ArticleTranslationUncheckedUpdateInput>
  }


  /**
   * ArticleTranslation delete
   */
  export type ArticleTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter which ArticleTranslation to delete.
     */
    where: ArticleTranslationWhereUniqueInput
  }


  /**
   * ArticleTranslation deleteMany
   */
  export type ArticleTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleTranslations to delete
     */
    where?: ArticleTranslationWhereInput
  }


  /**
   * ArticleTranslation.blocks
   */
  export type ArticleTranslation$blocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * ArticleTranslation without action
   */
  export type ArticleTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Tag$translationsArgs<ExtArgs>
    articles?: boolean | Tag$articlesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Tag$translationsArgs<ExtArgs>
    articles?: boolean | Tag$articlesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      translations: Prisma.$TagTranslationPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }


  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Tag$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    articles<T extends Tag$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.translations
   */
  export type Tag$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    where?: TagTranslationWhereInput
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    cursor?: TagTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }


  /**
   * Tag.articles
   */
  export type Tag$articlesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
  }



  /**
   * Model TagTranslation
   */

  export type AggregateTagTranslation = {
    _count: TagTranslationCountAggregateOutputType | null
    _min: TagTranslationMinAggregateOutputType | null
    _max: TagTranslationMaxAggregateOutputType | null
  }

  export type TagTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    tagId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    tagId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagTranslationCountAggregateOutputType = {
    id: number
    lang: number
    tagId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    tagId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    tagId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    tagId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagTranslation to aggregate.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagTranslations
    **/
    _count?: true | TagTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagTranslationMaxAggregateInputType
  }

  export type GetTagTranslationAggregateType<T extends TagTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTagTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagTranslation[P]>
      : GetScalarType<T[P], AggregateTagTranslation[P]>
  }




  export type TagTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagTranslationWhereInput
    orderBy?: TagTranslationOrderByWithAggregationInput | TagTranslationOrderByWithAggregationInput[]
    by: TagTranslationScalarFieldEnum[] | TagTranslationScalarFieldEnum
    having?: TagTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagTranslationCountAggregateInputType | true
    _min?: TagTranslationMinAggregateInputType
    _max?: TagTranslationMaxAggregateInputType
  }

  export type TagTranslationGroupByOutputType = {
    id: string
    lang: string
    tagId: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TagTranslationCountAggregateOutputType | null
    _min: TagTranslationMinAggregateOutputType | null
    _max: TagTranslationMaxAggregateOutputType | null
  }

  type GetTagTranslationGroupByPayload<T extends TagTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TagTranslationGroupByOutputType[P]>
        }
      >
    >


  export type TagTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    tagId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTranslation"]>

  export type TagTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    tagId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }


  export type $TagTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "TagTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      tagId: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tagTranslation"]>
    composites: {}
  }


  type TagTranslationGetPayload<S extends boolean | null | undefined | TagTranslationDefaultArgs> = $Result.GetResult<Prisma.$TagTranslationPayload, S>

  type TagTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TagTranslationFindManyArgs, 'select' | 'include'> & {
      select?: TagTranslationCountAggregateInputType | true
    }

  export interface TagTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagTranslation'], meta: { name: 'TagTranslation' } }
    /**
     * Find zero or one TagTranslation that matches the filter.
     * @param {TagTranslationFindUniqueArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TagTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TagTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagTranslationFindUniqueOrThrowArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TagTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationFindFirstArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TagTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TagTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationFindFirstOrThrowArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TagTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagTranslations
     * const tagTranslations = await prisma.tagTranslation.findMany()
     * 
     * // Get first 10 TagTranslations
     * const tagTranslations = await prisma.tagTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagTranslationWithIdOnly = await prisma.tagTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TagTranslation.
     * @param {TagTranslationCreateArgs} args - Arguments to create a TagTranslation.
     * @example
     * // Create one TagTranslation
     * const TagTranslation = await prisma.tagTranslation.create({
     *   data: {
     *     // ... data to create a TagTranslation
     *   }
     * })
     * 
    **/
    create<T extends TagTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagTranslationCreateArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TagTranslations.
     *     @param {TagTranslationCreateManyArgs} args - Arguments to create many TagTranslations.
     *     @example
     *     // Create many TagTranslations
     *     const tagTranslation = await prisma.tagTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TagTranslation.
     * @param {TagTranslationDeleteArgs} args - Arguments to delete one TagTranslation.
     * @example
     * // Delete one TagTranslation
     * const TagTranslation = await prisma.tagTranslation.delete({
     *   where: {
     *     // ... filter to delete one TagTranslation
     *   }
     * })
     * 
    **/
    delete<T extends TagTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagTranslationDeleteArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TagTranslation.
     * @param {TagTranslationUpdateArgs} args - Arguments to update one TagTranslation.
     * @example
     * // Update one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagTranslationUpdateArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TagTranslations.
     * @param {TagTranslationDeleteManyArgs} args - Arguments to filter TagTranslations to delete.
     * @example
     * // Delete a few TagTranslations
     * const { count } = await prisma.tagTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagTranslations
     * const tagTranslation = await prisma.tagTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TagTranslation.
     * @param {TagTranslationUpsertArgs} args - Arguments to update or create a TagTranslation.
     * @example
     * // Update or create a TagTranslation
     * const tagTranslation = await prisma.tagTranslation.upsert({
     *   create: {
     *     // ... data to create a TagTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends TagTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagTranslationUpsertArgs<ExtArgs>>
    ): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TagTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationCountArgs} args - Arguments to filter TagTranslations to count.
     * @example
     * // Count the number of TagTranslations
     * const count = await prisma.tagTranslation.count({
     *   where: {
     *     // ... the filter for the TagTranslations we want to count
     *   }
     * })
    **/
    count<T extends TagTranslationCountArgs>(
      args?: Subset<T, TagTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagTranslationAggregateArgs>(args: Subset<T, TagTranslationAggregateArgs>): Prisma.PrismaPromise<GetTagTranslationAggregateType<T>>

    /**
     * Group by TagTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagTranslationGroupByArgs['orderBy'] }
        : { orderBy?: TagTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagTranslation model
   */
  readonly fields: TagTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TagTranslation model
   */ 
  interface TagTranslationFieldRefs {
    readonly id: FieldRef<"TagTranslation", 'String'>
    readonly lang: FieldRef<"TagTranslation", 'String'>
    readonly tagId: FieldRef<"TagTranslation", 'String'>
    readonly name: FieldRef<"TagTranslation", 'String'>
    readonly createdAt: FieldRef<"TagTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"TagTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TagTranslation findUnique
   */
  export type TagTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where: TagTranslationWhereUniqueInput
  }


  /**
   * TagTranslation findUniqueOrThrow
   */
  export type TagTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where: TagTranslationWhereUniqueInput
  }


  /**
   * TagTranslation findFirst
   */
  export type TagTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagTranslations.
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagTranslations.
     */
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }


  /**
   * TagTranslation findFirstOrThrow
   */
  export type TagTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagTranslations.
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagTranslations.
     */
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }


  /**
   * TagTranslation findMany
   */
  export type TagTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslations to fetch.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagTranslations.
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }


  /**
   * TagTranslation create
   */
  export type TagTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a TagTranslation.
     */
    data: XOR<TagTranslationCreateInput, TagTranslationUncheckedCreateInput>
  }


  /**
   * TagTranslation createMany
   */
  export type TagTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagTranslations.
     */
    data: TagTranslationCreateManyInput | TagTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TagTranslation update
   */
  export type TagTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a TagTranslation.
     */
    data: XOR<TagTranslationUpdateInput, TagTranslationUncheckedUpdateInput>
    /**
     * Choose, which TagTranslation to update.
     */
    where: TagTranslationWhereUniqueInput
  }


  /**
   * TagTranslation updateMany
   */
  export type TagTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagTranslations.
     */
    data: XOR<TagTranslationUpdateManyMutationInput, TagTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TagTranslations to update
     */
    where?: TagTranslationWhereInput
  }


  /**
   * TagTranslation upsert
   */
  export type TagTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the TagTranslation to update in case it exists.
     */
    where: TagTranslationWhereUniqueInput
    /**
     * In case the TagTranslation found by the `where` argument doesn't exist, create a new TagTranslation with this data.
     */
    create: XOR<TagTranslationCreateInput, TagTranslationUncheckedCreateInput>
    /**
     * In case the TagTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagTranslationUpdateInput, TagTranslationUncheckedUpdateInput>
  }


  /**
   * TagTranslation delete
   */
  export type TagTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter which TagTranslation to delete.
     */
    where: TagTranslationWhereUniqueInput
  }


  /**
   * TagTranslation deleteMany
   */
  export type TagTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagTranslations to delete
     */
    where?: TagTranslationWhereInput
  }


  /**
   * TagTranslation without action
   */
  export type TagTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    articleId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Comment$translationsArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    translations?: boolean | Comment$translationsArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      translations: Prisma.$CommentTranslationPayload<ExtArgs>[]
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      articleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    translations<T extends Comment$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly articleId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.translations
   */
  export type Comment$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    where?: CommentTranslationWhereInput
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    cursor?: CommentTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentTranslationScalarFieldEnum | CommentTranslationScalarFieldEnum[]
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model CommentTranslation
   */

  export type AggregateCommentTranslation = {
    _count: CommentTranslationCountAggregateOutputType | null
    _min: CommentTranslationMinAggregateOutputType | null
    _max: CommentTranslationMaxAggregateOutputType | null
  }

  export type CommentTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    name: string | null
    body: string | null
    commentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    userId: string | null
    name: string | null
    body: string | null
    commentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentTranslationCountAggregateOutputType = {
    id: number
    lang: number
    userId: number
    name: number
    body: number
    commentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    name?: true
    body?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    name?: true
    body?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    userId?: true
    name?: true
    body?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentTranslation to aggregate.
     */
    where?: CommentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentTranslations to fetch.
     */
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentTranslations
    **/
    _count?: true | CommentTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentTranslationMaxAggregateInputType
  }

  export type GetCommentTranslationAggregateType<T extends CommentTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentTranslation[P]>
      : GetScalarType<T[P], AggregateCommentTranslation[P]>
  }




  export type CommentTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentTranslationWhereInput
    orderBy?: CommentTranslationOrderByWithAggregationInput | CommentTranslationOrderByWithAggregationInput[]
    by: CommentTranslationScalarFieldEnum[] | CommentTranslationScalarFieldEnum
    having?: CommentTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentTranslationCountAggregateInputType | true
    _min?: CommentTranslationMinAggregateInputType
    _max?: CommentTranslationMaxAggregateInputType
  }

  export type CommentTranslationGroupByOutputType = {
    id: string
    lang: string
    userId: string | null
    name: string | null
    body: string
    commentId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentTranslationCountAggregateOutputType | null
    _min: CommentTranslationMinAggregateOutputType | null
    _max: CommentTranslationMaxAggregateOutputType | null
  }

  type GetCommentTranslationGroupByPayload<T extends CommentTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CommentTranslationGroupByOutputType[P]>
        }
      >
    >


  export type CommentTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    userId?: boolean
    name?: boolean
    body?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | CommentTranslation$authorArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentTranslation"]>

  export type CommentTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    userId?: boolean
    name?: boolean
    body?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    author?: boolean | CommentTranslation$authorArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }


  export type $CommentTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CommentTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      userId: string | null
      name: string | null
      body: string
      commentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commentTranslation"]>
    composites: {}
  }


  type CommentTranslationGetPayload<S extends boolean | null | undefined | CommentTranslationDefaultArgs> = $Result.GetResult<Prisma.$CommentTranslationPayload, S>

  type CommentTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentTranslationFindManyArgs, 'select' | 'include'> & {
      select?: CommentTranslationCountAggregateInputType | true
    }

  export interface CommentTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentTranslation'], meta: { name: 'CommentTranslation' } }
    /**
     * Find zero or one CommentTranslation that matches the filter.
     * @param {CommentTranslationFindUniqueArgs} args - Arguments to find a CommentTranslation
     * @example
     * // Get one CommentTranslation
     * const commentTranslation = await prisma.commentTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommentTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentTranslationFindUniqueOrThrowArgs} args - Arguments to find a CommentTranslation
     * @example
     * // Get one CommentTranslation
     * const commentTranslation = await prisma.commentTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommentTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationFindFirstArgs} args - Arguments to find a CommentTranslation
     * @example
     * // Get one CommentTranslation
     * const commentTranslation = await prisma.commentTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommentTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationFindFirstOrThrowArgs} args - Arguments to find a CommentTranslation
     * @example
     * // Get one CommentTranslation
     * const commentTranslation = await prisma.commentTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommentTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentTranslations
     * const commentTranslations = await prisma.commentTranslation.findMany()
     * 
     * // Get first 10 CommentTranslations
     * const commentTranslations = await prisma.commentTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentTranslationWithIdOnly = await prisma.commentTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommentTranslation.
     * @param {CommentTranslationCreateArgs} args - Arguments to create a CommentTranslation.
     * @example
     * // Create one CommentTranslation
     * const CommentTranslation = await prisma.commentTranslation.create({
     *   data: {
     *     // ... data to create a CommentTranslation
     *   }
     * })
     * 
    **/
    create<T extends CommentTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentTranslationCreateArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommentTranslations.
     *     @param {CommentTranslationCreateManyArgs} args - Arguments to create many CommentTranslations.
     *     @example
     *     // Create many CommentTranslations
     *     const commentTranslation = await prisma.commentTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommentTranslation.
     * @param {CommentTranslationDeleteArgs} args - Arguments to delete one CommentTranslation.
     * @example
     * // Delete one CommentTranslation
     * const CommentTranslation = await prisma.commentTranslation.delete({
     *   where: {
     *     // ... filter to delete one CommentTranslation
     *   }
     * })
     * 
    **/
    delete<T extends CommentTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentTranslationDeleteArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommentTranslation.
     * @param {CommentTranslationUpdateArgs} args - Arguments to update one CommentTranslation.
     * @example
     * // Update one CommentTranslation
     * const commentTranslation = await prisma.commentTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentTranslationUpdateArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommentTranslations.
     * @param {CommentTranslationDeleteManyArgs} args - Arguments to filter CommentTranslations to delete.
     * @example
     * // Delete a few CommentTranslations
     * const { count } = await prisma.commentTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentTranslations
     * const commentTranslation = await prisma.commentTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentTranslation.
     * @param {CommentTranslationUpsertArgs} args - Arguments to update or create a CommentTranslation.
     * @example
     * // Update or create a CommentTranslation
     * const commentTranslation = await prisma.commentTranslation.upsert({
     *   create: {
     *     // ... data to create a CommentTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends CommentTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentTranslationUpsertArgs<ExtArgs>>
    ): Prisma__CommentTranslationClient<$Result.GetResult<Prisma.$CommentTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommentTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationCountArgs} args - Arguments to filter CommentTranslations to count.
     * @example
     * // Count the number of CommentTranslations
     * const count = await prisma.commentTranslation.count({
     *   where: {
     *     // ... the filter for the CommentTranslations we want to count
     *   }
     * })
    **/
    count<T extends CommentTranslationCountArgs>(
      args?: Subset<T, CommentTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentTranslationAggregateArgs>(args: Subset<T, CommentTranslationAggregateArgs>): Prisma.PrismaPromise<GetCommentTranslationAggregateType<T>>

    /**
     * Group by CommentTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentTranslationGroupByArgs['orderBy'] }
        : { orderBy?: CommentTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentTranslation model
   */
  readonly fields: CommentTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    author<T extends CommentTranslation$authorArgs<ExtArgs> = {}>(args?: Subset<T, CommentTranslation$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommentTranslation model
   */ 
  interface CommentTranslationFieldRefs {
    readonly id: FieldRef<"CommentTranslation", 'String'>
    readonly lang: FieldRef<"CommentTranslation", 'String'>
    readonly userId: FieldRef<"CommentTranslation", 'String'>
    readonly name: FieldRef<"CommentTranslation", 'String'>
    readonly body: FieldRef<"CommentTranslation", 'String'>
    readonly commentId: FieldRef<"CommentTranslation", 'String'>
    readonly createdAt: FieldRef<"CommentTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"CommentTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CommentTranslation findUnique
   */
  export type CommentTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CommentTranslation to fetch.
     */
    where: CommentTranslationWhereUniqueInput
  }


  /**
   * CommentTranslation findUniqueOrThrow
   */
  export type CommentTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CommentTranslation to fetch.
     */
    where: CommentTranslationWhereUniqueInput
  }


  /**
   * CommentTranslation findFirst
   */
  export type CommentTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CommentTranslation to fetch.
     */
    where?: CommentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentTranslations to fetch.
     */
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentTranslations.
     */
    cursor?: CommentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentTranslations.
     */
    distinct?: CommentTranslationScalarFieldEnum | CommentTranslationScalarFieldEnum[]
  }


  /**
   * CommentTranslation findFirstOrThrow
   */
  export type CommentTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CommentTranslation to fetch.
     */
    where?: CommentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentTranslations to fetch.
     */
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentTranslations.
     */
    cursor?: CommentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentTranslations.
     */
    distinct?: CommentTranslationScalarFieldEnum | CommentTranslationScalarFieldEnum[]
  }


  /**
   * CommentTranslation findMany
   */
  export type CommentTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CommentTranslations to fetch.
     */
    where?: CommentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentTranslations to fetch.
     */
    orderBy?: CommentTranslationOrderByWithRelationInput | CommentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentTranslations.
     */
    cursor?: CommentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentTranslations.
     */
    skip?: number
    distinct?: CommentTranslationScalarFieldEnum | CommentTranslationScalarFieldEnum[]
  }


  /**
   * CommentTranslation create
   */
  export type CommentTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentTranslation.
     */
    data: XOR<CommentTranslationCreateInput, CommentTranslationUncheckedCreateInput>
  }


  /**
   * CommentTranslation createMany
   */
  export type CommentTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentTranslations.
     */
    data: CommentTranslationCreateManyInput | CommentTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CommentTranslation update
   */
  export type CommentTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentTranslation.
     */
    data: XOR<CommentTranslationUpdateInput, CommentTranslationUncheckedUpdateInput>
    /**
     * Choose, which CommentTranslation to update.
     */
    where: CommentTranslationWhereUniqueInput
  }


  /**
   * CommentTranslation updateMany
   */
  export type CommentTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentTranslations.
     */
    data: XOR<CommentTranslationUpdateManyMutationInput, CommentTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CommentTranslations to update
     */
    where?: CommentTranslationWhereInput
  }


  /**
   * CommentTranslation upsert
   */
  export type CommentTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentTranslation to update in case it exists.
     */
    where: CommentTranslationWhereUniqueInput
    /**
     * In case the CommentTranslation found by the `where` argument doesn't exist, create a new CommentTranslation with this data.
     */
    create: XOR<CommentTranslationCreateInput, CommentTranslationUncheckedCreateInput>
    /**
     * In case the CommentTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentTranslationUpdateInput, CommentTranslationUncheckedUpdateInput>
  }


  /**
   * CommentTranslation delete
   */
  export type CommentTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
    /**
     * Filter which CommentTranslation to delete.
     */
    where: CommentTranslationWhereUniqueInput
  }


  /**
   * CommentTranslation deleteMany
   */
  export type CommentTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentTranslations to delete
     */
    where?: CommentTranslationWhereInput
  }


  /**
   * CommentTranslation.author
   */
  export type CommentTranslation$authorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * CommentTranslation without action
   */
  export type CommentTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentTranslation
     */
    select?: CommentTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    type: string | null
    pageId: string | null
    articleId: string | null
    categoryServiceId: string | null
    serviceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    type: string | null
    pageId: string | null
    articleId: string | null
    categoryServiceId: string | null
    serviceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    type: number
    content: number
    pageId: number
    articleId: number
    categoryServiceId: number
    serviceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    id?: true
    type?: true
    pageId?: true
    articleId?: true
    categoryServiceId?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    type?: true
    pageId?: true
    articleId?: true
    categoryServiceId?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    pageId?: true
    articleId?: true
    categoryServiceId?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    type: string | null
    content: JsonValue | null
    pageId: string | null
    articleId: string | null
    categoryServiceId: string | null
    serviceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    pageId?: boolean
    articleId?: boolean
    categoryServiceId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Page?: boolean | Block$PageArgs<ExtArgs>
    article?: boolean | Block$articleArgs<ExtArgs>
    categoryService?: boolean | Block$categoryServiceArgs<ExtArgs>
    service?: boolean | Block$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    pageId?: boolean
    articleId?: boolean
    categoryServiceId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Page?: boolean | Block$PageArgs<ExtArgs>
    article?: boolean | Block$articleArgs<ExtArgs>
    categoryService?: boolean | Block$categoryServiceArgs<ExtArgs>
    service?: boolean | Block$serviceArgs<ExtArgs>
  }


  export type $BlockPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      Page: Prisma.$PageTranslationPayload<ExtArgs> | null
      article: Prisma.$ArticleTranslationPayload<ExtArgs> | null
      categoryService: Prisma.$CategoryServiceTranslationPayload<ExtArgs> | null
      service: Prisma.$ServiceTranslationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      type: string | null
      content: Prisma.JsonValue | null
      pageId: string | null
      articleId: string | null
      categoryServiceId: string | null
      serviceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }


  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BlockFindManyArgs, 'select' | 'include'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlockFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Block that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlockFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlockFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
    **/
    create<T extends BlockCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlockCreateArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Blocks.
     *     @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     *     @example
     *     // Create many Blocks
     *     const block = await prisma.block.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlockCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
    **/
    delete<T extends BlockDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlockUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlockDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlockUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
    **/
    upsert<T extends BlockUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>
    ): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Page<T extends Block$PageArgs<ExtArgs> = {}>(args?: Subset<T, Block$PageArgs<ExtArgs>>): Prisma__PageTranslationClient<$Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    article<T extends Block$articleArgs<ExtArgs> = {}>(args?: Subset<T, Block$articleArgs<ExtArgs>>): Prisma__ArticleTranslationClient<$Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    categoryService<T extends Block$categoryServiceArgs<ExtArgs> = {}>(args?: Subset<T, Block$categoryServiceArgs<ExtArgs>>): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    service<T extends Block$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Block$serviceArgs<ExtArgs>>): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Block model
   */ 
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly type: FieldRef<"Block", 'String'>
    readonly content: FieldRef<"Block", 'Json'>
    readonly pageId: FieldRef<"Block", 'String'>
    readonly articleId: FieldRef<"Block", 'String'>
    readonly categoryServiceId: FieldRef<"Block", 'String'>
    readonly serviceId: FieldRef<"Block", 'String'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
    readonly updatedAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }


  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }


  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }


  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }


  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
  }


  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }


  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }


  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
  }


  /**
   * Block.Page
   */
  export type Block$PageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PageTranslationInclude<ExtArgs> | null
    where?: PageTranslationWhereInput
  }


  /**
   * Block.article
   */
  export type Block$articleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    where?: ArticleTranslationWhereInput
  }


  /**
   * Block.categoryService
   */
  export type Block$categoryServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    where?: CategoryServiceTranslationWhereInput
  }


  /**
   * Block.service
   */
  export type Block$serviceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    where?: ServiceTranslationWhereInput
  }


  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
  }



  /**
   * Model CategoryService
   */

  export type AggregateCategoryService = {
    _count: CategoryServiceCountAggregateOutputType | null
    _min: CategoryServiceMinAggregateOutputType | null
    _max: CategoryServiceMaxAggregateOutputType | null
  }

  export type CategoryServiceMinAggregateOutputType = {
    id: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryServiceMaxAggregateOutputType = {
    id: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryServiceCountAggregateOutputType = {
    id: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryServiceMinAggregateInputType = {
    id?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryServiceMaxAggregateInputType = {
    id?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryServiceCountAggregateInputType = {
    id?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryService to aggregate.
     */
    where?: CategoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServices to fetch.
     */
    orderBy?: CategoryServiceOrderByWithRelationInput | CategoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryServices
    **/
    _count?: true | CategoryServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryServiceMaxAggregateInputType
  }

  export type GetCategoryServiceAggregateType<T extends CategoryServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryService[P]>
      : GetScalarType<T[P], AggregateCategoryService[P]>
  }




  export type CategoryServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryServiceWhereInput
    orderBy?: CategoryServiceOrderByWithAggregationInput | CategoryServiceOrderByWithAggregationInput[]
    by: CategoryServiceScalarFieldEnum[] | CategoryServiceScalarFieldEnum
    having?: CategoryServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryServiceCountAggregateInputType | true
    _min?: CategoryServiceMinAggregateInputType
    _max?: CategoryServiceMaxAggregateInputType
  }

  export type CategoryServiceGroupByOutputType = {
    id: string
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryServiceCountAggregateOutputType | null
    _min: CategoryServiceMinAggregateOutputType | null
    _max: CategoryServiceMaxAggregateOutputType | null
  }

  type GetCategoryServiceGroupByPayload<T extends CategoryServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryServiceGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryServiceGroupByOutputType[P]>
        }
      >
    >


  export type CategoryServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | CategoryService$servicesArgs<ExtArgs>
    translations?: boolean | CategoryService$translationsArgs<ExtArgs>
    _count?: boolean | CategoryServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryService"]>

  export type CategoryServiceSelectScalar = {
    id?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | CategoryService$servicesArgs<ExtArgs>
    translations?: boolean | CategoryService$translationsArgs<ExtArgs>
    _count?: boolean | CategoryServiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CategoryService"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      translations: Prisma.$CategoryServiceTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryService"]>
    composites: {}
  }


  type CategoryServiceGetPayload<S extends boolean | null | undefined | CategoryServiceDefaultArgs> = $Result.GetResult<Prisma.$CategoryServicePayload, S>

  type CategoryServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryServiceFindManyArgs, 'select' | 'include'> & {
      select?: CategoryServiceCountAggregateInputType | true
    }

  export interface CategoryServiceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryService'], meta: { name: 'CategoryService' } }
    /**
     * Find zero or one CategoryService that matches the filter.
     * @param {CategoryServiceFindUniqueArgs} args - Arguments to find a CategoryService
     * @example
     * // Get one CategoryService
     * const categoryService = await prisma.categoryService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryServiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CategoryService that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryServiceFindUniqueOrThrowArgs} args - Arguments to find a CategoryService
     * @example
     * // Get one CategoryService
     * const categoryService = await prisma.categoryService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CategoryService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceFindFirstArgs} args - Arguments to find a CategoryService
     * @example
     * // Get one CategoryService
     * const categoryService = await prisma.categoryService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryServiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CategoryService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceFindFirstOrThrowArgs} args - Arguments to find a CategoryService
     * @example
     * // Get one CategoryService
     * const categoryService = await prisma.categoryService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CategoryServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryServices
     * const categoryServices = await prisma.categoryService.findMany()
     * 
     * // Get first 10 CategoryServices
     * const categoryServices = await prisma.categoryService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryServiceWithIdOnly = await prisma.categoryService.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CategoryService.
     * @param {CategoryServiceCreateArgs} args - Arguments to create a CategoryService.
     * @example
     * // Create one CategoryService
     * const CategoryService = await prisma.categoryService.create({
     *   data: {
     *     // ... data to create a CategoryService
     *   }
     * })
     * 
    **/
    create<T extends CategoryServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceCreateArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CategoryServices.
     *     @param {CategoryServiceCreateManyArgs} args - Arguments to create many CategoryServices.
     *     @example
     *     // Create many CategoryServices
     *     const categoryService = await prisma.categoryService.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryService.
     * @param {CategoryServiceDeleteArgs} args - Arguments to delete one CategoryService.
     * @example
     * // Delete one CategoryService
     * const CategoryService = await prisma.categoryService.delete({
     *   where: {
     *     // ... filter to delete one CategoryService
     *   }
     * })
     * 
    **/
    delete<T extends CategoryServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceDeleteArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CategoryService.
     * @param {CategoryServiceUpdateArgs} args - Arguments to update one CategoryService.
     * @example
     * // Update one CategoryService
     * const categoryService = await prisma.categoryService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceUpdateArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CategoryServices.
     * @param {CategoryServiceDeleteManyArgs} args - Arguments to filter CategoryServices to delete.
     * @example
     * // Delete a few CategoryServices
     * const { count } = await prisma.categoryService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryServices
     * const categoryService = await prisma.categoryService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryService.
     * @param {CategoryServiceUpsertArgs} args - Arguments to update or create a CategoryService.
     * @example
     * // Update or create a CategoryService
     * const categoryService = await prisma.categoryService.upsert({
     *   create: {
     *     // ... data to create a CategoryService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryService we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceUpsertArgs<ExtArgs>>
    ): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CategoryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceCountArgs} args - Arguments to filter CategoryServices to count.
     * @example
     * // Count the number of CategoryServices
     * const count = await prisma.categoryService.count({
     *   where: {
     *     // ... the filter for the CategoryServices we want to count
     *   }
     * })
    **/
    count<T extends CategoryServiceCountArgs>(
      args?: Subset<T, CategoryServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryServiceAggregateArgs>(args: Subset<T, CategoryServiceAggregateArgs>): Prisma.PrismaPromise<GetCategoryServiceAggregateType<T>>

    /**
     * Group by CategoryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryServiceGroupByArgs['orderBy'] }
        : { orderBy?: CategoryServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryService model
   */
  readonly fields: CategoryServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    services<T extends CategoryService$servicesArgs<ExtArgs> = {}>(args?: Subset<T, CategoryService$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany'> | Null>;

    translations<T extends CategoryService$translationsArgs<ExtArgs> = {}>(args?: Subset<T, CategoryService$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CategoryService model
   */ 
  interface CategoryServiceFieldRefs {
    readonly id: FieldRef<"CategoryService", 'String'>
    readonly published: FieldRef<"CategoryService", 'Boolean'>
    readonly createdAt: FieldRef<"CategoryService", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryService", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CategoryService findUnique
   */
  export type CategoryServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which CategoryService to fetch.
     */
    where: CategoryServiceWhereUniqueInput
  }


  /**
   * CategoryService findUniqueOrThrow
   */
  export type CategoryServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which CategoryService to fetch.
     */
    where: CategoryServiceWhereUniqueInput
  }


  /**
   * CategoryService findFirst
   */
  export type CategoryServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which CategoryService to fetch.
     */
    where?: CategoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServices to fetch.
     */
    orderBy?: CategoryServiceOrderByWithRelationInput | CategoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryServices.
     */
    cursor?: CategoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryServices.
     */
    distinct?: CategoryServiceScalarFieldEnum | CategoryServiceScalarFieldEnum[]
  }


  /**
   * CategoryService findFirstOrThrow
   */
  export type CategoryServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which CategoryService to fetch.
     */
    where?: CategoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServices to fetch.
     */
    orderBy?: CategoryServiceOrderByWithRelationInput | CategoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryServices.
     */
    cursor?: CategoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryServices.
     */
    distinct?: CategoryServiceScalarFieldEnum | CategoryServiceScalarFieldEnum[]
  }


  /**
   * CategoryService findMany
   */
  export type CategoryServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which CategoryServices to fetch.
     */
    where?: CategoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServices to fetch.
     */
    orderBy?: CategoryServiceOrderByWithRelationInput | CategoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryServices.
     */
    cursor?: CategoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServices.
     */
    skip?: number
    distinct?: CategoryServiceScalarFieldEnum | CategoryServiceScalarFieldEnum[]
  }


  /**
   * CategoryService create
   */
  export type CategoryServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryService.
     */
    data: XOR<CategoryServiceCreateInput, CategoryServiceUncheckedCreateInput>
  }


  /**
   * CategoryService createMany
   */
  export type CategoryServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryServices.
     */
    data: CategoryServiceCreateManyInput | CategoryServiceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CategoryService update
   */
  export type CategoryServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryService.
     */
    data: XOR<CategoryServiceUpdateInput, CategoryServiceUncheckedUpdateInput>
    /**
     * Choose, which CategoryService to update.
     */
    where: CategoryServiceWhereUniqueInput
  }


  /**
   * CategoryService updateMany
   */
  export type CategoryServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryServices.
     */
    data: XOR<CategoryServiceUpdateManyMutationInput, CategoryServiceUncheckedUpdateManyInput>
    /**
     * Filter which CategoryServices to update
     */
    where?: CategoryServiceWhereInput
  }


  /**
   * CategoryService upsert
   */
  export type CategoryServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryService to update in case it exists.
     */
    where: CategoryServiceWhereUniqueInput
    /**
     * In case the CategoryService found by the `where` argument doesn't exist, create a new CategoryService with this data.
     */
    create: XOR<CategoryServiceCreateInput, CategoryServiceUncheckedCreateInput>
    /**
     * In case the CategoryService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryServiceUpdateInput, CategoryServiceUncheckedUpdateInput>
  }


  /**
   * CategoryService delete
   */
  export type CategoryServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
    /**
     * Filter which CategoryService to delete.
     */
    where: CategoryServiceWhereUniqueInput
  }


  /**
   * CategoryService deleteMany
   */
  export type CategoryServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryServices to delete
     */
    where?: CategoryServiceWhereInput
  }


  /**
   * CategoryService.services
   */
  export type CategoryService$servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * CategoryService.translations
   */
  export type CategoryService$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    where?: CategoryServiceTranslationWhereInput
    orderBy?: CategoryServiceTranslationOrderByWithRelationInput | CategoryServiceTranslationOrderByWithRelationInput[]
    cursor?: CategoryServiceTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryServiceTranslationScalarFieldEnum | CategoryServiceTranslationScalarFieldEnum[]
  }


  /**
   * CategoryService without action
   */
  export type CategoryServiceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryService
     */
    select?: CategoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceInclude<ExtArgs> | null
  }



  /**
   * Model CategoryServiceTranslation
   */

  export type AggregateCategoryServiceTranslation = {
    _count: CategoryServiceTranslationCountAggregateOutputType | null
    _min: CategoryServiceTranslationMinAggregateOutputType | null
    _max: CategoryServiceTranslationMaxAggregateOutputType | null
  }

  export type CategoryServiceTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    descriprion: string | null
    categoryServiceId: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryServiceTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    descriprion: string | null
    categoryServiceId: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryServiceTranslationCountAggregateOutputType = {
    id: number
    lang: number
    name: number
    descriprion: number
    images: number
    categoryServiceId: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryServiceTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    descriprion?: true
    categoryServiceId?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryServiceTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    descriprion?: true
    categoryServiceId?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryServiceTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    descriprion?: true
    images?: true
    categoryServiceId?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryServiceTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryServiceTranslation to aggregate.
     */
    where?: CategoryServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServiceTranslations to fetch.
     */
    orderBy?: CategoryServiceTranslationOrderByWithRelationInput | CategoryServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServiceTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryServiceTranslations
    **/
    _count?: true | CategoryServiceTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryServiceTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryServiceTranslationMaxAggregateInputType
  }

  export type GetCategoryServiceTranslationAggregateType<T extends CategoryServiceTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryServiceTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryServiceTranslation[P]>
      : GetScalarType<T[P], AggregateCategoryServiceTranslation[P]>
  }




  export type CategoryServiceTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryServiceTranslationWhereInput
    orderBy?: CategoryServiceTranslationOrderByWithAggregationInput | CategoryServiceTranslationOrderByWithAggregationInput[]
    by: CategoryServiceTranslationScalarFieldEnum[] | CategoryServiceTranslationScalarFieldEnum
    having?: CategoryServiceTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryServiceTranslationCountAggregateInputType | true
    _min?: CategoryServiceTranslationMinAggregateInputType
    _max?: CategoryServiceTranslationMaxAggregateInputType
  }

  export type CategoryServiceTranslationGroupByOutputType = {
    id: string
    lang: string
    name: string
    descriprion: string | null
    images: string[]
    categoryServiceId: string
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryServiceTranslationCountAggregateOutputType | null
    _min: CategoryServiceTranslationMinAggregateOutputType | null
    _max: CategoryServiceTranslationMaxAggregateOutputType | null
  }

  type GetCategoryServiceTranslationGroupByPayload<T extends CategoryServiceTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryServiceTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryServiceTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryServiceTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryServiceTranslationGroupByOutputType[P]>
        }
      >
    >


  export type CategoryServiceTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    name?: boolean
    descriprion?: boolean
    images?: boolean
    categoryServiceId?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    categoryService?: boolean | CategoryServiceDefaultArgs<ExtArgs>
    blocks?: boolean | CategoryServiceTranslation$blocksArgs<ExtArgs>
    _count?: boolean | CategoryServiceTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryServiceTranslation"]>

  export type CategoryServiceTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    name?: boolean
    descriprion?: boolean
    images?: boolean
    categoryServiceId?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryServiceTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    categoryService?: boolean | CategoryServiceDefaultArgs<ExtArgs>
    blocks?: boolean | CategoryServiceTranslation$blocksArgs<ExtArgs>
    _count?: boolean | CategoryServiceTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryServiceTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CategoryServiceTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      categoryService: Prisma.$CategoryServicePayload<ExtArgs>
      blocks: Prisma.$BlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      name: string
      descriprion: string | null
      images: string[]
      categoryServiceId: string
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryServiceTranslation"]>
    composites: {}
  }


  type CategoryServiceTranslationGetPayload<S extends boolean | null | undefined | CategoryServiceTranslationDefaultArgs> = $Result.GetResult<Prisma.$CategoryServiceTranslationPayload, S>

  type CategoryServiceTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryServiceTranslationFindManyArgs, 'select' | 'include'> & {
      select?: CategoryServiceTranslationCountAggregateInputType | true
    }

  export interface CategoryServiceTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryServiceTranslation'], meta: { name: 'CategoryServiceTranslation' } }
    /**
     * Find zero or one CategoryServiceTranslation that matches the filter.
     * @param {CategoryServiceTranslationFindUniqueArgs} args - Arguments to find a CategoryServiceTranslation
     * @example
     * // Get one CategoryServiceTranslation
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryServiceTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CategoryServiceTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryServiceTranslationFindUniqueOrThrowArgs} args - Arguments to find a CategoryServiceTranslation
     * @example
     * // Get one CategoryServiceTranslation
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryServiceTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CategoryServiceTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationFindFirstArgs} args - Arguments to find a CategoryServiceTranslation
     * @example
     * // Get one CategoryServiceTranslation
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryServiceTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CategoryServiceTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationFindFirstOrThrowArgs} args - Arguments to find a CategoryServiceTranslation
     * @example
     * // Get one CategoryServiceTranslation
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryServiceTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CategoryServiceTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryServiceTranslations
     * const categoryServiceTranslations = await prisma.categoryServiceTranslation.findMany()
     * 
     * // Get first 10 CategoryServiceTranslations
     * const categoryServiceTranslations = await prisma.categoryServiceTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryServiceTranslationWithIdOnly = await prisma.categoryServiceTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryServiceTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CategoryServiceTranslation.
     * @param {CategoryServiceTranslationCreateArgs} args - Arguments to create a CategoryServiceTranslation.
     * @example
     * // Create one CategoryServiceTranslation
     * const CategoryServiceTranslation = await prisma.categoryServiceTranslation.create({
     *   data: {
     *     // ... data to create a CategoryServiceTranslation
     *   }
     * })
     * 
    **/
    create<T extends CategoryServiceTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceTranslationCreateArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CategoryServiceTranslations.
     *     @param {CategoryServiceTranslationCreateManyArgs} args - Arguments to create many CategoryServiceTranslations.
     *     @example
     *     // Create many CategoryServiceTranslations
     *     const categoryServiceTranslation = await prisma.categoryServiceTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryServiceTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryServiceTranslation.
     * @param {CategoryServiceTranslationDeleteArgs} args - Arguments to delete one CategoryServiceTranslation.
     * @example
     * // Delete one CategoryServiceTranslation
     * const CategoryServiceTranslation = await prisma.categoryServiceTranslation.delete({
     *   where: {
     *     // ... filter to delete one CategoryServiceTranslation
     *   }
     * })
     * 
    **/
    delete<T extends CategoryServiceTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceTranslationDeleteArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CategoryServiceTranslation.
     * @param {CategoryServiceTranslationUpdateArgs} args - Arguments to update one CategoryServiceTranslation.
     * @example
     * // Update one CategoryServiceTranslation
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryServiceTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceTranslationUpdateArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CategoryServiceTranslations.
     * @param {CategoryServiceTranslationDeleteManyArgs} args - Arguments to filter CategoryServiceTranslations to delete.
     * @example
     * // Delete a few CategoryServiceTranslations
     * const { count } = await prisma.categoryServiceTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryServiceTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryServiceTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryServiceTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryServiceTranslations
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryServiceTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryServiceTranslation.
     * @param {CategoryServiceTranslationUpsertArgs} args - Arguments to update or create a CategoryServiceTranslation.
     * @example
     * // Update or create a CategoryServiceTranslation
     * const categoryServiceTranslation = await prisma.categoryServiceTranslation.upsert({
     *   create: {
     *     // ... data to create a CategoryServiceTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryServiceTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryServiceTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryServiceTranslationUpsertArgs<ExtArgs>>
    ): Prisma__CategoryServiceTranslationClient<$Result.GetResult<Prisma.$CategoryServiceTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CategoryServiceTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationCountArgs} args - Arguments to filter CategoryServiceTranslations to count.
     * @example
     * // Count the number of CategoryServiceTranslations
     * const count = await prisma.categoryServiceTranslation.count({
     *   where: {
     *     // ... the filter for the CategoryServiceTranslations we want to count
     *   }
     * })
    **/
    count<T extends CategoryServiceTranslationCountArgs>(
      args?: Subset<T, CategoryServiceTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryServiceTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryServiceTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryServiceTranslationAggregateArgs>(args: Subset<T, CategoryServiceTranslationAggregateArgs>): Prisma.PrismaPromise<GetCategoryServiceTranslationAggregateType<T>>

    /**
     * Group by CategoryServiceTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryServiceTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryServiceTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryServiceTranslationGroupByArgs['orderBy'] }
        : { orderBy?: CategoryServiceTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryServiceTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryServiceTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryServiceTranslation model
   */
  readonly fields: CategoryServiceTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryServiceTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryServiceTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    categoryService<T extends CategoryServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryServiceDefaultArgs<ExtArgs>>): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    blocks<T extends CategoryServiceTranslation$blocksArgs<ExtArgs> = {}>(args?: Subset<T, CategoryServiceTranslation$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CategoryServiceTranslation model
   */ 
  interface CategoryServiceTranslationFieldRefs {
    readonly id: FieldRef<"CategoryServiceTranslation", 'String'>
    readonly lang: FieldRef<"CategoryServiceTranslation", 'String'>
    readonly name: FieldRef<"CategoryServiceTranslation", 'String'>
    readonly descriprion: FieldRef<"CategoryServiceTranslation", 'String'>
    readonly images: FieldRef<"CategoryServiceTranslation", 'String[]'>
    readonly categoryServiceId: FieldRef<"CategoryServiceTranslation", 'String'>
    readonly published: FieldRef<"CategoryServiceTranslation", 'Boolean'>
    readonly createdAt: FieldRef<"CategoryServiceTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryServiceTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CategoryServiceTranslation findUnique
   */
  export type CategoryServiceTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryServiceTranslation to fetch.
     */
    where: CategoryServiceTranslationWhereUniqueInput
  }


  /**
   * CategoryServiceTranslation findUniqueOrThrow
   */
  export type CategoryServiceTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryServiceTranslation to fetch.
     */
    where: CategoryServiceTranslationWhereUniqueInput
  }


  /**
   * CategoryServiceTranslation findFirst
   */
  export type CategoryServiceTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryServiceTranslation to fetch.
     */
    where?: CategoryServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServiceTranslations to fetch.
     */
    orderBy?: CategoryServiceTranslationOrderByWithRelationInput | CategoryServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryServiceTranslations.
     */
    cursor?: CategoryServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServiceTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryServiceTranslations.
     */
    distinct?: CategoryServiceTranslationScalarFieldEnum | CategoryServiceTranslationScalarFieldEnum[]
  }


  /**
   * CategoryServiceTranslation findFirstOrThrow
   */
  export type CategoryServiceTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryServiceTranslation to fetch.
     */
    where?: CategoryServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServiceTranslations to fetch.
     */
    orderBy?: CategoryServiceTranslationOrderByWithRelationInput | CategoryServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryServiceTranslations.
     */
    cursor?: CategoryServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServiceTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryServiceTranslations.
     */
    distinct?: CategoryServiceTranslationScalarFieldEnum | CategoryServiceTranslationScalarFieldEnum[]
  }


  /**
   * CategoryServiceTranslation findMany
   */
  export type CategoryServiceTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryServiceTranslations to fetch.
     */
    where?: CategoryServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryServiceTranslations to fetch.
     */
    orderBy?: CategoryServiceTranslationOrderByWithRelationInput | CategoryServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryServiceTranslations.
     */
    cursor?: CategoryServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryServiceTranslations.
     */
    skip?: number
    distinct?: CategoryServiceTranslationScalarFieldEnum | CategoryServiceTranslationScalarFieldEnum[]
  }


  /**
   * CategoryServiceTranslation create
   */
  export type CategoryServiceTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryServiceTranslation.
     */
    data: XOR<CategoryServiceTranslationCreateInput, CategoryServiceTranslationUncheckedCreateInput>
  }


  /**
   * CategoryServiceTranslation createMany
   */
  export type CategoryServiceTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryServiceTranslations.
     */
    data: CategoryServiceTranslationCreateManyInput | CategoryServiceTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CategoryServiceTranslation update
   */
  export type CategoryServiceTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryServiceTranslation.
     */
    data: XOR<CategoryServiceTranslationUpdateInput, CategoryServiceTranslationUncheckedUpdateInput>
    /**
     * Choose, which CategoryServiceTranslation to update.
     */
    where: CategoryServiceTranslationWhereUniqueInput
  }


  /**
   * CategoryServiceTranslation updateMany
   */
  export type CategoryServiceTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryServiceTranslations.
     */
    data: XOR<CategoryServiceTranslationUpdateManyMutationInput, CategoryServiceTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CategoryServiceTranslations to update
     */
    where?: CategoryServiceTranslationWhereInput
  }


  /**
   * CategoryServiceTranslation upsert
   */
  export type CategoryServiceTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryServiceTranslation to update in case it exists.
     */
    where: CategoryServiceTranslationWhereUniqueInput
    /**
     * In case the CategoryServiceTranslation found by the `where` argument doesn't exist, create a new CategoryServiceTranslation with this data.
     */
    create: XOR<CategoryServiceTranslationCreateInput, CategoryServiceTranslationUncheckedCreateInput>
    /**
     * In case the CategoryServiceTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryServiceTranslationUpdateInput, CategoryServiceTranslationUncheckedUpdateInput>
  }


  /**
   * CategoryServiceTranslation delete
   */
  export type CategoryServiceTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter which CategoryServiceTranslation to delete.
     */
    where: CategoryServiceTranslationWhereUniqueInput
  }


  /**
   * CategoryServiceTranslation deleteMany
   */
  export type CategoryServiceTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryServiceTranslations to delete
     */
    where?: CategoryServiceTranslationWhereInput
  }


  /**
   * CategoryServiceTranslation.blocks
   */
  export type CategoryServiceTranslation$blocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * CategoryServiceTranslation without action
   */
  export type CategoryServiceTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryServiceTranslation
     */
    select?: CategoryServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryServiceTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CategoryService?: boolean | CategoryServiceDefaultArgs<ExtArgs>
    translations?: boolean | Service$translationsArgs<ExtArgs>
    orders?: boolean | Service$ordersArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    CategoryService?: boolean | CategoryServiceDefaultArgs<ExtArgs>
    translations?: boolean | Service$translationsArgs<ExtArgs>
    orders?: boolean | Service$ordersArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      CategoryService: Prisma.$CategoryServicePayload<ExtArgs>
      translations: Prisma.$ServiceTranslationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CategoryService<T extends CategoryServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryServiceDefaultArgs<ExtArgs>>): Prisma__CategoryServiceClient<$Result.GetResult<Prisma.$CategoryServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    translations<T extends Service$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Service$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Service$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Service$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly categoryId: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.translations
   */
  export type Service$translationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    where?: ServiceTranslationWhereInput
    orderBy?: ServiceTranslationOrderByWithRelationInput | ServiceTranslationOrderByWithRelationInput[]
    cursor?: ServiceTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTranslationScalarFieldEnum | ServiceTranslationScalarFieldEnum[]
  }


  /**
   * Service.orders
   */
  export type Service$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model ServiceTranslation
   */

  export type AggregateServiceTranslation = {
    _count: ServiceTranslationCountAggregateOutputType | null
    _min: ServiceTranslationMinAggregateOutputType | null
    _max: ServiceTranslationMaxAggregateOutputType | null
  }

  export type ServiceTranslationMinAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    description: string | null
    serviceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTranslationMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    description: string | null
    serviceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTranslationCountAggregateOutputType = {
    id: number
    lang: number
    name: number
    description: number
    serviceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTranslationMinAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    description?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    description?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTranslationCountAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    description?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTranslationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTranslation to aggregate.
     */
    where?: ServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTranslations to fetch.
     */
    orderBy?: ServiceTranslationOrderByWithRelationInput | ServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTranslations
    **/
    _count?: true | ServiceTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTranslationMaxAggregateInputType
  }

  export type GetServiceTranslationAggregateType<T extends ServiceTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTranslation[P]>
      : GetScalarType<T[P], AggregateServiceTranslation[P]>
  }




  export type ServiceTranslationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTranslationWhereInput
    orderBy?: ServiceTranslationOrderByWithAggregationInput | ServiceTranslationOrderByWithAggregationInput[]
    by: ServiceTranslationScalarFieldEnum[] | ServiceTranslationScalarFieldEnum
    having?: ServiceTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTranslationCountAggregateInputType | true
    _min?: ServiceTranslationMinAggregateInputType
    _max?: ServiceTranslationMaxAggregateInputType
  }

  export type ServiceTranslationGroupByOutputType = {
    id: string
    lang: string
    name: string
    description: string | null
    serviceId: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceTranslationCountAggregateOutputType | null
    _min: ServiceTranslationMinAggregateOutputType | null
    _max: ServiceTranslationMaxAggregateOutputType | null
  }

  type GetServiceTranslationGroupByPayload<T extends ServiceTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTranslationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    name?: boolean
    description?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    blocks?: boolean | ServiceTranslation$blocksArgs<ExtArgs>
    _count?: boolean | ServiceTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTranslation"]>

  export type ServiceTranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    name?: boolean
    description?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTranslationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    blocks?: boolean | ServiceTranslation$blocksArgs<ExtArgs>
    _count?: boolean | ServiceTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ServiceTranslationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ServiceTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      blocks: Prisma.$BlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      lang: string
      name: string
      description: string | null
      serviceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTranslation"]>
    composites: {}
  }


  type ServiceTranslationGetPayload<S extends boolean | null | undefined | ServiceTranslationDefaultArgs> = $Result.GetResult<Prisma.$ServiceTranslationPayload, S>

  type ServiceTranslationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceTranslationFindManyArgs, 'select' | 'include'> & {
      select?: ServiceTranslationCountAggregateInputType | true
    }

  export interface ServiceTranslationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTranslation'], meta: { name: 'ServiceTranslation' } }
    /**
     * Find zero or one ServiceTranslation that matches the filter.
     * @param {ServiceTranslationFindUniqueArgs} args - Arguments to find a ServiceTranslation
     * @example
     * // Get one ServiceTranslation
     * const serviceTranslation = await prisma.serviceTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceTranslationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ServiceTranslation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceTranslationFindUniqueOrThrowArgs} args - Arguments to find a ServiceTranslation
     * @example
     * // Get one ServiceTranslation
     * const serviceTranslation = await prisma.serviceTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceTranslationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ServiceTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationFindFirstArgs} args - Arguments to find a ServiceTranslation
     * @example
     * // Get one ServiceTranslation
     * const serviceTranslation = await prisma.serviceTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceTranslationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ServiceTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationFindFirstOrThrowArgs} args - Arguments to find a ServiceTranslation
     * @example
     * // Get one ServiceTranslation
     * const serviceTranslation = await prisma.serviceTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceTranslationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ServiceTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTranslations
     * const serviceTranslations = await prisma.serviceTranslation.findMany()
     * 
     * // Get first 10 ServiceTranslations
     * const serviceTranslations = await prisma.serviceTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTranslationWithIdOnly = await prisma.serviceTranslation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceTranslationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ServiceTranslation.
     * @param {ServiceTranslationCreateArgs} args - Arguments to create a ServiceTranslation.
     * @example
     * // Create one ServiceTranslation
     * const ServiceTranslation = await prisma.serviceTranslation.create({
     *   data: {
     *     // ... data to create a ServiceTranslation
     *   }
     * })
     * 
    **/
    create<T extends ServiceTranslationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTranslationCreateArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ServiceTranslations.
     *     @param {ServiceTranslationCreateManyArgs} args - Arguments to create many ServiceTranslations.
     *     @example
     *     // Create many ServiceTranslations
     *     const serviceTranslation = await prisma.serviceTranslation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceTranslationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceTranslation.
     * @param {ServiceTranslationDeleteArgs} args - Arguments to delete one ServiceTranslation.
     * @example
     * // Delete one ServiceTranslation
     * const ServiceTranslation = await prisma.serviceTranslation.delete({
     *   where: {
     *     // ... filter to delete one ServiceTranslation
     *   }
     * })
     * 
    **/
    delete<T extends ServiceTranslationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTranslationDeleteArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ServiceTranslation.
     * @param {ServiceTranslationUpdateArgs} args - Arguments to update one ServiceTranslation.
     * @example
     * // Update one ServiceTranslation
     * const serviceTranslation = await prisma.serviceTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceTranslationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTranslationUpdateArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ServiceTranslations.
     * @param {ServiceTranslationDeleteManyArgs} args - Arguments to filter ServiceTranslations to delete.
     * @example
     * // Delete a few ServiceTranslations
     * const { count } = await prisma.serviceTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceTranslationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTranslations
     * const serviceTranslation = await prisma.serviceTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceTranslationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceTranslation.
     * @param {ServiceTranslationUpsertArgs} args - Arguments to update or create a ServiceTranslation.
     * @example
     * // Update or create a ServiceTranslation
     * const serviceTranslation = await prisma.serviceTranslation.upsert({
     *   create: {
     *     // ... data to create a ServiceTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTranslation we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceTranslationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTranslationUpsertArgs<ExtArgs>>
    ): Prisma__ServiceTranslationClient<$Result.GetResult<Prisma.$ServiceTranslationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ServiceTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationCountArgs} args - Arguments to filter ServiceTranslations to count.
     * @example
     * // Count the number of ServiceTranslations
     * const count = await prisma.serviceTranslation.count({
     *   where: {
     *     // ... the filter for the ServiceTranslations we want to count
     *   }
     * })
    **/
    count<T extends ServiceTranslationCountArgs>(
      args?: Subset<T, ServiceTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTranslationAggregateArgs>(args: Subset<T, ServiceTranslationAggregateArgs>): Prisma.PrismaPromise<GetServiceTranslationAggregateType<T>>

    /**
     * Group by ServiceTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTranslation model
   */
  readonly fields: ServiceTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTranslationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    blocks<T extends ServiceTranslation$blocksArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTranslation$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ServiceTranslation model
   */ 
  interface ServiceTranslationFieldRefs {
    readonly id: FieldRef<"ServiceTranslation", 'String'>
    readonly lang: FieldRef<"ServiceTranslation", 'String'>
    readonly name: FieldRef<"ServiceTranslation", 'String'>
    readonly description: FieldRef<"ServiceTranslation", 'String'>
    readonly serviceId: FieldRef<"ServiceTranslation", 'String'>
    readonly createdAt: FieldRef<"ServiceTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTranslation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ServiceTranslation findUnique
   */
  export type ServiceTranslationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTranslation to fetch.
     */
    where: ServiceTranslationWhereUniqueInput
  }


  /**
   * ServiceTranslation findUniqueOrThrow
   */
  export type ServiceTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTranslation to fetch.
     */
    where: ServiceTranslationWhereUniqueInput
  }


  /**
   * ServiceTranslation findFirst
   */
  export type ServiceTranslationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTranslation to fetch.
     */
    where?: ServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTranslations to fetch.
     */
    orderBy?: ServiceTranslationOrderByWithRelationInput | ServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTranslations.
     */
    cursor?: ServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTranslations.
     */
    distinct?: ServiceTranslationScalarFieldEnum | ServiceTranslationScalarFieldEnum[]
  }


  /**
   * ServiceTranslation findFirstOrThrow
   */
  export type ServiceTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTranslation to fetch.
     */
    where?: ServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTranslations to fetch.
     */
    orderBy?: ServiceTranslationOrderByWithRelationInput | ServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTranslations.
     */
    cursor?: ServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTranslations.
     */
    distinct?: ServiceTranslationScalarFieldEnum | ServiceTranslationScalarFieldEnum[]
  }


  /**
   * ServiceTranslation findMany
   */
  export type ServiceTranslationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTranslations to fetch.
     */
    where?: ServiceTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTranslations to fetch.
     */
    orderBy?: ServiceTranslationOrderByWithRelationInput | ServiceTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTranslations.
     */
    cursor?: ServiceTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTranslations.
     */
    skip?: number
    distinct?: ServiceTranslationScalarFieldEnum | ServiceTranslationScalarFieldEnum[]
  }


  /**
   * ServiceTranslation create
   */
  export type ServiceTranslationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTranslation.
     */
    data: XOR<ServiceTranslationCreateInput, ServiceTranslationUncheckedCreateInput>
  }


  /**
   * ServiceTranslation createMany
   */
  export type ServiceTranslationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTranslations.
     */
    data: ServiceTranslationCreateManyInput | ServiceTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ServiceTranslation update
   */
  export type ServiceTranslationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTranslation.
     */
    data: XOR<ServiceTranslationUpdateInput, ServiceTranslationUncheckedUpdateInput>
    /**
     * Choose, which ServiceTranslation to update.
     */
    where: ServiceTranslationWhereUniqueInput
  }


  /**
   * ServiceTranslation updateMany
   */
  export type ServiceTranslationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTranslations.
     */
    data: XOR<ServiceTranslationUpdateManyMutationInput, ServiceTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTranslations to update
     */
    where?: ServiceTranslationWhereInput
  }


  /**
   * ServiceTranslation upsert
   */
  export type ServiceTranslationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTranslation to update in case it exists.
     */
    where: ServiceTranslationWhereUniqueInput
    /**
     * In case the ServiceTranslation found by the `where` argument doesn't exist, create a new ServiceTranslation with this data.
     */
    create: XOR<ServiceTranslationCreateInput, ServiceTranslationUncheckedCreateInput>
    /**
     * In case the ServiceTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTranslationUpdateInput, ServiceTranslationUncheckedUpdateInput>
  }


  /**
   * ServiceTranslation delete
   */
  export type ServiceTranslationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
    /**
     * Filter which ServiceTranslation to delete.
     */
    where: ServiceTranslationWhereUniqueInput
  }


  /**
   * ServiceTranslation deleteMany
   */
  export type ServiceTranslationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTranslations to delete
     */
    where?: ServiceTranslationWhereInput
  }


  /**
   * ServiceTranslation.blocks
   */
  export type ServiceTranslation$blocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }


  /**
   * ServiceTranslation without action
   */
  export type ServiceTranslationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTranslation
     */
    select?: ServiceTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTranslationInclude<ExtArgs> | null
  }



  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    studentId: string | null
    serviceId: string | null
    DescriptionOtherService: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    studentId: string | null
    serviceId: string | null
    DescriptionOtherService: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    studentId: number
    serviceId: number
    DescriptionOtherService: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    studentId?: true
    serviceId?: true
    DescriptionOtherService?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    studentId?: true
    serviceId?: true
    DescriptionOtherService?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    studentId?: true
    serviceId?: true
    DescriptionOtherService?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    phone: string | null
    studentId: string | null
    serviceId: string | null
    DescriptionOtherService: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    studentId?: boolean
    serviceId?: boolean
    DescriptionOtherService?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Order$studentArgs<ExtArgs>
    service?: boolean | Order$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    studentId?: boolean
    serviceId?: boolean
    DescriptionOtherService?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    student?: boolean | Order$studentArgs<ExtArgs>
    service?: boolean | Order$serviceArgs<ExtArgs>
  }


  export type $OrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      student: Prisma.$UserPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string | null
      email: string | null
      phone: string | null
      studentId: string | null
      serviceId: string | null
      DescriptionOtherService: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends Order$studentArgs<ExtArgs> = {}>(args?: Subset<T, Order$studentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    service<T extends Order$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Order$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly name: FieldRef<"Order", 'String'>
    readonly email: FieldRef<"Order", 'String'>
    readonly phone: FieldRef<"Order", 'String'>
    readonly studentId: FieldRef<"Order", 'String'>
    readonly serviceId: FieldRef<"Order", 'String'>
    readonly DescriptionOtherService: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order.student
   */
  export type Order$studentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Order.service
   */
  export type Order$serviceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }


  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    label: 'label',
    language: 'language',
    common: 'common'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const GlobalScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalScalarFieldEnum = (typeof GlobalScalarFieldEnum)[keyof typeof GlobalScalarFieldEnum]


  export const GlobalTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    name: 'name',
    logo: 'logo',
    favicon: 'favicon',
    images: 'images',
    description: 'description',
    globalId: 'globalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalTranslationScalarFieldEnum = (typeof GlobalTranslationScalarFieldEnum)[keyof typeof GlobalTranslationScalarFieldEnum]


  export const SocialLinkScalarFieldEnum: {
    id: 'id',
    social: 'social',
    url: 'url',
    globalId: 'globalId'
  };

  export type SocialLinkScalarFieldEnum = (typeof SocialLinkScalarFieldEnum)[keyof typeof SocialLinkScalarFieldEnum]


  export const NavbarItemScalarFieldEnum: {
    id: 'id',
    isDropdown: 'isDropdown',
    forArticle: 'forArticle',
    forPage: 'forPage',
    pageId: 'pageId',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NavbarItemScalarFieldEnum = (typeof NavbarItemScalarFieldEnum)[keyof typeof NavbarItemScalarFieldEnum]


  export const NavbarItemTranslationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lang: 'lang',
    navbarItemId: 'navbarItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NavbarItemTranslationScalarFieldEnum = (typeof NavbarItemTranslationScalarFieldEnum)[keyof typeof NavbarItemTranslationScalarFieldEnum]


  export const DropDownGroupScalarFieldEnum: {
    id: 'id',
    navItemId: 'navItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DropDownGroupScalarFieldEnum = (typeof DropDownGroupScalarFieldEnum)[keyof typeof DropDownGroupScalarFieldEnum]


  export const DropDownGroupTranslationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lang: 'lang',
    dropdownGroupId: 'dropdownGroupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DropDownGroupTranslationScalarFieldEnum = (typeof DropDownGroupTranslationScalarFieldEnum)[keyof typeof DropDownGroupTranslationScalarFieldEnum]


  export const DropdownItemScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    pageId: 'pageId',
    forGroup: 'forGroup',
    forArticle: 'forArticle',
    forPage: 'forPage',
    articleId: 'articleId',
    navItemId: 'navItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DropdownItemScalarFieldEnum = (typeof DropdownItemScalarFieldEnum)[keyof typeof DropdownItemScalarFieldEnum]


  export const DropdownItemTranslationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lang: 'lang',
    dropdownItemId: 'dropdownItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DropdownItemTranslationScalarFieldEnum = (typeof DropdownItemTranslationScalarFieldEnum)[keyof typeof DropdownItemTranslationScalarFieldEnum]


  export const FooterScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FooterScalarFieldEnum = (typeof FooterScalarFieldEnum)[keyof typeof FooterScalarFieldEnum]


  export const FooterTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    footerId: 'footerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FooterTranslationScalarFieldEnum = (typeof FooterTranslationScalarFieldEnum)[keyof typeof FooterTranslationScalarFieldEnum]


  export const GroupFooterScalarFieldEnum: {
    id: 'id',
    footerId: 'footerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupFooterScalarFieldEnum = (typeof GroupFooterScalarFieldEnum)[keyof typeof GroupFooterScalarFieldEnum]


  export const GroupFooterTranslationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    groupfooterId: 'groupfooterId',
    lang: 'lang',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupFooterTranslationScalarFieldEnum = (typeof GroupFooterTranslationScalarFieldEnum)[keyof typeof GroupFooterTranslationScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    groupFooterId: 'groupFooterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const PageTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    userId: 'userId',
    title: 'title',
    description: 'description',
    images: 'images',
    published: 'published',
    pageId: 'pageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageTranslationScalarFieldEnum = (typeof PageTranslationScalarFieldEnum)[keyof typeof PageTranslationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CategoryTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    userId: 'userId',
    name: 'name',
    description: 'description',
    images: 'images',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryTranslationScalarFieldEnum = (typeof CategoryTranslationScalarFieldEnum)[keyof typeof CategoryTranslationScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    footerId: 'footerId',
    groupfooterId: 'groupfooterId'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const ArticleTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    userId: 'userId',
    slug: 'slug',
    published: 'published',
    title: 'title',
    description: 'description',
    articleId: 'articleId',
    images: 'images',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleTranslationScalarFieldEnum = (typeof ArticleTranslationScalarFieldEnum)[keyof typeof ArticleTranslationScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    tagId: 'tagId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagTranslationScalarFieldEnum = (typeof TagTranslationScalarFieldEnum)[keyof typeof TagTranslationScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    userId: 'userId',
    name: 'name',
    body: 'body',
    commentId: 'commentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentTranslationScalarFieldEnum = (typeof CommentTranslationScalarFieldEnum)[keyof typeof CommentTranslationScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    pageId: 'pageId',
    articleId: 'articleId',
    categoryServiceId: 'categoryServiceId',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const CategoryServiceScalarFieldEnum: {
    id: 'id',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryServiceScalarFieldEnum = (typeof CategoryServiceScalarFieldEnum)[keyof typeof CategoryServiceScalarFieldEnum]


  export const CategoryServiceTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    name: 'name',
    descriprion: 'descriprion',
    images: 'images',
    categoryServiceId: 'categoryServiceId',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryServiceTranslationScalarFieldEnum = (typeof CategoryServiceTranslationScalarFieldEnum)[keyof typeof CategoryServiceTranslationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceTranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    name: 'name',
    description: 'description',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTranslationScalarFieldEnum = (typeof ServiceTranslationScalarFieldEnum)[keyof typeof ServiceTranslationScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    studentId: 'studentId',
    serviceId: 'serviceId',
    DescriptionOtherService: 'DescriptionOtherService',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    pages?: PageTranslationListRelationFilter
    articles?: ArticleTranslationListRelationFilter
    categories?: CategoryTranslationListRelationFilter
    Comment?: CommentTranslationListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    pages?: PageTranslationOrderByRelationAggregateInput
    articles?: ArticleTranslationOrderByRelationAggregateInput
    categories?: CategoryTranslationOrderByRelationAggregateInput
    Comment?: CommentTranslationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    pages?: PageTranslationListRelationFilter
    articles?: ArticleTranslationListRelationFilter
    categories?: CategoryTranslationListRelationFilter
    Comment?: CommentTranslationListRelationFilter
    orders?: OrderListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    label?: StringFilter<"Language"> | string
    language?: StringFilter<"Language"> | string
    common?: JsonFilter<"Language">
    globals?: GlobalTranslationListRelationFilter
    pages?: PageTranslationListRelationFilter
    categoreis?: CategoryTranslationListRelationFilter
    categoriesServices?: CategoryServiceTranslationListRelationFilter
    services?: ServiceTranslationListRelationFilter
    articles?: ArticleTranslationListRelationFilter
    tags?: TagTranslationListRelationFilter
    comments?: CommentTranslationListRelationFilter
    navbarItems?: NavbarItemTranslationListRelationFilter
    dropdownGroups?: DropDownGroupTranslationListRelationFilter
    dropdownItems?: DropdownItemTranslationListRelationFilter
    footers?: FooterTranslationListRelationFilter
    groupFooters?: GroupFooterTranslationListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    language?: SortOrder
    common?: SortOrder
    globals?: GlobalTranslationOrderByRelationAggregateInput
    pages?: PageTranslationOrderByRelationAggregateInput
    categoreis?: CategoryTranslationOrderByRelationAggregateInput
    categoriesServices?: CategoryServiceTranslationOrderByRelationAggregateInput
    services?: ServiceTranslationOrderByRelationAggregateInput
    articles?: ArticleTranslationOrderByRelationAggregateInput
    tags?: TagTranslationOrderByRelationAggregateInput
    comments?: CommentTranslationOrderByRelationAggregateInput
    navbarItems?: NavbarItemTranslationOrderByRelationAggregateInput
    dropdownGroups?: DropDownGroupTranslationOrderByRelationAggregateInput
    dropdownItems?: DropdownItemTranslationOrderByRelationAggregateInput
    footers?: FooterTranslationOrderByRelationAggregateInput
    groupFooters?: GroupFooterTranslationOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    language?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    label?: StringFilter<"Language"> | string
    common?: JsonFilter<"Language">
    globals?: GlobalTranslationListRelationFilter
    pages?: PageTranslationListRelationFilter
    categoreis?: CategoryTranslationListRelationFilter
    categoriesServices?: CategoryServiceTranslationListRelationFilter
    services?: ServiceTranslationListRelationFilter
    articles?: ArticleTranslationListRelationFilter
    tags?: TagTranslationListRelationFilter
    comments?: CommentTranslationListRelationFilter
    navbarItems?: NavbarItemTranslationListRelationFilter
    dropdownGroups?: DropDownGroupTranslationListRelationFilter
    dropdownItems?: DropdownItemTranslationListRelationFilter
    footers?: FooterTranslationListRelationFilter
    groupFooters?: GroupFooterTranslationListRelationFilter
  }, "id" | "language">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    language?: SortOrder
    common?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    label?: StringWithAggregatesFilter<"Language"> | string
    language?: StringWithAggregatesFilter<"Language"> | string
    common?: JsonWithAggregatesFilter<"Language">
  }

  export type GlobalWhereInput = {
    AND?: GlobalWhereInput | GlobalWhereInput[]
    OR?: GlobalWhereInput[]
    NOT?: GlobalWhereInput | GlobalWhereInput[]
    id?: StringFilter<"Global"> | string
    createdAt?: DateTimeFilter<"Global"> | Date | string
    updatedAt?: DateTimeFilter<"Global"> | Date | string
    translations?: GlobalTranslationListRelationFilter
    socialLinks?: SocialLinkListRelationFilter
  }

  export type GlobalOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: GlobalTranslationOrderByRelationAggregateInput
    socialLinks?: SocialLinkOrderByRelationAggregateInput
  }

  export type GlobalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GlobalWhereInput | GlobalWhereInput[]
    OR?: GlobalWhereInput[]
    NOT?: GlobalWhereInput | GlobalWhereInput[]
    createdAt?: DateTimeFilter<"Global"> | Date | string
    updatedAt?: DateTimeFilter<"Global"> | Date | string
    translations?: GlobalTranslationListRelationFilter
    socialLinks?: SocialLinkListRelationFilter
  }, "id">

  export type GlobalOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalCountOrderByAggregateInput
    _max?: GlobalMaxOrderByAggregateInput
    _min?: GlobalMinOrderByAggregateInput
  }

  export type GlobalScalarWhereWithAggregatesInput = {
    AND?: GlobalScalarWhereWithAggregatesInput | GlobalScalarWhereWithAggregatesInput[]
    OR?: GlobalScalarWhereWithAggregatesInput[]
    NOT?: GlobalScalarWhereWithAggregatesInput | GlobalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Global"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Global"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Global"> | Date | string
  }

  export type GlobalTranslationWhereInput = {
    AND?: GlobalTranslationWhereInput | GlobalTranslationWhereInput[]
    OR?: GlobalTranslationWhereInput[]
    NOT?: GlobalTranslationWhereInput | GlobalTranslationWhereInput[]
    id?: StringFilter<"GlobalTranslation"> | string
    lang?: StringFilter<"GlobalTranslation"> | string
    name?: StringNullableFilter<"GlobalTranslation"> | string | null
    logo?: StringNullableFilter<"GlobalTranslation"> | string | null
    favicon?: StringNullableFilter<"GlobalTranslation"> | string | null
    images?: StringNullableListFilter<"GlobalTranslation">
    description?: StringNullableFilter<"GlobalTranslation"> | string | null
    globalId?: StringFilter<"GlobalTranslation"> | string
    createdAt?: DateTimeFilter<"GlobalTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    global?: XOR<GlobalRelationFilter, GlobalWhereInput>
  }

  export type GlobalTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    images?: SortOrder
    description?: SortOrderInput | SortOrder
    globalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    global?: GlobalOrderByWithRelationInput
  }

  export type GlobalTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_globalId?: GlobalTranslationLangGlobalIdCompoundUniqueInput
    AND?: GlobalTranslationWhereInput | GlobalTranslationWhereInput[]
    OR?: GlobalTranslationWhereInput[]
    NOT?: GlobalTranslationWhereInput | GlobalTranslationWhereInput[]
    lang?: StringFilter<"GlobalTranslation"> | string
    name?: StringNullableFilter<"GlobalTranslation"> | string | null
    logo?: StringNullableFilter<"GlobalTranslation"> | string | null
    favicon?: StringNullableFilter<"GlobalTranslation"> | string | null
    images?: StringNullableListFilter<"GlobalTranslation">
    description?: StringNullableFilter<"GlobalTranslation"> | string | null
    globalId?: StringFilter<"GlobalTranslation"> | string
    createdAt?: DateTimeFilter<"GlobalTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    global?: XOR<GlobalRelationFilter, GlobalWhereInput>
  }, "id" | "lang_globalId">

  export type GlobalTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    images?: SortOrder
    description?: SortOrderInput | SortOrder
    globalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalTranslationCountOrderByAggregateInput
    _max?: GlobalTranslationMaxOrderByAggregateInput
    _min?: GlobalTranslationMinOrderByAggregateInput
  }

  export type GlobalTranslationScalarWhereWithAggregatesInput = {
    AND?: GlobalTranslationScalarWhereWithAggregatesInput | GlobalTranslationScalarWhereWithAggregatesInput[]
    OR?: GlobalTranslationScalarWhereWithAggregatesInput[]
    NOT?: GlobalTranslationScalarWhereWithAggregatesInput | GlobalTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalTranslation"> | string
    lang?: StringWithAggregatesFilter<"GlobalTranslation"> | string
    name?: StringNullableWithAggregatesFilter<"GlobalTranslation"> | string | null
    logo?: StringNullableWithAggregatesFilter<"GlobalTranslation"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"GlobalTranslation"> | string | null
    images?: StringNullableListFilter<"GlobalTranslation">
    description?: StringNullableWithAggregatesFilter<"GlobalTranslation"> | string | null
    globalId?: StringWithAggregatesFilter<"GlobalTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GlobalTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalTranslation"> | Date | string
  }

  export type SocialLinkWhereInput = {
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    social?: StringFilter<"SocialLink"> | string
    url?: StringFilter<"SocialLink"> | string
    globalId?: StringNullableFilter<"SocialLink"> | string | null
    global?: XOR<GlobalNullableRelationFilter, GlobalWhereInput> | null
  }

  export type SocialLinkOrderByWithRelationInput = {
    id?: SortOrder
    social?: SortOrder
    url?: SortOrder
    globalId?: SortOrderInput | SortOrder
    global?: GlobalOrderByWithRelationInput
  }

  export type SocialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    social?: StringFilter<"SocialLink"> | string
    url?: StringFilter<"SocialLink"> | string
    globalId?: StringNullableFilter<"SocialLink"> | string | null
    global?: XOR<GlobalNullableRelationFilter, GlobalWhereInput> | null
  }, "id">

  export type SocialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    social?: SortOrder
    url?: SortOrder
    globalId?: SortOrderInput | SortOrder
    _count?: SocialLinkCountOrderByAggregateInput
    _max?: SocialLinkMaxOrderByAggregateInput
    _min?: SocialLinkMinOrderByAggregateInput
  }

  export type SocialLinkScalarWhereWithAggregatesInput = {
    AND?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    OR?: SocialLinkScalarWhereWithAggregatesInput[]
    NOT?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialLink"> | string
    social?: StringWithAggregatesFilter<"SocialLink"> | string
    url?: StringWithAggregatesFilter<"SocialLink"> | string
    globalId?: StringNullableWithAggregatesFilter<"SocialLink"> | string | null
  }

  export type NavbarItemWhereInput = {
    AND?: NavbarItemWhereInput | NavbarItemWhereInput[]
    OR?: NavbarItemWhereInput[]
    NOT?: NavbarItemWhereInput | NavbarItemWhereInput[]
    id?: StringFilter<"NavbarItem"> | string
    isDropdown?: BoolFilter<"NavbarItem"> | boolean
    forArticle?: BoolFilter<"NavbarItem"> | boolean
    forPage?: BoolFilter<"NavbarItem"> | boolean
    pageId?: StringNullableFilter<"NavbarItem"> | string | null
    articleId?: StringNullableFilter<"NavbarItem"> | string | null
    createdAt?: DateTimeFilter<"NavbarItem"> | Date | string
    updatedAt?: DateTimeFilter<"NavbarItem"> | Date | string
    translations?: NavbarItemTranslationListRelationFilter
    dropdownGroups?: DropDownGroupListRelationFilter
    dropdownItems?: DropdownItemListRelationFilter
    page?: XOR<PageNullableRelationFilter, PageWhereInput> | null
    article?: XOR<ArticleNullableRelationFilter, ArticleWhereInput> | null
  }

  export type NavbarItemOrderByWithRelationInput = {
    id?: SortOrder
    isDropdown?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    pageId?: SortOrderInput | SortOrder
    articleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: NavbarItemTranslationOrderByRelationAggregateInput
    dropdownGroups?: DropDownGroupOrderByRelationAggregateInput
    dropdownItems?: DropdownItemOrderByRelationAggregateInput
    page?: PageOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
  }

  export type NavbarItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageId?: string
    articleId?: string
    pageId_articleId?: NavbarItemPageIdArticleIdCompoundUniqueInput
    AND?: NavbarItemWhereInput | NavbarItemWhereInput[]
    OR?: NavbarItemWhereInput[]
    NOT?: NavbarItemWhereInput | NavbarItemWhereInput[]
    isDropdown?: BoolFilter<"NavbarItem"> | boolean
    forArticle?: BoolFilter<"NavbarItem"> | boolean
    forPage?: BoolFilter<"NavbarItem"> | boolean
    createdAt?: DateTimeFilter<"NavbarItem"> | Date | string
    updatedAt?: DateTimeFilter<"NavbarItem"> | Date | string
    translations?: NavbarItemTranslationListRelationFilter
    dropdownGroups?: DropDownGroupListRelationFilter
    dropdownItems?: DropdownItemListRelationFilter
    page?: XOR<PageNullableRelationFilter, PageWhereInput> | null
    article?: XOR<ArticleNullableRelationFilter, ArticleWhereInput> | null
  }, "id" | "id" | "pageId" | "articleId" | "pageId_articleId">

  export type NavbarItemOrderByWithAggregationInput = {
    id?: SortOrder
    isDropdown?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    pageId?: SortOrderInput | SortOrder
    articleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NavbarItemCountOrderByAggregateInput
    _max?: NavbarItemMaxOrderByAggregateInput
    _min?: NavbarItemMinOrderByAggregateInput
  }

  export type NavbarItemScalarWhereWithAggregatesInput = {
    AND?: NavbarItemScalarWhereWithAggregatesInput | NavbarItemScalarWhereWithAggregatesInput[]
    OR?: NavbarItemScalarWhereWithAggregatesInput[]
    NOT?: NavbarItemScalarWhereWithAggregatesInput | NavbarItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NavbarItem"> | string
    isDropdown?: BoolWithAggregatesFilter<"NavbarItem"> | boolean
    forArticle?: BoolWithAggregatesFilter<"NavbarItem"> | boolean
    forPage?: BoolWithAggregatesFilter<"NavbarItem"> | boolean
    pageId?: StringNullableWithAggregatesFilter<"NavbarItem"> | string | null
    articleId?: StringNullableWithAggregatesFilter<"NavbarItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NavbarItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NavbarItem"> | Date | string
  }

  export type NavbarItemTranslationWhereInput = {
    AND?: NavbarItemTranslationWhereInput | NavbarItemTranslationWhereInput[]
    OR?: NavbarItemTranslationWhereInput[]
    NOT?: NavbarItemTranslationWhereInput | NavbarItemTranslationWhereInput[]
    id?: StringFilter<"NavbarItemTranslation"> | string
    name?: StringFilter<"NavbarItemTranslation"> | string
    lang?: StringFilter<"NavbarItemTranslation"> | string
    navbarItemId?: StringNullableFilter<"NavbarItemTranslation"> | string | null
    createdAt?: DateTimeFilter<"NavbarItemTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"NavbarItemTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    navbarItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
  }

  export type NavbarItemTranslationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    navbarItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    navbarItem?: NavbarItemOrderByWithRelationInput
  }

  export type NavbarItemTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_navbarItemId?: NavbarItemTranslationLangNavbarItemIdCompoundUniqueInput
    AND?: NavbarItemTranslationWhereInput | NavbarItemTranslationWhereInput[]
    OR?: NavbarItemTranslationWhereInput[]
    NOT?: NavbarItemTranslationWhereInput | NavbarItemTranslationWhereInput[]
    name?: StringFilter<"NavbarItemTranslation"> | string
    lang?: StringFilter<"NavbarItemTranslation"> | string
    navbarItemId?: StringNullableFilter<"NavbarItemTranslation"> | string | null
    createdAt?: DateTimeFilter<"NavbarItemTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"NavbarItemTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    navbarItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
  }, "id" | "lang_navbarItemId">

  export type NavbarItemTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    navbarItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NavbarItemTranslationCountOrderByAggregateInput
    _max?: NavbarItemTranslationMaxOrderByAggregateInput
    _min?: NavbarItemTranslationMinOrderByAggregateInput
  }

  export type NavbarItemTranslationScalarWhereWithAggregatesInput = {
    AND?: NavbarItemTranslationScalarWhereWithAggregatesInput | NavbarItemTranslationScalarWhereWithAggregatesInput[]
    OR?: NavbarItemTranslationScalarWhereWithAggregatesInput[]
    NOT?: NavbarItemTranslationScalarWhereWithAggregatesInput | NavbarItemTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NavbarItemTranslation"> | string
    name?: StringWithAggregatesFilter<"NavbarItemTranslation"> | string
    lang?: StringWithAggregatesFilter<"NavbarItemTranslation"> | string
    navbarItemId?: StringNullableWithAggregatesFilter<"NavbarItemTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NavbarItemTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NavbarItemTranslation"> | Date | string
  }

  export type DropDownGroupWhereInput = {
    AND?: DropDownGroupWhereInput | DropDownGroupWhereInput[]
    OR?: DropDownGroupWhereInput[]
    NOT?: DropDownGroupWhereInput | DropDownGroupWhereInput[]
    id?: StringFilter<"DropDownGroup"> | string
    navItemId?: StringNullableFilter<"DropDownGroup"> | string | null
    createdAt?: DateTimeFilter<"DropDownGroup"> | Date | string
    updatedAt?: DateTimeFilter<"DropDownGroup"> | Date | string
    translations?: DropDownGroupTranslationListRelationFilter
    navItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
    dropdownItems?: DropdownItemListRelationFilter
  }

  export type DropDownGroupOrderByWithRelationInput = {
    id?: SortOrder
    navItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: DropDownGroupTranslationOrderByRelationAggregateInput
    navItem?: NavbarItemOrderByWithRelationInput
    dropdownItems?: DropdownItemOrderByRelationAggregateInput
  }

  export type DropDownGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DropDownGroupWhereInput | DropDownGroupWhereInput[]
    OR?: DropDownGroupWhereInput[]
    NOT?: DropDownGroupWhereInput | DropDownGroupWhereInput[]
    navItemId?: StringNullableFilter<"DropDownGroup"> | string | null
    createdAt?: DateTimeFilter<"DropDownGroup"> | Date | string
    updatedAt?: DateTimeFilter<"DropDownGroup"> | Date | string
    translations?: DropDownGroupTranslationListRelationFilter
    navItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
    dropdownItems?: DropdownItemListRelationFilter
  }, "id">

  export type DropDownGroupOrderByWithAggregationInput = {
    id?: SortOrder
    navItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DropDownGroupCountOrderByAggregateInput
    _max?: DropDownGroupMaxOrderByAggregateInput
    _min?: DropDownGroupMinOrderByAggregateInput
  }

  export type DropDownGroupScalarWhereWithAggregatesInput = {
    AND?: DropDownGroupScalarWhereWithAggregatesInput | DropDownGroupScalarWhereWithAggregatesInput[]
    OR?: DropDownGroupScalarWhereWithAggregatesInput[]
    NOT?: DropDownGroupScalarWhereWithAggregatesInput | DropDownGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DropDownGroup"> | string
    navItemId?: StringNullableWithAggregatesFilter<"DropDownGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DropDownGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DropDownGroup"> | Date | string
  }

  export type DropDownGroupTranslationWhereInput = {
    AND?: DropDownGroupTranslationWhereInput | DropDownGroupTranslationWhereInput[]
    OR?: DropDownGroupTranslationWhereInput[]
    NOT?: DropDownGroupTranslationWhereInput | DropDownGroupTranslationWhereInput[]
    id?: StringFilter<"DropDownGroupTranslation"> | string
    name?: StringFilter<"DropDownGroupTranslation"> | string
    lang?: StringFilter<"DropDownGroupTranslation"> | string
    dropdownGroupId?: StringNullableFilter<"DropDownGroupTranslation"> | string | null
    createdAt?: DateTimeFilter<"DropDownGroupTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DropDownGroupTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    dropdownGroup?: XOR<DropDownGroupNullableRelationFilter, DropDownGroupWhereInput> | null
  }

  export type DropDownGroupTranslationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    dropdownGroup?: DropDownGroupOrderByWithRelationInput
  }

  export type DropDownGroupTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_dropdownGroupId?: DropDownGroupTranslationLangDropdownGroupIdCompoundUniqueInput
    AND?: DropDownGroupTranslationWhereInput | DropDownGroupTranslationWhereInput[]
    OR?: DropDownGroupTranslationWhereInput[]
    NOT?: DropDownGroupTranslationWhereInput | DropDownGroupTranslationWhereInput[]
    name?: StringFilter<"DropDownGroupTranslation"> | string
    lang?: StringFilter<"DropDownGroupTranslation"> | string
    dropdownGroupId?: StringNullableFilter<"DropDownGroupTranslation"> | string | null
    createdAt?: DateTimeFilter<"DropDownGroupTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DropDownGroupTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    dropdownGroup?: XOR<DropDownGroupNullableRelationFilter, DropDownGroupWhereInput> | null
  }, "id" | "lang_dropdownGroupId">

  export type DropDownGroupTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DropDownGroupTranslationCountOrderByAggregateInput
    _max?: DropDownGroupTranslationMaxOrderByAggregateInput
    _min?: DropDownGroupTranslationMinOrderByAggregateInput
  }

  export type DropDownGroupTranslationScalarWhereWithAggregatesInput = {
    AND?: DropDownGroupTranslationScalarWhereWithAggregatesInput | DropDownGroupTranslationScalarWhereWithAggregatesInput[]
    OR?: DropDownGroupTranslationScalarWhereWithAggregatesInput[]
    NOT?: DropDownGroupTranslationScalarWhereWithAggregatesInput | DropDownGroupTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DropDownGroupTranslation"> | string
    name?: StringWithAggregatesFilter<"DropDownGroupTranslation"> | string
    lang?: StringWithAggregatesFilter<"DropDownGroupTranslation"> | string
    dropdownGroupId?: StringNullableWithAggregatesFilter<"DropDownGroupTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DropDownGroupTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DropDownGroupTranslation"> | Date | string
  }

  export type DropdownItemWhereInput = {
    AND?: DropdownItemWhereInput | DropdownItemWhereInput[]
    OR?: DropdownItemWhereInput[]
    NOT?: DropdownItemWhereInput | DropdownItemWhereInput[]
    id?: StringFilter<"DropdownItem"> | string
    groupId?: StringNullableFilter<"DropdownItem"> | string | null
    pageId?: StringNullableFilter<"DropdownItem"> | string | null
    forGroup?: BoolFilter<"DropdownItem"> | boolean
    forArticle?: BoolFilter<"DropdownItem"> | boolean
    forPage?: BoolFilter<"DropdownItem"> | boolean
    articleId?: StringNullableFilter<"DropdownItem"> | string | null
    navItemId?: StringNullableFilter<"DropdownItem"> | string | null
    createdAt?: DateTimeFilter<"DropdownItem"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownItem"> | Date | string
    translations?: DropdownItemTranslationListRelationFilter
    group?: XOR<DropDownGroupNullableRelationFilter, DropDownGroupWhereInput> | null
    page?: XOR<PageNullableRelationFilter, PageWhereInput> | null
    article?: XOR<ArticleNullableRelationFilter, ArticleWhereInput> | null
    navItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
  }

  export type DropdownItemOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    forGroup?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    articleId?: SortOrderInput | SortOrder
    navItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: DropdownItemTranslationOrderByRelationAggregateInput
    group?: DropDownGroupOrderByWithRelationInput
    page?: PageOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
    navItem?: NavbarItemOrderByWithRelationInput
  }

  export type DropdownItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageId?: string
    articleId?: string
    AND?: DropdownItemWhereInput | DropdownItemWhereInput[]
    OR?: DropdownItemWhereInput[]
    NOT?: DropdownItemWhereInput | DropdownItemWhereInput[]
    groupId?: StringNullableFilter<"DropdownItem"> | string | null
    forGroup?: BoolFilter<"DropdownItem"> | boolean
    forArticle?: BoolFilter<"DropdownItem"> | boolean
    forPage?: BoolFilter<"DropdownItem"> | boolean
    navItemId?: StringNullableFilter<"DropdownItem"> | string | null
    createdAt?: DateTimeFilter<"DropdownItem"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownItem"> | Date | string
    translations?: DropdownItemTranslationListRelationFilter
    group?: XOR<DropDownGroupNullableRelationFilter, DropDownGroupWhereInput> | null
    page?: XOR<PageNullableRelationFilter, PageWhereInput> | null
    article?: XOR<ArticleNullableRelationFilter, ArticleWhereInput> | null
    navItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
  }, "id" | "id" | "pageId" | "articleId">

  export type DropdownItemOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    forGroup?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    articleId?: SortOrderInput | SortOrder
    navItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DropdownItemCountOrderByAggregateInput
    _max?: DropdownItemMaxOrderByAggregateInput
    _min?: DropdownItemMinOrderByAggregateInput
  }

  export type DropdownItemScalarWhereWithAggregatesInput = {
    AND?: DropdownItemScalarWhereWithAggregatesInput | DropdownItemScalarWhereWithAggregatesInput[]
    OR?: DropdownItemScalarWhereWithAggregatesInput[]
    NOT?: DropdownItemScalarWhereWithAggregatesInput | DropdownItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DropdownItem"> | string
    groupId?: StringNullableWithAggregatesFilter<"DropdownItem"> | string | null
    pageId?: StringNullableWithAggregatesFilter<"DropdownItem"> | string | null
    forGroup?: BoolWithAggregatesFilter<"DropdownItem"> | boolean
    forArticle?: BoolWithAggregatesFilter<"DropdownItem"> | boolean
    forPage?: BoolWithAggregatesFilter<"DropdownItem"> | boolean
    articleId?: StringNullableWithAggregatesFilter<"DropdownItem"> | string | null
    navItemId?: StringNullableWithAggregatesFilter<"DropdownItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DropdownItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DropdownItem"> | Date | string
  }

  export type DropdownItemTranslationWhereInput = {
    AND?: DropdownItemTranslationWhereInput | DropdownItemTranslationWhereInput[]
    OR?: DropdownItemTranslationWhereInput[]
    NOT?: DropdownItemTranslationWhereInput | DropdownItemTranslationWhereInput[]
    id?: StringFilter<"DropdownItemTranslation"> | string
    name?: StringFilter<"DropdownItemTranslation"> | string
    lang?: StringFilter<"DropdownItemTranslation"> | string
    dropdownItemId?: StringNullableFilter<"DropdownItemTranslation"> | string | null
    createdAt?: DateTimeFilter<"DropdownItemTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownItemTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    dropdownItem?: XOR<DropdownItemNullableRelationFilter, DropdownItemWhereInput> | null
  }

  export type DropdownItemTranslationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    dropdownItem?: DropdownItemOrderByWithRelationInput
  }

  export type DropdownItemTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_dropdownItemId?: DropdownItemTranslationLangDropdownItemIdCompoundUniqueInput
    AND?: DropdownItemTranslationWhereInput | DropdownItemTranslationWhereInput[]
    OR?: DropdownItemTranslationWhereInput[]
    NOT?: DropdownItemTranslationWhereInput | DropdownItemTranslationWhereInput[]
    name?: StringFilter<"DropdownItemTranslation"> | string
    lang?: StringFilter<"DropdownItemTranslation"> | string
    dropdownItemId?: StringNullableFilter<"DropdownItemTranslation"> | string | null
    createdAt?: DateTimeFilter<"DropdownItemTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownItemTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    dropdownItem?: XOR<DropdownItemNullableRelationFilter, DropdownItemWhereInput> | null
  }, "id" | "lang_dropdownItemId">

  export type DropdownItemTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DropdownItemTranslationCountOrderByAggregateInput
    _max?: DropdownItemTranslationMaxOrderByAggregateInput
    _min?: DropdownItemTranslationMinOrderByAggregateInput
  }

  export type DropdownItemTranslationScalarWhereWithAggregatesInput = {
    AND?: DropdownItemTranslationScalarWhereWithAggregatesInput | DropdownItemTranslationScalarWhereWithAggregatesInput[]
    OR?: DropdownItemTranslationScalarWhereWithAggregatesInput[]
    NOT?: DropdownItemTranslationScalarWhereWithAggregatesInput | DropdownItemTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DropdownItemTranslation"> | string
    name?: StringWithAggregatesFilter<"DropdownItemTranslation"> | string
    lang?: StringWithAggregatesFilter<"DropdownItemTranslation"> | string
    dropdownItemId?: StringNullableWithAggregatesFilter<"DropdownItemTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DropdownItemTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DropdownItemTranslation"> | Date | string
  }

  export type FooterWhereInput = {
    AND?: FooterWhereInput | FooterWhereInput[]
    OR?: FooterWhereInput[]
    NOT?: FooterWhereInput | FooterWhereInput[]
    id?: StringFilter<"Footer"> | string
    createdAt?: DateTimeFilter<"Footer"> | Date | string
    updatedAt?: DateTimeFilter<"Footer"> | Date | string
    translations?: FooterTranslationListRelationFilter
    groups?: GroupFooterListRelationFilter
    articles?: ArticleListRelationFilter
  }

  export type FooterOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: FooterTranslationOrderByRelationAggregateInput
    groups?: GroupFooterOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
  }

  export type FooterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FooterWhereInput | FooterWhereInput[]
    OR?: FooterWhereInput[]
    NOT?: FooterWhereInput | FooterWhereInput[]
    createdAt?: DateTimeFilter<"Footer"> | Date | string
    updatedAt?: DateTimeFilter<"Footer"> | Date | string
    translations?: FooterTranslationListRelationFilter
    groups?: GroupFooterListRelationFilter
    articles?: ArticleListRelationFilter
  }, "id">

  export type FooterOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FooterCountOrderByAggregateInput
    _max?: FooterMaxOrderByAggregateInput
    _min?: FooterMinOrderByAggregateInput
  }

  export type FooterScalarWhereWithAggregatesInput = {
    AND?: FooterScalarWhereWithAggregatesInput | FooterScalarWhereWithAggregatesInput[]
    OR?: FooterScalarWhereWithAggregatesInput[]
    NOT?: FooterScalarWhereWithAggregatesInput | FooterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Footer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Footer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Footer"> | Date | string
  }

  export type FooterTranslationWhereInput = {
    AND?: FooterTranslationWhereInput | FooterTranslationWhereInput[]
    OR?: FooterTranslationWhereInput[]
    NOT?: FooterTranslationWhereInput | FooterTranslationWhereInput[]
    id?: StringFilter<"FooterTranslation"> | string
    lang?: StringFilter<"FooterTranslation"> | string
    footerId?: StringNullableFilter<"FooterTranslation"> | string | null
    createdAt?: DateTimeFilter<"FooterTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"FooterTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    footer?: XOR<FooterNullableRelationFilter, FooterWhereInput> | null
  }

  export type FooterTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    footerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    footer?: FooterOrderByWithRelationInput
  }

  export type FooterTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_footerId?: FooterTranslationLangFooterIdCompoundUniqueInput
    AND?: FooterTranslationWhereInput | FooterTranslationWhereInput[]
    OR?: FooterTranslationWhereInput[]
    NOT?: FooterTranslationWhereInput | FooterTranslationWhereInput[]
    lang?: StringFilter<"FooterTranslation"> | string
    footerId?: StringNullableFilter<"FooterTranslation"> | string | null
    createdAt?: DateTimeFilter<"FooterTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"FooterTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    footer?: XOR<FooterNullableRelationFilter, FooterWhereInput> | null
  }, "id" | "lang_footerId">

  export type FooterTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    footerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FooterTranslationCountOrderByAggregateInput
    _max?: FooterTranslationMaxOrderByAggregateInput
    _min?: FooterTranslationMinOrderByAggregateInput
  }

  export type FooterTranslationScalarWhereWithAggregatesInput = {
    AND?: FooterTranslationScalarWhereWithAggregatesInput | FooterTranslationScalarWhereWithAggregatesInput[]
    OR?: FooterTranslationScalarWhereWithAggregatesInput[]
    NOT?: FooterTranslationScalarWhereWithAggregatesInput | FooterTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FooterTranslation"> | string
    lang?: StringWithAggregatesFilter<"FooterTranslation"> | string
    footerId?: StringNullableWithAggregatesFilter<"FooterTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FooterTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FooterTranslation"> | Date | string
  }

  export type GroupFooterWhereInput = {
    AND?: GroupFooterWhereInput | GroupFooterWhereInput[]
    OR?: GroupFooterWhereInput[]
    NOT?: GroupFooterWhereInput | GroupFooterWhereInput[]
    id?: StringFilter<"GroupFooter"> | string
    footerId?: StringNullableFilter<"GroupFooter"> | string | null
    createdAt?: DateTimeFilter<"GroupFooter"> | Date | string
    updatedAt?: DateTimeFilter<"GroupFooter"> | Date | string
    translations?: GroupFooterTranslationListRelationFilter
    footer?: XOR<FooterNullableRelationFilter, FooterWhereInput> | null
    articles?: ArticleListRelationFilter
    pages?: PageListRelationFilter
  }

  export type GroupFooterOrderByWithRelationInput = {
    id?: SortOrder
    footerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: GroupFooterTranslationOrderByRelationAggregateInput
    footer?: FooterOrderByWithRelationInput
    articles?: ArticleOrderByRelationAggregateInput
    pages?: PageOrderByRelationAggregateInput
  }

  export type GroupFooterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupFooterWhereInput | GroupFooterWhereInput[]
    OR?: GroupFooterWhereInput[]
    NOT?: GroupFooterWhereInput | GroupFooterWhereInput[]
    footerId?: StringNullableFilter<"GroupFooter"> | string | null
    createdAt?: DateTimeFilter<"GroupFooter"> | Date | string
    updatedAt?: DateTimeFilter<"GroupFooter"> | Date | string
    translations?: GroupFooterTranslationListRelationFilter
    footer?: XOR<FooterNullableRelationFilter, FooterWhereInput> | null
    articles?: ArticleListRelationFilter
    pages?: PageListRelationFilter
  }, "id">

  export type GroupFooterOrderByWithAggregationInput = {
    id?: SortOrder
    footerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupFooterCountOrderByAggregateInput
    _max?: GroupFooterMaxOrderByAggregateInput
    _min?: GroupFooterMinOrderByAggregateInput
  }

  export type GroupFooterScalarWhereWithAggregatesInput = {
    AND?: GroupFooterScalarWhereWithAggregatesInput | GroupFooterScalarWhereWithAggregatesInput[]
    OR?: GroupFooterScalarWhereWithAggregatesInput[]
    NOT?: GroupFooterScalarWhereWithAggregatesInput | GroupFooterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupFooter"> | string
    footerId?: StringNullableWithAggregatesFilter<"GroupFooter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GroupFooter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupFooter"> | Date | string
  }

  export type GroupFooterTranslationWhereInput = {
    AND?: GroupFooterTranslationWhereInput | GroupFooterTranslationWhereInput[]
    OR?: GroupFooterTranslationWhereInput[]
    NOT?: GroupFooterTranslationWhereInput | GroupFooterTranslationWhereInput[]
    id?: StringFilter<"GroupFooterTranslation"> | string
    title?: StringNullableFilter<"GroupFooterTranslation"> | string | null
    groupfooterId?: StringNullableFilter<"GroupFooterTranslation"> | string | null
    lang?: StringFilter<"GroupFooterTranslation"> | string
    createdAt?: DateTimeFilter<"GroupFooterTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GroupFooterTranslation"> | Date | string
    groupfooter?: XOR<GroupFooterNullableRelationFilter, GroupFooterWhereInput> | null
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }

  export type GroupFooterTranslationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    groupfooterId?: SortOrderInput | SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupfooter?: GroupFooterOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type GroupFooterTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_groupfooterId?: GroupFooterTranslationLangGroupfooterIdCompoundUniqueInput
    AND?: GroupFooterTranslationWhereInput | GroupFooterTranslationWhereInput[]
    OR?: GroupFooterTranslationWhereInput[]
    NOT?: GroupFooterTranslationWhereInput | GroupFooterTranslationWhereInput[]
    title?: StringNullableFilter<"GroupFooterTranslation"> | string | null
    groupfooterId?: StringNullableFilter<"GroupFooterTranslation"> | string | null
    lang?: StringFilter<"GroupFooterTranslation"> | string
    createdAt?: DateTimeFilter<"GroupFooterTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GroupFooterTranslation"> | Date | string
    groupfooter?: XOR<GroupFooterNullableRelationFilter, GroupFooterWhereInput> | null
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }, "id" | "lang_groupfooterId">

  export type GroupFooterTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    groupfooterId?: SortOrderInput | SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupFooterTranslationCountOrderByAggregateInput
    _max?: GroupFooterTranslationMaxOrderByAggregateInput
    _min?: GroupFooterTranslationMinOrderByAggregateInput
  }

  export type GroupFooterTranslationScalarWhereWithAggregatesInput = {
    AND?: GroupFooterTranslationScalarWhereWithAggregatesInput | GroupFooterTranslationScalarWhereWithAggregatesInput[]
    OR?: GroupFooterTranslationScalarWhereWithAggregatesInput[]
    NOT?: GroupFooterTranslationScalarWhereWithAggregatesInput | GroupFooterTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupFooterTranslation"> | string
    title?: StringNullableWithAggregatesFilter<"GroupFooterTranslation"> | string | null
    groupfooterId?: StringNullableWithAggregatesFilter<"GroupFooterTranslation"> | string | null
    lang?: StringWithAggregatesFilter<"GroupFooterTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupFooterTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupFooterTranslation"> | Date | string
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: StringFilter<"Page"> | string
    groupFooterId?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    translations?: PageTranslationListRelationFilter
    navbarItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
    dropdownItem?: XOR<DropdownItemNullableRelationFilter, DropdownItemWhereInput> | null
    groupFooter?: XOR<GroupFooterNullableRelationFilter, GroupFooterWhereInput> | null
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    groupFooterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: PageTranslationOrderByRelationAggregateInput
    navbarItem?: NavbarItemOrderByWithRelationInput
    dropdownItem?: DropdownItemOrderByWithRelationInput
    groupFooter?: GroupFooterOrderByWithRelationInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    groupFooterId?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    translations?: PageTranslationListRelationFilter
    navbarItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
    dropdownItem?: XOR<DropdownItemNullableRelationFilter, DropdownItemWhereInput> | null
    groupFooter?: XOR<GroupFooterNullableRelationFilter, GroupFooterWhereInput> | null
  }, "id" | "id">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    groupFooterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Page"> | string
    groupFooterId?: StringNullableWithAggregatesFilter<"Page"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type PageTranslationWhereInput = {
    AND?: PageTranslationWhereInput | PageTranslationWhereInput[]
    OR?: PageTranslationWhereInput[]
    NOT?: PageTranslationWhereInput | PageTranslationWhereInput[]
    id?: StringFilter<"PageTranslation"> | string
    lang?: StringFilter<"PageTranslation"> | string
    userId?: StringFilter<"PageTranslation"> | string
    title?: StringFilter<"PageTranslation"> | string
    description?: StringNullableFilter<"PageTranslation"> | string | null
    images?: StringNullableListFilter<"PageTranslation">
    published?: BoolFilter<"PageTranslation"> | boolean
    pageId?: StringFilter<"PageTranslation"> | string
    createdAt?: DateTimeFilter<"PageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PageTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    blocks?: BlockListRelationFilter
    page?: XOR<PageRelationFilter, PageWhereInput>
  }

  export type PageTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    images?: SortOrder
    published?: SortOrder
    pageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    blocks?: BlockOrderByRelationAggregateInput
    page?: PageOrderByWithRelationInput
  }

  export type PageTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_pageId?: PageTranslationLangPageIdCompoundUniqueInput
    AND?: PageTranslationWhereInput | PageTranslationWhereInput[]
    OR?: PageTranslationWhereInput[]
    NOT?: PageTranslationWhereInput | PageTranslationWhereInput[]
    lang?: StringFilter<"PageTranslation"> | string
    userId?: StringFilter<"PageTranslation"> | string
    title?: StringFilter<"PageTranslation"> | string
    description?: StringNullableFilter<"PageTranslation"> | string | null
    images?: StringNullableListFilter<"PageTranslation">
    published?: BoolFilter<"PageTranslation"> | boolean
    pageId?: StringFilter<"PageTranslation"> | string
    createdAt?: DateTimeFilter<"PageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PageTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    blocks?: BlockListRelationFilter
    page?: XOR<PageRelationFilter, PageWhereInput>
  }, "id" | "lang_pageId">

  export type PageTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    images?: SortOrder
    published?: SortOrder
    pageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageTranslationCountOrderByAggregateInput
    _max?: PageTranslationMaxOrderByAggregateInput
    _min?: PageTranslationMinOrderByAggregateInput
  }

  export type PageTranslationScalarWhereWithAggregatesInput = {
    AND?: PageTranslationScalarWhereWithAggregatesInput | PageTranslationScalarWhereWithAggregatesInput[]
    OR?: PageTranslationScalarWhereWithAggregatesInput[]
    NOT?: PageTranslationScalarWhereWithAggregatesInput | PageTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PageTranslation"> | string
    lang?: StringWithAggregatesFilter<"PageTranslation"> | string
    userId?: StringWithAggregatesFilter<"PageTranslation"> | string
    title?: StringWithAggregatesFilter<"PageTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"PageTranslation"> | string | null
    images?: StringNullableListFilter<"PageTranslation">
    published?: BoolWithAggregatesFilter<"PageTranslation"> | boolean
    pageId?: StringWithAggregatesFilter<"PageTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PageTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PageTranslation"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    translations?: CategoryTranslationListRelationFilter
    articles?: ArticleListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: CategoryTranslationOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    translations?: CategoryTranslationListRelationFilter
    articles?: ArticleListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type CategoryTranslationWhereInput = {
    AND?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    OR?: CategoryTranslationWhereInput[]
    NOT?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    id?: StringFilter<"CategoryTranslation"> | string
    lang?: StringFilter<"CategoryTranslation"> | string
    userId?: StringFilter<"CategoryTranslation"> | string
    name?: StringFilter<"CategoryTranslation"> | string
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryTranslation">
    categoryId?: StringFilter<"CategoryTranslation"> | string
    createdAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }

  export type CategoryTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type CategoryTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_categoryId?: CategoryTranslationLangCategoryIdCompoundUniqueInput
    AND?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    OR?: CategoryTranslationWhereInput[]
    NOT?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    lang?: StringFilter<"CategoryTranslation"> | string
    userId?: StringFilter<"CategoryTranslation"> | string
    name?: StringFilter<"CategoryTranslation"> | string
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryTranslation">
    categoryId?: StringFilter<"CategoryTranslation"> | string
    createdAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }, "id" | "lang_categoryId">

  export type CategoryTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryTranslationCountOrderByAggregateInput
    _max?: CategoryTranslationMaxOrderByAggregateInput
    _min?: CategoryTranslationMinOrderByAggregateInput
  }

  export type CategoryTranslationScalarWhereWithAggregatesInput = {
    AND?: CategoryTranslationScalarWhereWithAggregatesInput | CategoryTranslationScalarWhereWithAggregatesInput[]
    OR?: CategoryTranslationScalarWhereWithAggregatesInput[]
    NOT?: CategoryTranslationScalarWhereWithAggregatesInput | CategoryTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    lang?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    userId?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    name?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryTranslation">
    categoryId?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryTranslation"> | Date | string
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: StringFilter<"Article"> | string
    categoryId?: StringNullableFilter<"Article"> | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    footerId?: StringNullableFilter<"Article"> | string | null
    groupfooterId?: StringNullableFilter<"Article"> | string | null
    translations?: ArticleTranslationListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tags?: TagListRelationFilter
    comments?: CommentListRelationFilter
    footer?: XOR<FooterNullableRelationFilter, FooterWhereInput> | null
    groupfooter?: XOR<GroupFooterNullableRelationFilter, GroupFooterWhereInput> | null
    navbarItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
    dropdownItem?: XOR<DropdownItemNullableRelationFilter, DropdownItemWhereInput> | null
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    footerId?: SortOrderInput | SortOrder
    groupfooterId?: SortOrderInput | SortOrder
    translations?: ArticleTranslationOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    footer?: FooterOrderByWithRelationInput
    groupfooter?: GroupFooterOrderByWithRelationInput
    navbarItem?: NavbarItemOrderByWithRelationInput
    dropdownItem?: DropdownItemOrderByWithRelationInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    categoryId?: StringNullableFilter<"Article"> | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    footerId?: StringNullableFilter<"Article"> | string | null
    groupfooterId?: StringNullableFilter<"Article"> | string | null
    translations?: ArticleTranslationListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tags?: TagListRelationFilter
    comments?: CommentListRelationFilter
    footer?: XOR<FooterNullableRelationFilter, FooterWhereInput> | null
    groupfooter?: XOR<GroupFooterNullableRelationFilter, GroupFooterWhereInput> | null
    navbarItem?: XOR<NavbarItemNullableRelationFilter, NavbarItemWhereInput> | null
    dropdownItem?: XOR<DropdownItemNullableRelationFilter, DropdownItemWhereInput> | null
  }, "id" | "id">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    footerId?: SortOrderInput | SortOrder
    groupfooterId?: SortOrderInput | SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Article"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Article"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    footerId?: StringNullableWithAggregatesFilter<"Article"> | string | null
    groupfooterId?: StringNullableWithAggregatesFilter<"Article"> | string | null
  }

  export type ArticleTranslationWhereInput = {
    AND?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
    OR?: ArticleTranslationWhereInput[]
    NOT?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
    id?: StringFilter<"ArticleTranslation"> | string
    lang?: StringFilter<"ArticleTranslation"> | string
    userId?: StringFilter<"ArticleTranslation"> | string
    slug?: StringNullableFilter<"ArticleTranslation"> | string | null
    published?: BoolFilter<"ArticleTranslation"> | boolean
    title?: StringNullableFilter<"ArticleTranslation"> | string | null
    description?: StringNullableFilter<"ArticleTranslation"> | string | null
    articleId?: StringFilter<"ArticleTranslation"> | string
    images?: StringNullableListFilter<"ArticleTranslation">
    createdAt?: DateTimeFilter<"ArticleTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ArticleTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
    blocks?: BlockListRelationFilter
  }

  export type ArticleTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    slug?: SortOrderInput | SortOrder
    published?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    articleId?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
    blocks?: BlockOrderByRelationAggregateInput
  }

  export type ArticleTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_articleId?: ArticleTranslationLangArticleIdCompoundUniqueInput
    AND?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
    OR?: ArticleTranslationWhereInput[]
    NOT?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
    lang?: StringFilter<"ArticleTranslation"> | string
    userId?: StringFilter<"ArticleTranslation"> | string
    slug?: StringNullableFilter<"ArticleTranslation"> | string | null
    published?: BoolFilter<"ArticleTranslation"> | boolean
    title?: StringNullableFilter<"ArticleTranslation"> | string | null
    description?: StringNullableFilter<"ArticleTranslation"> | string | null
    articleId?: StringFilter<"ArticleTranslation"> | string
    images?: StringNullableListFilter<"ArticleTranslation">
    createdAt?: DateTimeFilter<"ArticleTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ArticleTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
    blocks?: BlockListRelationFilter
  }, "id" | "lang_articleId">

  export type ArticleTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    slug?: SortOrderInput | SortOrder
    published?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    articleId?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleTranslationCountOrderByAggregateInput
    _max?: ArticleTranslationMaxOrderByAggregateInput
    _min?: ArticleTranslationMinOrderByAggregateInput
  }

  export type ArticleTranslationScalarWhereWithAggregatesInput = {
    AND?: ArticleTranslationScalarWhereWithAggregatesInput | ArticleTranslationScalarWhereWithAggregatesInput[]
    OR?: ArticleTranslationScalarWhereWithAggregatesInput[]
    NOT?: ArticleTranslationScalarWhereWithAggregatesInput | ArticleTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArticleTranslation"> | string
    lang?: StringWithAggregatesFilter<"ArticleTranslation"> | string
    userId?: StringWithAggregatesFilter<"ArticleTranslation"> | string
    slug?: StringNullableWithAggregatesFilter<"ArticleTranslation"> | string | null
    published?: BoolWithAggregatesFilter<"ArticleTranslation"> | boolean
    title?: StringNullableWithAggregatesFilter<"ArticleTranslation"> | string | null
    description?: StringNullableWithAggregatesFilter<"ArticleTranslation"> | string | null
    articleId?: StringWithAggregatesFilter<"ArticleTranslation"> | string
    images?: StringNullableListFilter<"ArticleTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"ArticleTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ArticleTranslation"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    translations?: TagTranslationListRelationFilter
    articles?: ArticleListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: TagTranslationOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    translations?: TagTranslationListRelationFilter
    articles?: ArticleListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TagTranslationWhereInput = {
    AND?: TagTranslationWhereInput | TagTranslationWhereInput[]
    OR?: TagTranslationWhereInput[]
    NOT?: TagTranslationWhereInput | TagTranslationWhereInput[]
    id?: StringFilter<"TagTranslation"> | string
    lang?: StringFilter<"TagTranslation"> | string
    tagId?: StringFilter<"TagTranslation"> | string
    name?: StringFilter<"TagTranslation"> | string
    createdAt?: DateTimeFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TagTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type TagTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TagTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_tagId?: TagTranslationLangTagIdCompoundUniqueInput
    AND?: TagTranslationWhereInput | TagTranslationWhereInput[]
    OR?: TagTranslationWhereInput[]
    NOT?: TagTranslationWhereInput | TagTranslationWhereInput[]
    lang?: StringFilter<"TagTranslation"> | string
    tagId?: StringFilter<"TagTranslation"> | string
    name?: StringFilter<"TagTranslation"> | string
    createdAt?: DateTimeFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TagTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "lang_tagId">

  export type TagTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagTranslationCountOrderByAggregateInput
    _max?: TagTranslationMaxOrderByAggregateInput
    _min?: TagTranslationMinOrderByAggregateInput
  }

  export type TagTranslationScalarWhereWithAggregatesInput = {
    AND?: TagTranslationScalarWhereWithAggregatesInput | TagTranslationScalarWhereWithAggregatesInput[]
    OR?: TagTranslationScalarWhereWithAggregatesInput[]
    NOT?: TagTranslationScalarWhereWithAggregatesInput | TagTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TagTranslation"> | string
    lang?: StringWithAggregatesFilter<"TagTranslation"> | string
    tagId?: StringWithAggregatesFilter<"TagTranslation"> | string
    name?: StringWithAggregatesFilter<"TagTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TagTranslation"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    articleId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    translations?: CommentTranslationListRelationFilter
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: CommentTranslationOrderByRelationAggregateInput
    article?: ArticleOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    articleId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    translations?: CommentTranslationListRelationFilter
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    articleId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type CommentTranslationWhereInput = {
    AND?: CommentTranslationWhereInput | CommentTranslationWhereInput[]
    OR?: CommentTranslationWhereInput[]
    NOT?: CommentTranslationWhereInput | CommentTranslationWhereInput[]
    id?: StringFilter<"CommentTranslation"> | string
    lang?: StringFilter<"CommentTranslation"> | string
    userId?: StringNullableFilter<"CommentTranslation"> | string | null
    name?: StringNullableFilter<"CommentTranslation"> | string | null
    body?: StringFilter<"CommentTranslation"> | string
    commentId?: StringFilter<"CommentTranslation"> | string
    createdAt?: DateTimeFilter<"CommentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CommentTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type CommentTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    body?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type CommentTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_commentId?: CommentTranslationLangCommentIdCompoundUniqueInput
    AND?: CommentTranslationWhereInput | CommentTranslationWhereInput[]
    OR?: CommentTranslationWhereInput[]
    NOT?: CommentTranslationWhereInput | CommentTranslationWhereInput[]
    lang?: StringFilter<"CommentTranslation"> | string
    userId?: StringNullableFilter<"CommentTranslation"> | string | null
    name?: StringNullableFilter<"CommentTranslation"> | string | null
    body?: StringFilter<"CommentTranslation"> | string
    commentId?: StringFilter<"CommentTranslation"> | string
    createdAt?: DateTimeFilter<"CommentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CommentTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }, "id" | "lang_commentId">

  export type CommentTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    body?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentTranslationCountOrderByAggregateInput
    _max?: CommentTranslationMaxOrderByAggregateInput
    _min?: CommentTranslationMinOrderByAggregateInput
  }

  export type CommentTranslationScalarWhereWithAggregatesInput = {
    AND?: CommentTranslationScalarWhereWithAggregatesInput | CommentTranslationScalarWhereWithAggregatesInput[]
    OR?: CommentTranslationScalarWhereWithAggregatesInput[]
    NOT?: CommentTranslationScalarWhereWithAggregatesInput | CommentTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentTranslation"> | string
    lang?: StringWithAggregatesFilter<"CommentTranslation"> | string
    userId?: StringNullableWithAggregatesFilter<"CommentTranslation"> | string | null
    name?: StringNullableWithAggregatesFilter<"CommentTranslation"> | string | null
    body?: StringWithAggregatesFilter<"CommentTranslation"> | string
    commentId?: StringWithAggregatesFilter<"CommentTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommentTranslation"> | Date | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: StringFilter<"Block"> | string
    type?: StringNullableFilter<"Block"> | string | null
    content?: JsonNullableFilter<"Block">
    pageId?: StringNullableFilter<"Block"> | string | null
    articleId?: StringNullableFilter<"Block"> | string | null
    categoryServiceId?: StringNullableFilter<"Block"> | string | null
    serviceId?: StringNullableFilter<"Block"> | string | null
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
    Page?: XOR<PageTranslationNullableRelationFilter, PageTranslationWhereInput> | null
    article?: XOR<ArticleTranslationNullableRelationFilter, ArticleTranslationWhereInput> | null
    categoryService?: XOR<CategoryServiceTranslationNullableRelationFilter, CategoryServiceTranslationWhereInput> | null
    service?: XOR<ServiceTranslationNullableRelationFilter, ServiceTranslationWhereInput> | null
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    articleId?: SortOrderInput | SortOrder
    categoryServiceId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Page?: PageTranslationOrderByWithRelationInput
    article?: ArticleTranslationOrderByWithRelationInput
    categoryService?: CategoryServiceTranslationOrderByWithRelationInput
    service?: ServiceTranslationOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    type?: StringNullableFilter<"Block"> | string | null
    content?: JsonNullableFilter<"Block">
    pageId?: StringNullableFilter<"Block"> | string | null
    articleId?: StringNullableFilter<"Block"> | string | null
    categoryServiceId?: StringNullableFilter<"Block"> | string | null
    serviceId?: StringNullableFilter<"Block"> | string | null
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
    Page?: XOR<PageTranslationNullableRelationFilter, PageTranslationWhereInput> | null
    article?: XOR<ArticleTranslationNullableRelationFilter, ArticleTranslationWhereInput> | null
    categoryService?: XOR<CategoryServiceTranslationNullableRelationFilter, CategoryServiceTranslationWhereInput> | null
    service?: XOR<ServiceTranslationNullableRelationFilter, ServiceTranslationWhereInput> | null
  }, "id">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    articleId?: SortOrderInput | SortOrder
    categoryServiceId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Block"> | string
    type?: StringNullableWithAggregatesFilter<"Block"> | string | null
    content?: JsonNullableWithAggregatesFilter<"Block">
    pageId?: StringNullableWithAggregatesFilter<"Block"> | string | null
    articleId?: StringNullableWithAggregatesFilter<"Block"> | string | null
    categoryServiceId?: StringNullableWithAggregatesFilter<"Block"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"Block"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type CategoryServiceWhereInput = {
    AND?: CategoryServiceWhereInput | CategoryServiceWhereInput[]
    OR?: CategoryServiceWhereInput[]
    NOT?: CategoryServiceWhereInput | CategoryServiceWhereInput[]
    id?: StringFilter<"CategoryService"> | string
    published?: BoolFilter<"CategoryService"> | boolean
    createdAt?: DateTimeFilter<"CategoryService"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryService"> | Date | string
    services?: ServiceListRelationFilter
    translations?: CategoryServiceTranslationListRelationFilter
  }

  export type CategoryServiceOrderByWithRelationInput = {
    id?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    translations?: CategoryServiceTranslationOrderByRelationAggregateInput
  }

  export type CategoryServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryServiceWhereInput | CategoryServiceWhereInput[]
    OR?: CategoryServiceWhereInput[]
    NOT?: CategoryServiceWhereInput | CategoryServiceWhereInput[]
    published?: BoolFilter<"CategoryService"> | boolean
    createdAt?: DateTimeFilter<"CategoryService"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryService"> | Date | string
    services?: ServiceListRelationFilter
    translations?: CategoryServiceTranslationListRelationFilter
  }, "id">

  export type CategoryServiceOrderByWithAggregationInput = {
    id?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryServiceCountOrderByAggregateInput
    _max?: CategoryServiceMaxOrderByAggregateInput
    _min?: CategoryServiceMinOrderByAggregateInput
  }

  export type CategoryServiceScalarWhereWithAggregatesInput = {
    AND?: CategoryServiceScalarWhereWithAggregatesInput | CategoryServiceScalarWhereWithAggregatesInput[]
    OR?: CategoryServiceScalarWhereWithAggregatesInput[]
    NOT?: CategoryServiceScalarWhereWithAggregatesInput | CategoryServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryService"> | string
    published?: BoolWithAggregatesFilter<"CategoryService"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CategoryService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryService"> | Date | string
  }

  export type CategoryServiceTranslationWhereInput = {
    AND?: CategoryServiceTranslationWhereInput | CategoryServiceTranslationWhereInput[]
    OR?: CategoryServiceTranslationWhereInput[]
    NOT?: CategoryServiceTranslationWhereInput | CategoryServiceTranslationWhereInput[]
    id?: StringFilter<"CategoryServiceTranslation"> | string
    lang?: StringFilter<"CategoryServiceTranslation"> | string
    name?: StringFilter<"CategoryServiceTranslation"> | string
    descriprion?: StringNullableFilter<"CategoryServiceTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryServiceTranslation">
    categoryServiceId?: StringFilter<"CategoryServiceTranslation"> | string
    published?: BoolFilter<"CategoryServiceTranslation"> | boolean
    createdAt?: DateTimeFilter<"CategoryServiceTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryServiceTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    categoryService?: XOR<CategoryServiceRelationFilter, CategoryServiceWhereInput>
    blocks?: BlockListRelationFilter
  }

  export type CategoryServiceTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    descriprion?: SortOrderInput | SortOrder
    images?: SortOrder
    categoryServiceId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    categoryService?: CategoryServiceOrderByWithRelationInput
    blocks?: BlockOrderByRelationAggregateInput
  }

  export type CategoryServiceTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_categoryServiceId?: CategoryServiceTranslationLangCategoryServiceIdCompoundUniqueInput
    AND?: CategoryServiceTranslationWhereInput | CategoryServiceTranslationWhereInput[]
    OR?: CategoryServiceTranslationWhereInput[]
    NOT?: CategoryServiceTranslationWhereInput | CategoryServiceTranslationWhereInput[]
    lang?: StringFilter<"CategoryServiceTranslation"> | string
    name?: StringFilter<"CategoryServiceTranslation"> | string
    descriprion?: StringNullableFilter<"CategoryServiceTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryServiceTranslation">
    categoryServiceId?: StringFilter<"CategoryServiceTranslation"> | string
    published?: BoolFilter<"CategoryServiceTranslation"> | boolean
    createdAt?: DateTimeFilter<"CategoryServiceTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryServiceTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    categoryService?: XOR<CategoryServiceRelationFilter, CategoryServiceWhereInput>
    blocks?: BlockListRelationFilter
  }, "id" | "lang_categoryServiceId">

  export type CategoryServiceTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    descriprion?: SortOrderInput | SortOrder
    images?: SortOrder
    categoryServiceId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryServiceTranslationCountOrderByAggregateInput
    _max?: CategoryServiceTranslationMaxOrderByAggregateInput
    _min?: CategoryServiceTranslationMinOrderByAggregateInput
  }

  export type CategoryServiceTranslationScalarWhereWithAggregatesInput = {
    AND?: CategoryServiceTranslationScalarWhereWithAggregatesInput | CategoryServiceTranslationScalarWhereWithAggregatesInput[]
    OR?: CategoryServiceTranslationScalarWhereWithAggregatesInput[]
    NOT?: CategoryServiceTranslationScalarWhereWithAggregatesInput | CategoryServiceTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryServiceTranslation"> | string
    lang?: StringWithAggregatesFilter<"CategoryServiceTranslation"> | string
    name?: StringWithAggregatesFilter<"CategoryServiceTranslation"> | string
    descriprion?: StringNullableWithAggregatesFilter<"CategoryServiceTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryServiceTranslation">
    categoryServiceId?: StringWithAggregatesFilter<"CategoryServiceTranslation"> | string
    published?: BoolWithAggregatesFilter<"CategoryServiceTranslation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CategoryServiceTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryServiceTranslation"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    categoryId?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    CategoryService?: XOR<CategoryServiceRelationFilter, CategoryServiceWhereInput>
    translations?: ServiceTranslationListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CategoryService?: CategoryServiceOrderByWithRelationInput
    translations?: ServiceTranslationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    categoryId?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    CategoryService?: XOR<CategoryServiceRelationFilter, CategoryServiceWhereInput>
    translations?: ServiceTranslationListRelationFilter
    orders?: OrderListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    categoryId?: StringWithAggregatesFilter<"Service"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServiceTranslationWhereInput = {
    AND?: ServiceTranslationWhereInput | ServiceTranslationWhereInput[]
    OR?: ServiceTranslationWhereInput[]
    NOT?: ServiceTranslationWhereInput | ServiceTranslationWhereInput[]
    id?: StringFilter<"ServiceTranslation"> | string
    lang?: StringFilter<"ServiceTranslation"> | string
    name?: StringFilter<"ServiceTranslation"> | string
    description?: StringNullableFilter<"ServiceTranslation"> | string | null
    serviceId?: StringFilter<"ServiceTranslation"> | string
    createdAt?: DateTimeFilter<"ServiceTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    blocks?: BlockListRelationFilter
  }

  export type ServiceTranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    blocks?: BlockOrderByRelationAggregateInput
  }

  export type ServiceTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lang_serviceId?: ServiceTranslationLangServiceIdCompoundUniqueInput
    AND?: ServiceTranslationWhereInput | ServiceTranslationWhereInput[]
    OR?: ServiceTranslationWhereInput[]
    NOT?: ServiceTranslationWhereInput | ServiceTranslationWhereInput[]
    lang?: StringFilter<"ServiceTranslation"> | string
    name?: StringFilter<"ServiceTranslation"> | string
    description?: StringNullableFilter<"ServiceTranslation"> | string | null
    serviceId?: StringFilter<"ServiceTranslation"> | string
    createdAt?: DateTimeFilter<"ServiceTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTranslation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    blocks?: BlockListRelationFilter
  }, "id" | "lang_serviceId">

  export type ServiceTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTranslationCountOrderByAggregateInput
    _max?: ServiceTranslationMaxOrderByAggregateInput
    _min?: ServiceTranslationMinOrderByAggregateInput
  }

  export type ServiceTranslationScalarWhereWithAggregatesInput = {
    AND?: ServiceTranslationScalarWhereWithAggregatesInput | ServiceTranslationScalarWhereWithAggregatesInput[]
    OR?: ServiceTranslationScalarWhereWithAggregatesInput[]
    NOT?: ServiceTranslationScalarWhereWithAggregatesInput | ServiceTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceTranslation"> | string
    lang?: StringWithAggregatesFilter<"ServiceTranslation"> | string
    name?: StringWithAggregatesFilter<"ServiceTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceTranslation"> | string | null
    serviceId?: StringWithAggregatesFilter<"ServiceTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTranslation"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    name?: StringNullableFilter<"Order"> | string | null
    email?: StringNullableFilter<"Order"> | string | null
    phone?: StringNullableFilter<"Order"> | string | null
    studentId?: StringNullableFilter<"Order"> | string | null
    serviceId?: StringNullableFilter<"Order"> | string | null
    DescriptionOtherService?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    student?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    DescriptionOtherService?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    name?: StringNullableFilter<"Order"> | string | null
    email?: StringNullableFilter<"Order"> | string | null
    phone?: StringNullableFilter<"Order"> | string | null
    studentId?: StringNullableFilter<"Order"> | string | null
    serviceId?: StringNullableFilter<"Order"> | string | null
    DescriptionOtherService?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    student?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    DescriptionOtherService?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    name?: StringNullableWithAggregatesFilter<"Order"> | string | null
    email?: StringNullableWithAggregatesFilter<"Order"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Order"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    DescriptionOtherService?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
  }

  export type GlobalCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GlobalTranslationCreateNestedManyWithoutGlobalInput
    socialLinks?: SocialLinkCreateNestedManyWithoutGlobalInput
  }

  export type GlobalUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GlobalTranslationUncheckedCreateNestedManyWithoutGlobalInput
    socialLinks?: SocialLinkUncheckedCreateNestedManyWithoutGlobalInput
  }

  export type GlobalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GlobalTranslationUpdateManyWithoutGlobalNestedInput
    socialLinks?: SocialLinkUpdateManyWithoutGlobalNestedInput
  }

  export type GlobalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GlobalTranslationUncheckedUpdateManyWithoutGlobalNestedInput
    socialLinks?: SocialLinkUncheckedUpdateManyWithoutGlobalNestedInput
  }

  export type GlobalCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationCreateInput = {
    id?: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutGlobalsInput
    global: GlobalCreateNestedOneWithoutTranslationsInput
  }

  export type GlobalTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    globalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutGlobalsNestedInput
    global?: GlobalUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type GlobalTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    globalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationCreateManyInput = {
    id?: string
    lang: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    globalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    globalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkCreateInput = {
    id?: string
    social: string
    url: string
    global?: GlobalCreateNestedOneWithoutSocialLinksInput
  }

  export type SocialLinkUncheckedCreateInput = {
    id?: string
    social: string
    url: string
    globalId?: string | null
  }

  export type SocialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    global?: GlobalUpdateOneWithoutSocialLinksNestedInput
  }

  export type SocialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    globalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLinkCreateManyInput = {
    id?: string
    social: string
    url: string
    globalId?: string | null
  }

  export type SocialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    globalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NavbarItemCreateInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutNavItemInput
    page?: PageCreateNestedOneWithoutNavbarItemInput
    article?: ArticleCreateNestedOneWithoutNavbarItemInput
  }

  export type NavbarItemUncheckedCreateInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: string | null
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationUncheckedCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupUncheckedCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutNavItemInput
  }

  export type NavbarItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutNavItemNestedInput
    page?: PageUpdateOneWithoutNavbarItemNestedInput
    article?: ArticleUpdateOneWithoutNavbarItemNestedInput
  }

  export type NavbarItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUncheckedUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutNavItemNestedInput
  }

  export type NavbarItemCreateManyInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: string | null
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemTranslationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutNavbarItemsInput
    navbarItem?: NavbarItemCreateNestedOneWithoutTranslationsInput
  }

  export type NavbarItemTranslationUncheckedCreateInput = {
    id?: string
    name: string
    lang: string
    navbarItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutNavbarItemsNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutTranslationsNestedInput
  }

  export type NavbarItemTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    navbarItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemTranslationCreateManyInput = {
    id?: string
    name: string
    lang: string
    navbarItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    navbarItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropDownGroupTranslationCreateNestedManyWithoutDropdownGroupInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownGroupsInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutGroupInput
  }

  export type DropDownGroupUncheckedCreateInput = {
    id?: string
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutDropdownGroupInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutGroupInput
  }

  export type DropDownGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropDownGroupTranslationUpdateManyWithoutDropdownGroupNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownGroupsNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutGroupNestedInput
  }

  export type DropDownGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropDownGroupTranslationUncheckedUpdateManyWithoutDropdownGroupNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type DropDownGroupCreateManyInput = {
    id?: string
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutDropdownGroupsInput
    dropdownGroup?: DropDownGroupCreateNestedOneWithoutTranslationsInput
  }

  export type DropDownGroupTranslationUncheckedCreateInput = {
    id?: string
    name: string
    lang: string
    dropdownGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutDropdownGroupsNestedInput
    dropdownGroup?: DropDownGroupUpdateOneWithoutTranslationsNestedInput
  }

  export type DropDownGroupTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    dropdownGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationCreateManyInput = {
    id?: string
    name: string
    lang: string
    dropdownGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    dropdownGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemCreateInput = {
    id?: string
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationCreateNestedManyWithoutDropdownItemInput
    group?: DropDownGroupCreateNestedOneWithoutDropdownItemsInput
    page?: PageCreateNestedOneWithoutDropdownItemInput
    article?: ArticleCreateNestedOneWithoutDropdownItemInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownItemsInput
  }

  export type DropdownItemUncheckedCreateInput = {
    id?: string
    groupId?: string | null
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationUncheckedCreateNestedManyWithoutDropdownItemInput
  }

  export type DropdownItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUpdateManyWithoutDropdownItemNestedInput
    group?: DropDownGroupUpdateOneWithoutDropdownItemsNestedInput
    page?: PageUpdateOneWithoutDropdownItemNestedInput
    article?: ArticleUpdateOneWithoutDropdownItemNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownItemsNestedInput
  }

  export type DropdownItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemNestedInput
  }

  export type DropdownItemCreateManyInput = {
    id?: string
    groupId?: string | null
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutDropdownItemsInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutTranslationsInput
  }

  export type DropdownItemTranslationUncheckedCreateInput = {
    id?: string
    name: string
    lang: string
    dropdownItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutDropdownItemsNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutTranslationsNestedInput
  }

  export type DropdownItemTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    dropdownItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationCreateManyInput = {
    id?: string
    name: string
    lang: string
    dropdownItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    dropdownItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: FooterTranslationCreateNestedManyWithoutFooterInput
    groups?: GroupFooterCreateNestedManyWithoutFooterInput
    articles?: ArticleCreateNestedManyWithoutFooterInput
  }

  export type FooterUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: FooterTranslationUncheckedCreateNestedManyWithoutFooterInput
    groups?: GroupFooterUncheckedCreateNestedManyWithoutFooterInput
    articles?: ArticleUncheckedCreateNestedManyWithoutFooterInput
  }

  export type FooterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: FooterTranslationUpdateManyWithoutFooterNestedInput
    groups?: GroupFooterUpdateManyWithoutFooterNestedInput
    articles?: ArticleUpdateManyWithoutFooterNestedInput
  }

  export type FooterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: FooterTranslationUncheckedUpdateManyWithoutFooterNestedInput
    groups?: GroupFooterUncheckedUpdateManyWithoutFooterNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutFooterNestedInput
  }

  export type FooterCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutFootersInput
    footer?: FooterCreateNestedOneWithoutTranslationsInput
  }

  export type FooterTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutFootersNestedInput
    footer?: FooterUpdateOneWithoutTranslationsNestedInput
  }

  export type FooterTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationCreateManyInput = {
    id?: string
    lang: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationCreateNestedManyWithoutGroupfooterInput
    footer?: FooterCreateNestedOneWithoutGroupsInput
    articles?: ArticleCreateNestedManyWithoutGroupfooterInput
    pages?: PageCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterUncheckedCreateInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationUncheckedCreateNestedManyWithoutGroupfooterInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupfooterInput
    pages?: PageUncheckedCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUpdateManyWithoutGroupfooterNestedInput
    footer?: FooterUpdateOneWithoutGroupsNestedInput
    articles?: ArticleUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUpdateManyWithoutGroupFooterNestedInput
  }

  export type GroupFooterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUncheckedUpdateManyWithoutGroupFooterNestedInput
  }

  export type GroupFooterCreateManyInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterTranslationCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupfooter?: GroupFooterCreateNestedOneWithoutTranslationsInput
    language: LanguageCreateNestedOneWithoutGroupFootersInput
  }

  export type GroupFooterTranslationUncheckedCreateInput = {
    id?: string
    title?: string | null
    groupfooterId?: string | null
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupfooter?: GroupFooterUpdateOneWithoutTranslationsNestedInput
    language?: LanguageUpdateOneRequiredWithoutGroupFootersNestedInput
  }

  export type GroupFooterTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterTranslationCreateManyInput = {
    id?: string
    title?: string | null
    groupfooterId?: string | null
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    navbarItem?: NavbarItemCreateNestedOneWithoutPageInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutPageInput
    groupFooter?: GroupFooterCreateNestedOneWithoutPagesInput
  }

  export type PageUncheckedCreateInput = {
    id?: string
    groupFooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutPageInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutPageNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutPageNestedInput
    groupFooter?: GroupFooterUpdateOneWithoutPagesNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupFooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutPageNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutPageNestedInput
  }

  export type PageCreateManyInput = {
    id?: string
    groupFooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupFooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationCreateInput = {
    id?: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutPagesInput
    author: UserCreateNestedOneWithoutPagesInput
    blocks?: BlockCreateNestedManyWithoutPageInput
    page: PageCreateNestedOneWithoutTranslationsInput
  }

  export type PageTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutPagesNestedInput
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    blocks?: BlockUpdateManyWithoutPageNestedInput
    page?: PageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PageTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageTranslationCreateManyInput = {
    id?: string
    lang: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
    articles?: ArticleCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
    articles?: ArticleUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationCreateInput = {
    id?: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCategoreisInput
    author: UserCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutTranslationsInput
  }

  export type CategoryTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    userId: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCategoreisNestedInput
    author?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CategoryTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationCreateManyInput = {
    id?: string
    lang: string
    userId: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
  }

  export type ArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleTranslationCreateInput = {
    id?: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutArticlesInput
    article: ArticleCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationCreateManyInput = {
    id?: string
    lang: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TagTranslationCreateNestedManyWithoutTagInput
    articles?: ArticleCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TagTranslationUncheckedCreateNestedManyWithoutTagInput
    articles?: ArticleUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TagTranslationUpdateManyWithoutTagNestedInput
    articles?: ArticleUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TagTranslationUncheckedUpdateManyWithoutTagNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutTranslationsInput
  }

  export type TagTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    tagId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TagTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationCreateManyInput = {
    id?: string
    lang: string
    tagId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CommentTranslationCreateNestedManyWithoutCommentInput
    article: ArticleCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CommentTranslationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CommentTranslationUpdateManyWithoutCommentNestedInput
    article?: ArticleUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CommentTranslationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationCreateInput = {
    id?: string
    name?: string | null
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCommentsInput
    author?: UserCreateNestedOneWithoutCommentInput
    comment: CommentCreateNestedOneWithoutTranslationsInput
  }

  export type CommentTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    userId?: string | null
    name?: string | null
    body: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneWithoutCommentNestedInput
    comment?: CommentUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CommentTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationCreateManyInput = {
    id?: string
    lang: string
    userId?: string | null
    name?: string | null
    body: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Page?: PageTranslationCreateNestedOneWithoutBlocksInput
    article?: ArticleTranslationCreateNestedOneWithoutBlocksInput
    categoryService?: CategoryServiceTranslationCreateNestedOneWithoutBlocksInput
    service?: ServiceTranslationCreateNestedOneWithoutBlocksInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    articleId?: string | null
    categoryServiceId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Page?: PageTranslationUpdateOneWithoutBlocksNestedInput
    article?: ArticleTranslationUpdateOneWithoutBlocksNestedInput
    categoryService?: CategoryServiceTranslationUpdateOneWithoutBlocksNestedInput
    service?: ServiceTranslationUpdateOneWithoutBlocksNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    articleId?: string | null
    categoryServiceId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceCreateInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryServiceInput
    translations?: CategoryServiceTranslationCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceUncheckedCreateInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryServiceInput
    translations?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryServiceNestedInput
    translations?: CategoryServiceTranslationUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryServiceNestedInput
    translations?: CategoryServiceTranslationUncheckedUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceCreateManyInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceTranslationCreateInput = {
    id?: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCategoriesServicesInput
    categoryService: CategoryServiceCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    categoryServiceId: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCategoriesServicesNestedInput
    categoryService?: CategoryServiceUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    categoryServiceId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceTranslationCreateManyInput = {
    id?: string
    lang: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    categoryServiceId: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryServiceTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    categoryServiceId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CategoryService: CategoryServiceCreateNestedOneWithoutServicesInput
    translations?: ServiceTranslationCreateNestedManyWithoutServiceInput
    orders?: OrderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ServiceTranslationUncheckedCreateNestedManyWithoutServiceInput
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CategoryService?: CategoryServiceUpdateOneRequiredWithoutServicesNestedInput
    translations?: ServiceTranslationUpdateManyWithoutServiceNestedInput
    orders?: OrderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ServiceTranslationUncheckedUpdateManyWithoutServiceNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTranslationCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutServiceInput
  }

  export type ServiceTranslationUncheckedCreateInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTranslationCreateManyInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: UserCreateNestedOneWithoutOrdersInput
    service?: ServiceCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    studentId?: string | null
    serviceId?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneWithoutOrdersNestedInput
    service?: ServiceUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    studentId?: string | null
    serviceId?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PageTranslationListRelationFilter = {
    every?: PageTranslationWhereInput
    some?: PageTranslationWhereInput
    none?: PageTranslationWhereInput
  }

  export type ArticleTranslationListRelationFilter = {
    every?: ArticleTranslationWhereInput
    some?: ArticleTranslationWhereInput
    none?: ArticleTranslationWhereInput
  }

  export type CategoryTranslationListRelationFilter = {
    every?: CategoryTranslationWhereInput
    some?: CategoryTranslationWhereInput
    none?: CategoryTranslationWhereInput
  }

  export type CommentTranslationListRelationFilter = {
    every?: CommentTranslationWhereInput
    some?: CommentTranslationWhereInput
    none?: CommentTranslationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type GlobalTranslationListRelationFilter = {
    every?: GlobalTranslationWhereInput
    some?: GlobalTranslationWhereInput
    none?: GlobalTranslationWhereInput
  }

  export type CategoryServiceTranslationListRelationFilter = {
    every?: CategoryServiceTranslationWhereInput
    some?: CategoryServiceTranslationWhereInput
    none?: CategoryServiceTranslationWhereInput
  }

  export type ServiceTranslationListRelationFilter = {
    every?: ServiceTranslationWhereInput
    some?: ServiceTranslationWhereInput
    none?: ServiceTranslationWhereInput
  }

  export type TagTranslationListRelationFilter = {
    every?: TagTranslationWhereInput
    some?: TagTranslationWhereInput
    none?: TagTranslationWhereInput
  }

  export type NavbarItemTranslationListRelationFilter = {
    every?: NavbarItemTranslationWhereInput
    some?: NavbarItemTranslationWhereInput
    none?: NavbarItemTranslationWhereInput
  }

  export type DropDownGroupTranslationListRelationFilter = {
    every?: DropDownGroupTranslationWhereInput
    some?: DropDownGroupTranslationWhereInput
    none?: DropDownGroupTranslationWhereInput
  }

  export type DropdownItemTranslationListRelationFilter = {
    every?: DropdownItemTranslationWhereInput
    some?: DropdownItemTranslationWhereInput
    none?: DropdownItemTranslationWhereInput
  }

  export type FooterTranslationListRelationFilter = {
    every?: FooterTranslationWhereInput
    some?: FooterTranslationWhereInput
    none?: FooterTranslationWhereInput
  }

  export type GroupFooterTranslationListRelationFilter = {
    every?: GroupFooterTranslationWhereInput
    some?: GroupFooterTranslationWhereInput
    none?: GroupFooterTranslationWhereInput
  }

  export type GlobalTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryServiceTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NavbarItemTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DropDownGroupTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DropdownItemTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FooterTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupFooterTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    language?: SortOrder
    common?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    language?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    language?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SocialLinkListRelationFilter = {
    every?: SocialLinkWhereInput
    some?: SocialLinkWhereInput
    none?: SocialLinkWhereInput
  }

  export type SocialLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GlobalCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type GlobalRelationFilter = {
    is?: GlobalWhereInput
    isNot?: GlobalWhereInput
  }

  export type GlobalTranslationLangGlobalIdCompoundUniqueInput = {
    lang: string
    globalId: string
  }

  export type GlobalTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    images?: SortOrder
    description?: SortOrder
    globalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    description?: SortOrder
    globalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    description?: SortOrder
    globalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalNullableRelationFilter = {
    is?: GlobalWhereInput | null
    isNot?: GlobalWhereInput | null
  }

  export type SocialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    social?: SortOrder
    url?: SortOrder
    globalId?: SortOrder
  }

  export type SocialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    social?: SortOrder
    url?: SortOrder
    globalId?: SortOrder
  }

  export type SocialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    social?: SortOrder
    url?: SortOrder
    globalId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DropDownGroupListRelationFilter = {
    every?: DropDownGroupWhereInput
    some?: DropDownGroupWhereInput
    none?: DropDownGroupWhereInput
  }

  export type DropdownItemListRelationFilter = {
    every?: DropdownItemWhereInput
    some?: DropdownItemWhereInput
    none?: DropdownItemWhereInput
  }

  export type PageNullableRelationFilter = {
    is?: PageWhereInput | null
    isNot?: PageWhereInput | null
  }

  export type ArticleNullableRelationFilter = {
    is?: ArticleWhereInput | null
    isNot?: ArticleWhereInput | null
  }

  export type DropDownGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DropdownItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NavbarItemPageIdArticleIdCompoundUniqueInput = {
    pageId: string
    articleId: string
  }

  export type NavbarItemCountOrderByAggregateInput = {
    id?: SortOrder
    isDropdown?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavbarItemMaxOrderByAggregateInput = {
    id?: SortOrder
    isDropdown?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavbarItemMinOrderByAggregateInput = {
    id?: SortOrder
    isDropdown?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NavbarItemNullableRelationFilter = {
    is?: NavbarItemWhereInput | null
    isNot?: NavbarItemWhereInput | null
  }

  export type NavbarItemTranslationLangNavbarItemIdCompoundUniqueInput = {
    lang: string
    navbarItemId: string
  }

  export type NavbarItemTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    navbarItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavbarItemTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    navbarItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavbarItemTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    navbarItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropDownGroupCountOrderByAggregateInput = {
    id?: SortOrder
    navItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropDownGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    navItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropDownGroupMinOrderByAggregateInput = {
    id?: SortOrder
    navItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropDownGroupNullableRelationFilter = {
    is?: DropDownGroupWhereInput | null
    isNot?: DropDownGroupWhereInput | null
  }

  export type DropDownGroupTranslationLangDropdownGroupIdCompoundUniqueInput = {
    lang: string
    dropdownGroupId: string
  }

  export type DropDownGroupTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropDownGroupTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropDownGroupTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownItemCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    pageId?: SortOrder
    forGroup?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    articleId?: SortOrder
    navItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownItemMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    pageId?: SortOrder
    forGroup?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    articleId?: SortOrder
    navItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownItemMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    pageId?: SortOrder
    forGroup?: SortOrder
    forArticle?: SortOrder
    forPage?: SortOrder
    articleId?: SortOrder
    navItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownItemNullableRelationFilter = {
    is?: DropdownItemWhereInput | null
    isNot?: DropdownItemWhereInput | null
  }

  export type DropdownItemTranslationLangDropdownItemIdCompoundUniqueInput = {
    lang: string
    dropdownItemId: string
  }

  export type DropdownItemTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownItemTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownItemTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lang?: SortOrder
    dropdownItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupFooterListRelationFilter = {
    every?: GroupFooterWhereInput
    some?: GroupFooterWhereInput
    none?: GroupFooterWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type GroupFooterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FooterCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterNullableRelationFilter = {
    is?: FooterWhereInput | null
    isNot?: FooterWhereInput | null
  }

  export type FooterTranslationLangFooterIdCompoundUniqueInput = {
    lang: string
    footerId: string
  }

  export type FooterTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    footerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    footerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    footerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupFooterCountOrderByAggregateInput = {
    id?: SortOrder
    footerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupFooterMaxOrderByAggregateInput = {
    id?: SortOrder
    footerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupFooterMinOrderByAggregateInput = {
    id?: SortOrder
    footerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupFooterNullableRelationFilter = {
    is?: GroupFooterWhereInput | null
    isNot?: GroupFooterWhereInput | null
  }

  export type GroupFooterTranslationLangGroupfooterIdCompoundUniqueInput = {
    lang: string
    groupfooterId: string
  }

  export type GroupFooterTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    groupfooterId?: SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupFooterTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    groupfooterId?: SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupFooterTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    groupfooterId?: SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    groupFooterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    groupFooterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    groupFooterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type PageRelationFilter = {
    is?: PageWhereInput
    isNot?: PageWhereInput
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageTranslationLangPageIdCompoundUniqueInput = {
    lang: string
    pageId: string
  }

  export type PageTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    images?: SortOrder
    published?: SortOrder
    pageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    published?: SortOrder
    pageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    published?: SortOrder
    pageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CategoryTranslationLangCategoryIdCompoundUniqueInput = {
    lang: string
    categoryId: string
  }

  export type CategoryTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    footerId?: SortOrder
    groupfooterId?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    footerId?: SortOrder
    groupfooterId?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    footerId?: SortOrder
    groupfooterId?: SortOrder
  }

  export type ArticleRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type ArticleTranslationLangArticleIdCompoundUniqueInput = {
    lang: string
    articleId: string
  }

  export type ArticleTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    published?: SortOrder
    title?: SortOrder
    description?: SortOrder
    articleId?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    published?: SortOrder
    title?: SortOrder
    description?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    published?: SortOrder
    title?: SortOrder
    description?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TagTranslationLangTagIdCompoundUniqueInput = {
    lang: string
    tagId: string
  }

  export type TagTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentTranslationLangCommentIdCompoundUniqueInput = {
    lang: string
    commentId: string
  }

  export type CommentTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    body?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    body?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    body?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PageTranslationNullableRelationFilter = {
    is?: PageTranslationWhereInput | null
    isNot?: PageTranslationWhereInput | null
  }

  export type ArticleTranslationNullableRelationFilter = {
    is?: ArticleTranslationWhereInput | null
    isNot?: ArticleTranslationWhereInput | null
  }

  export type CategoryServiceTranslationNullableRelationFilter = {
    is?: CategoryServiceTranslationWhereInput | null
    isNot?: CategoryServiceTranslationWhereInput | null
  }

  export type ServiceTranslationNullableRelationFilter = {
    is?: ServiceTranslationWhereInput | null
    isNot?: ServiceTranslationWhereInput | null
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    categoryServiceId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    categoryServiceId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    categoryServiceId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryServiceCountOrderByAggregateInput = {
    id?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryServiceMinOrderByAggregateInput = {
    id?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryServiceRelationFilter = {
    is?: CategoryServiceWhereInput
    isNot?: CategoryServiceWhereInput
  }

  export type CategoryServiceTranslationLangCategoryServiceIdCompoundUniqueInput = {
    lang: string
    categoryServiceId: string
  }

  export type CategoryServiceTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    descriprion?: SortOrder
    images?: SortOrder
    categoryServiceId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryServiceTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    descriprion?: SortOrder
    categoryServiceId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryServiceTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    descriprion?: SortOrder
    categoryServiceId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceTranslationLangServiceIdCompoundUniqueInput = {
    lang: string
    serviceId: string
  }

  export type ServiceTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    description?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    description?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    description?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    studentId?: SortOrder
    serviceId?: SortOrder
    DescriptionOtherService?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    studentId?: SortOrder
    serviceId?: SortOrder
    DescriptionOtherService?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    studentId?: SortOrder
    serviceId?: SortOrder
    DescriptionOtherService?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PageTranslationCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PageTranslationCreateWithoutAuthorInput, PageTranslationUncheckedCreateWithoutAuthorInput> | PageTranslationCreateWithoutAuthorInput[] | PageTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutAuthorInput | PageTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: PageTranslationCreateManyAuthorInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type ArticleTranslationCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleTranslationCreateWithoutAuthorInput, ArticleTranslationUncheckedCreateWithoutAuthorInput> | ArticleTranslationCreateWithoutAuthorInput[] | ArticleTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutAuthorInput | ArticleTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleTranslationCreateManyAuthorInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type CategoryTranslationCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CategoryTranslationCreateWithoutAuthorInput, CategoryTranslationUncheckedCreateWithoutAuthorInput> | CategoryTranslationCreateWithoutAuthorInput[] | CategoryTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutAuthorInput | CategoryTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: CategoryTranslationCreateManyAuthorInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type CommentTranslationCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentTranslationCreateWithoutAuthorInput, CommentTranslationUncheckedCreateWithoutAuthorInput> | CommentTranslationCreateWithoutAuthorInput[] | CommentTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutAuthorInput | CommentTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentTranslationCreateManyAuthorInputEnvelope
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutStudentInput = {
    create?: XOR<OrderCreateWithoutStudentInput, OrderUncheckedCreateWithoutStudentInput> | OrderCreateWithoutStudentInput[] | OrderUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStudentInput | OrderCreateOrConnectWithoutStudentInput[]
    createMany?: OrderCreateManyStudentInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PageTranslationUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PageTranslationCreateWithoutAuthorInput, PageTranslationUncheckedCreateWithoutAuthorInput> | PageTranslationCreateWithoutAuthorInput[] | PageTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutAuthorInput | PageTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: PageTranslationCreateManyAuthorInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleTranslationCreateWithoutAuthorInput, ArticleTranslationUncheckedCreateWithoutAuthorInput> | ArticleTranslationCreateWithoutAuthorInput[] | ArticleTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutAuthorInput | ArticleTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleTranslationCreateManyAuthorInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CategoryTranslationCreateWithoutAuthorInput, CategoryTranslationUncheckedCreateWithoutAuthorInput> | CategoryTranslationCreateWithoutAuthorInput[] | CategoryTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutAuthorInput | CategoryTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: CategoryTranslationCreateManyAuthorInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentTranslationCreateWithoutAuthorInput, CommentTranslationUncheckedCreateWithoutAuthorInput> | CommentTranslationCreateWithoutAuthorInput[] | CommentTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutAuthorInput | CommentTranslationCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentTranslationCreateManyAuthorInputEnvelope
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<OrderCreateWithoutStudentInput, OrderUncheckedCreateWithoutStudentInput> | OrderCreateWithoutStudentInput[] | OrderUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStudentInput | OrderCreateOrConnectWithoutStudentInput[]
    createMany?: OrderCreateManyStudentInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PageTranslationUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PageTranslationCreateWithoutAuthorInput, PageTranslationUncheckedCreateWithoutAuthorInput> | PageTranslationCreateWithoutAuthorInput[] | PageTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutAuthorInput | PageTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: PageTranslationUpsertWithWhereUniqueWithoutAuthorInput | PageTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PageTranslationCreateManyAuthorInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?: PageTranslationUpdateWithWhereUniqueWithoutAuthorInput | PageTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PageTranslationUpdateManyWithWhereWithoutAuthorInput | PageTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type ArticleTranslationUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutAuthorInput, ArticleTranslationUncheckedCreateWithoutAuthorInput> | ArticleTranslationCreateWithoutAuthorInput[] | ArticleTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutAuthorInput | ArticleTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleTranslationUpsertWithWhereUniqueWithoutAuthorInput | ArticleTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleTranslationCreateManyAuthorInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?: ArticleTranslationUpdateWithWhereUniqueWithoutAuthorInput | ArticleTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleTranslationUpdateManyWithWhereWithoutAuthorInput | ArticleTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type CategoryTranslationUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutAuthorInput, CategoryTranslationUncheckedCreateWithoutAuthorInput> | CategoryTranslationCreateWithoutAuthorInput[] | CategoryTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutAuthorInput | CategoryTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutAuthorInput | CategoryTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CategoryTranslationCreateManyAuthorInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutAuthorInput | CategoryTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutAuthorInput | CategoryTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CommentTranslationUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentTranslationCreateWithoutAuthorInput, CommentTranslationUncheckedCreateWithoutAuthorInput> | CommentTranslationCreateWithoutAuthorInput[] | CommentTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutAuthorInput | CommentTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentTranslationUpsertWithWhereUniqueWithoutAuthorInput | CommentTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentTranslationCreateManyAuthorInputEnvelope
    set?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    disconnect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    delete?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    update?: CommentTranslationUpdateWithWhereUniqueWithoutAuthorInput | CommentTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentTranslationUpdateManyWithWhereWithoutAuthorInput | CommentTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutStudentNestedInput = {
    create?: XOR<OrderCreateWithoutStudentInput, OrderUncheckedCreateWithoutStudentInput> | OrderCreateWithoutStudentInput[] | OrderUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStudentInput | OrderCreateOrConnectWithoutStudentInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStudentInput | OrderUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: OrderCreateManyStudentInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStudentInput | OrderUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStudentInput | OrderUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PageTranslationCreateWithoutAuthorInput, PageTranslationUncheckedCreateWithoutAuthorInput> | PageTranslationCreateWithoutAuthorInput[] | PageTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutAuthorInput | PageTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: PageTranslationUpsertWithWhereUniqueWithoutAuthorInput | PageTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PageTranslationCreateManyAuthorInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?: PageTranslationUpdateWithWhereUniqueWithoutAuthorInput | PageTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PageTranslationUpdateManyWithWhereWithoutAuthorInput | PageTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutAuthorInput, ArticleTranslationUncheckedCreateWithoutAuthorInput> | ArticleTranslationCreateWithoutAuthorInput[] | ArticleTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutAuthorInput | ArticleTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleTranslationUpsertWithWhereUniqueWithoutAuthorInput | ArticleTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleTranslationCreateManyAuthorInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?: ArticleTranslationUpdateWithWhereUniqueWithoutAuthorInput | ArticleTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleTranslationUpdateManyWithWhereWithoutAuthorInput | ArticleTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutAuthorInput, CategoryTranslationUncheckedCreateWithoutAuthorInput> | CategoryTranslationCreateWithoutAuthorInput[] | CategoryTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutAuthorInput | CategoryTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutAuthorInput | CategoryTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CategoryTranslationCreateManyAuthorInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutAuthorInput | CategoryTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutAuthorInput | CategoryTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentTranslationCreateWithoutAuthorInput, CommentTranslationUncheckedCreateWithoutAuthorInput> | CommentTranslationCreateWithoutAuthorInput[] | CommentTranslationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutAuthorInput | CommentTranslationCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentTranslationUpsertWithWhereUniqueWithoutAuthorInput | CommentTranslationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentTranslationCreateManyAuthorInputEnvelope
    set?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    disconnect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    delete?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    update?: CommentTranslationUpdateWithWhereUniqueWithoutAuthorInput | CommentTranslationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentTranslationUpdateManyWithWhereWithoutAuthorInput | CommentTranslationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<OrderCreateWithoutStudentInput, OrderUncheckedCreateWithoutStudentInput> | OrderCreateWithoutStudentInput[] | OrderUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStudentInput | OrderCreateOrConnectWithoutStudentInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStudentInput | OrderUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: OrderCreateManyStudentInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStudentInput | OrderUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStudentInput | OrderUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type GlobalTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<GlobalTranslationCreateWithoutLanguageInput, GlobalTranslationUncheckedCreateWithoutLanguageInput> | GlobalTranslationCreateWithoutLanguageInput[] | GlobalTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutLanguageInput | GlobalTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: GlobalTranslationCreateManyLanguageInputEnvelope
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
  }

  export type PageTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<PageTranslationCreateWithoutLanguageInput, PageTranslationUncheckedCreateWithoutLanguageInput> | PageTranslationCreateWithoutLanguageInput[] | PageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutLanguageInput | PageTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: PageTranslationCreateManyLanguageInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type CategoryTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CategoryTranslationCreateWithoutLanguageInput, CategoryTranslationUncheckedCreateWithoutLanguageInput> | CategoryTranslationCreateWithoutLanguageInput[] | CategoryTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutLanguageInput | CategoryTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: CategoryTranslationCreateManyLanguageInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type CategoryServiceTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutLanguageInput, CategoryServiceTranslationUncheckedCreateWithoutLanguageInput> | CategoryServiceTranslationCreateWithoutLanguageInput[] | CategoryServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutLanguageInput | CategoryServiceTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: CategoryServiceTranslationCreateManyLanguageInputEnvelope
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
  }

  export type ServiceTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ServiceTranslationCreateWithoutLanguageInput, ServiceTranslationUncheckedCreateWithoutLanguageInput> | ServiceTranslationCreateWithoutLanguageInput[] | ServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutLanguageInput | ServiceTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: ServiceTranslationCreateManyLanguageInputEnvelope
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
  }

  export type ArticleTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ArticleTranslationCreateWithoutLanguageInput, ArticleTranslationUncheckedCreateWithoutLanguageInput> | ArticleTranslationCreateWithoutLanguageInput[] | ArticleTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutLanguageInput | ArticleTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: ArticleTranslationCreateManyLanguageInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type TagTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<TagTranslationCreateWithoutLanguageInput, TagTranslationUncheckedCreateWithoutLanguageInput> | TagTranslationCreateWithoutLanguageInput[] | TagTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutLanguageInput | TagTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: TagTranslationCreateManyLanguageInputEnvelope
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
  }

  export type CommentTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CommentTranslationCreateWithoutLanguageInput, CommentTranslationUncheckedCreateWithoutLanguageInput> | CommentTranslationCreateWithoutLanguageInput[] | CommentTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutLanguageInput | CommentTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: CommentTranslationCreateManyLanguageInputEnvelope
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
  }

  export type NavbarItemTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutLanguageInput, NavbarItemTranslationUncheckedCreateWithoutLanguageInput> | NavbarItemTranslationCreateWithoutLanguageInput[] | NavbarItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutLanguageInput | NavbarItemTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: NavbarItemTranslationCreateManyLanguageInputEnvelope
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
  }

  export type DropDownGroupTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutLanguageInput, DropDownGroupTranslationUncheckedCreateWithoutLanguageInput> | DropDownGroupTranslationCreateWithoutLanguageInput[] | DropDownGroupTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutLanguageInput | DropDownGroupTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: DropDownGroupTranslationCreateManyLanguageInputEnvelope
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
  }

  export type DropdownItemTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutLanguageInput, DropdownItemTranslationUncheckedCreateWithoutLanguageInput> | DropdownItemTranslationCreateWithoutLanguageInput[] | DropdownItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutLanguageInput | DropdownItemTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: DropdownItemTranslationCreateManyLanguageInputEnvelope
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
  }

  export type FooterTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<FooterTranslationCreateWithoutLanguageInput, FooterTranslationUncheckedCreateWithoutLanguageInput> | FooterTranslationCreateWithoutLanguageInput[] | FooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutLanguageInput | FooterTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: FooterTranslationCreateManyLanguageInputEnvelope
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
  }

  export type GroupFooterTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutLanguageInput, GroupFooterTranslationUncheckedCreateWithoutLanguageInput> | GroupFooterTranslationCreateWithoutLanguageInput[] | GroupFooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutLanguageInput | GroupFooterTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: GroupFooterTranslationCreateManyLanguageInputEnvelope
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
  }

  export type GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<GlobalTranslationCreateWithoutLanguageInput, GlobalTranslationUncheckedCreateWithoutLanguageInput> | GlobalTranslationCreateWithoutLanguageInput[] | GlobalTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutLanguageInput | GlobalTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: GlobalTranslationCreateManyLanguageInputEnvelope
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
  }

  export type PageTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<PageTranslationCreateWithoutLanguageInput, PageTranslationUncheckedCreateWithoutLanguageInput> | PageTranslationCreateWithoutLanguageInput[] | PageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutLanguageInput | PageTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: PageTranslationCreateManyLanguageInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CategoryTranslationCreateWithoutLanguageInput, CategoryTranslationUncheckedCreateWithoutLanguageInput> | CategoryTranslationCreateWithoutLanguageInput[] | CategoryTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutLanguageInput | CategoryTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: CategoryTranslationCreateManyLanguageInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutLanguageInput, CategoryServiceTranslationUncheckedCreateWithoutLanguageInput> | CategoryServiceTranslationCreateWithoutLanguageInput[] | CategoryServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutLanguageInput | CategoryServiceTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: CategoryServiceTranslationCreateManyLanguageInputEnvelope
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
  }

  export type ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ServiceTranslationCreateWithoutLanguageInput, ServiceTranslationUncheckedCreateWithoutLanguageInput> | ServiceTranslationCreateWithoutLanguageInput[] | ServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutLanguageInput | ServiceTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: ServiceTranslationCreateManyLanguageInputEnvelope
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
  }

  export type ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ArticleTranslationCreateWithoutLanguageInput, ArticleTranslationUncheckedCreateWithoutLanguageInput> | ArticleTranslationCreateWithoutLanguageInput[] | ArticleTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutLanguageInput | ArticleTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: ArticleTranslationCreateManyLanguageInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type TagTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<TagTranslationCreateWithoutLanguageInput, TagTranslationUncheckedCreateWithoutLanguageInput> | TagTranslationCreateWithoutLanguageInput[] | TagTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutLanguageInput | TagTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: TagTranslationCreateManyLanguageInputEnvelope
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
  }

  export type CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CommentTranslationCreateWithoutLanguageInput, CommentTranslationUncheckedCreateWithoutLanguageInput> | CommentTranslationCreateWithoutLanguageInput[] | CommentTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutLanguageInput | CommentTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: CommentTranslationCreateManyLanguageInputEnvelope
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
  }

  export type NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutLanguageInput, NavbarItemTranslationUncheckedCreateWithoutLanguageInput> | NavbarItemTranslationCreateWithoutLanguageInput[] | NavbarItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutLanguageInput | NavbarItemTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: NavbarItemTranslationCreateManyLanguageInputEnvelope
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
  }

  export type DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutLanguageInput, DropDownGroupTranslationUncheckedCreateWithoutLanguageInput> | DropDownGroupTranslationCreateWithoutLanguageInput[] | DropDownGroupTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutLanguageInput | DropDownGroupTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: DropDownGroupTranslationCreateManyLanguageInputEnvelope
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
  }

  export type DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutLanguageInput, DropdownItemTranslationUncheckedCreateWithoutLanguageInput> | DropdownItemTranslationCreateWithoutLanguageInput[] | DropdownItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutLanguageInput | DropdownItemTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: DropdownItemTranslationCreateManyLanguageInputEnvelope
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
  }

  export type FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<FooterTranslationCreateWithoutLanguageInput, FooterTranslationUncheckedCreateWithoutLanguageInput> | FooterTranslationCreateWithoutLanguageInput[] | FooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutLanguageInput | FooterTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: FooterTranslationCreateManyLanguageInputEnvelope
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
  }

  export type GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutLanguageInput, GroupFooterTranslationUncheckedCreateWithoutLanguageInput> | GroupFooterTranslationCreateWithoutLanguageInput[] | GroupFooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutLanguageInput | GroupFooterTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: GroupFooterTranslationCreateManyLanguageInputEnvelope
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
  }

  export type GlobalTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<GlobalTranslationCreateWithoutLanguageInput, GlobalTranslationUncheckedCreateWithoutLanguageInput> | GlobalTranslationCreateWithoutLanguageInput[] | GlobalTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutLanguageInput | GlobalTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: GlobalTranslationUpsertWithWhereUniqueWithoutLanguageInput | GlobalTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: GlobalTranslationCreateManyLanguageInputEnvelope
    set?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    disconnect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    delete?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    update?: GlobalTranslationUpdateWithWhereUniqueWithoutLanguageInput | GlobalTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: GlobalTranslationUpdateManyWithWhereWithoutLanguageInput | GlobalTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: GlobalTranslationScalarWhereInput | GlobalTranslationScalarWhereInput[]
  }

  export type PageTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<PageTranslationCreateWithoutLanguageInput, PageTranslationUncheckedCreateWithoutLanguageInput> | PageTranslationCreateWithoutLanguageInput[] | PageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutLanguageInput | PageTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: PageTranslationUpsertWithWhereUniqueWithoutLanguageInput | PageTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: PageTranslationCreateManyLanguageInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?: PageTranslationUpdateWithWhereUniqueWithoutLanguageInput | PageTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: PageTranslationUpdateManyWithWhereWithoutLanguageInput | PageTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type CategoryTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutLanguageInput, CategoryTranslationUncheckedCreateWithoutLanguageInput> | CategoryTranslationCreateWithoutLanguageInput[] | CategoryTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutLanguageInput | CategoryTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutLanguageInput | CategoryTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CategoryTranslationCreateManyLanguageInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutLanguageInput | CategoryTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutLanguageInput | CategoryTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutLanguageInput, CategoryServiceTranslationUncheckedCreateWithoutLanguageInput> | CategoryServiceTranslationCreateWithoutLanguageInput[] | CategoryServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutLanguageInput | CategoryServiceTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: CategoryServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput | CategoryServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CategoryServiceTranslationCreateManyLanguageInputEnvelope
    set?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    disconnect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    delete?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    update?: CategoryServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput | CategoryServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CategoryServiceTranslationUpdateManyWithWhereWithoutLanguageInput | CategoryServiceTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CategoryServiceTranslationScalarWhereInput | CategoryServiceTranslationScalarWhereInput[]
  }

  export type ServiceTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ServiceTranslationCreateWithoutLanguageInput, ServiceTranslationUncheckedCreateWithoutLanguageInput> | ServiceTranslationCreateWithoutLanguageInput[] | ServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutLanguageInput | ServiceTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: ServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput | ServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ServiceTranslationCreateManyLanguageInputEnvelope
    set?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    disconnect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    delete?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    update?: ServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput | ServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ServiceTranslationUpdateManyWithWhereWithoutLanguageInput | ServiceTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ServiceTranslationScalarWhereInput | ServiceTranslationScalarWhereInput[]
  }

  export type ArticleTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutLanguageInput, ArticleTranslationUncheckedCreateWithoutLanguageInput> | ArticleTranslationCreateWithoutLanguageInput[] | ArticleTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutLanguageInput | ArticleTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: ArticleTranslationUpsertWithWhereUniqueWithoutLanguageInput | ArticleTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ArticleTranslationCreateManyLanguageInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?: ArticleTranslationUpdateWithWhereUniqueWithoutLanguageInput | ArticleTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ArticleTranslationUpdateManyWithWhereWithoutLanguageInput | ArticleTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type TagTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<TagTranslationCreateWithoutLanguageInput, TagTranslationUncheckedCreateWithoutLanguageInput> | TagTranslationCreateWithoutLanguageInput[] | TagTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutLanguageInput | TagTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: TagTranslationUpsertWithWhereUniqueWithoutLanguageInput | TagTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: TagTranslationCreateManyLanguageInputEnvelope
    set?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    disconnect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    delete?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    update?: TagTranslationUpdateWithWhereUniqueWithoutLanguageInput | TagTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: TagTranslationUpdateManyWithWhereWithoutLanguageInput | TagTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
  }

  export type CommentTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CommentTranslationCreateWithoutLanguageInput, CommentTranslationUncheckedCreateWithoutLanguageInput> | CommentTranslationCreateWithoutLanguageInput[] | CommentTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutLanguageInput | CommentTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: CommentTranslationUpsertWithWhereUniqueWithoutLanguageInput | CommentTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CommentTranslationCreateManyLanguageInputEnvelope
    set?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    disconnect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    delete?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    update?: CommentTranslationUpdateWithWhereUniqueWithoutLanguageInput | CommentTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CommentTranslationUpdateManyWithWhereWithoutLanguageInput | CommentTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
  }

  export type NavbarItemTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutLanguageInput, NavbarItemTranslationUncheckedCreateWithoutLanguageInput> | NavbarItemTranslationCreateWithoutLanguageInput[] | NavbarItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutLanguageInput | NavbarItemTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: NavbarItemTranslationUpsertWithWhereUniqueWithoutLanguageInput | NavbarItemTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: NavbarItemTranslationCreateManyLanguageInputEnvelope
    set?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    disconnect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    delete?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    update?: NavbarItemTranslationUpdateWithWhereUniqueWithoutLanguageInput | NavbarItemTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: NavbarItemTranslationUpdateManyWithWhereWithoutLanguageInput | NavbarItemTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: NavbarItemTranslationScalarWhereInput | NavbarItemTranslationScalarWhereInput[]
  }

  export type DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutLanguageInput, DropDownGroupTranslationUncheckedCreateWithoutLanguageInput> | DropDownGroupTranslationCreateWithoutLanguageInput[] | DropDownGroupTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutLanguageInput | DropDownGroupTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: DropDownGroupTranslationUpsertWithWhereUniqueWithoutLanguageInput | DropDownGroupTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: DropDownGroupTranslationCreateManyLanguageInputEnvelope
    set?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    disconnect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    delete?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    update?: DropDownGroupTranslationUpdateWithWhereUniqueWithoutLanguageInput | DropDownGroupTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: DropDownGroupTranslationUpdateManyWithWhereWithoutLanguageInput | DropDownGroupTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: DropDownGroupTranslationScalarWhereInput | DropDownGroupTranslationScalarWhereInput[]
  }

  export type DropdownItemTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutLanguageInput, DropdownItemTranslationUncheckedCreateWithoutLanguageInput> | DropdownItemTranslationCreateWithoutLanguageInput[] | DropdownItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutLanguageInput | DropdownItemTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: DropdownItemTranslationUpsertWithWhereUniqueWithoutLanguageInput | DropdownItemTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: DropdownItemTranslationCreateManyLanguageInputEnvelope
    set?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    disconnect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    delete?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    update?: DropdownItemTranslationUpdateWithWhereUniqueWithoutLanguageInput | DropdownItemTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: DropdownItemTranslationUpdateManyWithWhereWithoutLanguageInput | DropdownItemTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: DropdownItemTranslationScalarWhereInput | DropdownItemTranslationScalarWhereInput[]
  }

  export type FooterTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<FooterTranslationCreateWithoutLanguageInput, FooterTranslationUncheckedCreateWithoutLanguageInput> | FooterTranslationCreateWithoutLanguageInput[] | FooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutLanguageInput | FooterTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: FooterTranslationUpsertWithWhereUniqueWithoutLanguageInput | FooterTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: FooterTranslationCreateManyLanguageInputEnvelope
    set?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    disconnect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    delete?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    update?: FooterTranslationUpdateWithWhereUniqueWithoutLanguageInput | FooterTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: FooterTranslationUpdateManyWithWhereWithoutLanguageInput | FooterTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: FooterTranslationScalarWhereInput | FooterTranslationScalarWhereInput[]
  }

  export type GroupFooterTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutLanguageInput, GroupFooterTranslationUncheckedCreateWithoutLanguageInput> | GroupFooterTranslationCreateWithoutLanguageInput[] | GroupFooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutLanguageInput | GroupFooterTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: GroupFooterTranslationUpsertWithWhereUniqueWithoutLanguageInput | GroupFooterTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: GroupFooterTranslationCreateManyLanguageInputEnvelope
    set?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    disconnect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    delete?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    update?: GroupFooterTranslationUpdateWithWhereUniqueWithoutLanguageInput | GroupFooterTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: GroupFooterTranslationUpdateManyWithWhereWithoutLanguageInput | GroupFooterTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: GroupFooterTranslationScalarWhereInput | GroupFooterTranslationScalarWhereInput[]
  }

  export type GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<GlobalTranslationCreateWithoutLanguageInput, GlobalTranslationUncheckedCreateWithoutLanguageInput> | GlobalTranslationCreateWithoutLanguageInput[] | GlobalTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutLanguageInput | GlobalTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: GlobalTranslationUpsertWithWhereUniqueWithoutLanguageInput | GlobalTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: GlobalTranslationCreateManyLanguageInputEnvelope
    set?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    disconnect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    delete?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    update?: GlobalTranslationUpdateWithWhereUniqueWithoutLanguageInput | GlobalTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: GlobalTranslationUpdateManyWithWhereWithoutLanguageInput | GlobalTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: GlobalTranslationScalarWhereInput | GlobalTranslationScalarWhereInput[]
  }

  export type PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<PageTranslationCreateWithoutLanguageInput, PageTranslationUncheckedCreateWithoutLanguageInput> | PageTranslationCreateWithoutLanguageInput[] | PageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutLanguageInput | PageTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: PageTranslationUpsertWithWhereUniqueWithoutLanguageInput | PageTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: PageTranslationCreateManyLanguageInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?: PageTranslationUpdateWithWhereUniqueWithoutLanguageInput | PageTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: PageTranslationUpdateManyWithWhereWithoutLanguageInput | PageTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutLanguageInput, CategoryTranslationUncheckedCreateWithoutLanguageInput> | CategoryTranslationCreateWithoutLanguageInput[] | CategoryTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutLanguageInput | CategoryTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutLanguageInput | CategoryTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CategoryTranslationCreateManyLanguageInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutLanguageInput | CategoryTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutLanguageInput | CategoryTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutLanguageInput, CategoryServiceTranslationUncheckedCreateWithoutLanguageInput> | CategoryServiceTranslationCreateWithoutLanguageInput[] | CategoryServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutLanguageInput | CategoryServiceTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: CategoryServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput | CategoryServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CategoryServiceTranslationCreateManyLanguageInputEnvelope
    set?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    disconnect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    delete?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    update?: CategoryServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput | CategoryServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CategoryServiceTranslationUpdateManyWithWhereWithoutLanguageInput | CategoryServiceTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CategoryServiceTranslationScalarWhereInput | CategoryServiceTranslationScalarWhereInput[]
  }

  export type ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ServiceTranslationCreateWithoutLanguageInput, ServiceTranslationUncheckedCreateWithoutLanguageInput> | ServiceTranslationCreateWithoutLanguageInput[] | ServiceTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutLanguageInput | ServiceTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: ServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput | ServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ServiceTranslationCreateManyLanguageInputEnvelope
    set?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    disconnect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    delete?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    update?: ServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput | ServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ServiceTranslationUpdateManyWithWhereWithoutLanguageInput | ServiceTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ServiceTranslationScalarWhereInput | ServiceTranslationScalarWhereInput[]
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutLanguageInput, ArticleTranslationUncheckedCreateWithoutLanguageInput> | ArticleTranslationCreateWithoutLanguageInput[] | ArticleTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutLanguageInput | ArticleTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: ArticleTranslationUpsertWithWhereUniqueWithoutLanguageInput | ArticleTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ArticleTranslationCreateManyLanguageInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?: ArticleTranslationUpdateWithWhereUniqueWithoutLanguageInput | ArticleTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ArticleTranslationUpdateManyWithWhereWithoutLanguageInput | ArticleTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<TagTranslationCreateWithoutLanguageInput, TagTranslationUncheckedCreateWithoutLanguageInput> | TagTranslationCreateWithoutLanguageInput[] | TagTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutLanguageInput | TagTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: TagTranslationUpsertWithWhereUniqueWithoutLanguageInput | TagTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: TagTranslationCreateManyLanguageInputEnvelope
    set?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    disconnect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    delete?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    update?: TagTranslationUpdateWithWhereUniqueWithoutLanguageInput | TagTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: TagTranslationUpdateManyWithWhereWithoutLanguageInput | TagTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
  }

  export type CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CommentTranslationCreateWithoutLanguageInput, CommentTranslationUncheckedCreateWithoutLanguageInput> | CommentTranslationCreateWithoutLanguageInput[] | CommentTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutLanguageInput | CommentTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: CommentTranslationUpsertWithWhereUniqueWithoutLanguageInput | CommentTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CommentTranslationCreateManyLanguageInputEnvelope
    set?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    disconnect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    delete?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    update?: CommentTranslationUpdateWithWhereUniqueWithoutLanguageInput | CommentTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CommentTranslationUpdateManyWithWhereWithoutLanguageInput | CommentTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
  }

  export type NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutLanguageInput, NavbarItemTranslationUncheckedCreateWithoutLanguageInput> | NavbarItemTranslationCreateWithoutLanguageInput[] | NavbarItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutLanguageInput | NavbarItemTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: NavbarItemTranslationUpsertWithWhereUniqueWithoutLanguageInput | NavbarItemTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: NavbarItemTranslationCreateManyLanguageInputEnvelope
    set?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    disconnect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    delete?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    update?: NavbarItemTranslationUpdateWithWhereUniqueWithoutLanguageInput | NavbarItemTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: NavbarItemTranslationUpdateManyWithWhereWithoutLanguageInput | NavbarItemTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: NavbarItemTranslationScalarWhereInput | NavbarItemTranslationScalarWhereInput[]
  }

  export type DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutLanguageInput, DropDownGroupTranslationUncheckedCreateWithoutLanguageInput> | DropDownGroupTranslationCreateWithoutLanguageInput[] | DropDownGroupTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutLanguageInput | DropDownGroupTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: DropDownGroupTranslationUpsertWithWhereUniqueWithoutLanguageInput | DropDownGroupTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: DropDownGroupTranslationCreateManyLanguageInputEnvelope
    set?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    disconnect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    delete?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    update?: DropDownGroupTranslationUpdateWithWhereUniqueWithoutLanguageInput | DropDownGroupTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: DropDownGroupTranslationUpdateManyWithWhereWithoutLanguageInput | DropDownGroupTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: DropDownGroupTranslationScalarWhereInput | DropDownGroupTranslationScalarWhereInput[]
  }

  export type DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutLanguageInput, DropdownItemTranslationUncheckedCreateWithoutLanguageInput> | DropdownItemTranslationCreateWithoutLanguageInput[] | DropdownItemTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutLanguageInput | DropdownItemTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: DropdownItemTranslationUpsertWithWhereUniqueWithoutLanguageInput | DropdownItemTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: DropdownItemTranslationCreateManyLanguageInputEnvelope
    set?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    disconnect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    delete?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    update?: DropdownItemTranslationUpdateWithWhereUniqueWithoutLanguageInput | DropdownItemTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: DropdownItemTranslationUpdateManyWithWhereWithoutLanguageInput | DropdownItemTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: DropdownItemTranslationScalarWhereInput | DropdownItemTranslationScalarWhereInput[]
  }

  export type FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<FooterTranslationCreateWithoutLanguageInput, FooterTranslationUncheckedCreateWithoutLanguageInput> | FooterTranslationCreateWithoutLanguageInput[] | FooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutLanguageInput | FooterTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: FooterTranslationUpsertWithWhereUniqueWithoutLanguageInput | FooterTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: FooterTranslationCreateManyLanguageInputEnvelope
    set?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    disconnect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    delete?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    update?: FooterTranslationUpdateWithWhereUniqueWithoutLanguageInput | FooterTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: FooterTranslationUpdateManyWithWhereWithoutLanguageInput | FooterTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: FooterTranslationScalarWhereInput | FooterTranslationScalarWhereInput[]
  }

  export type GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutLanguageInput, GroupFooterTranslationUncheckedCreateWithoutLanguageInput> | GroupFooterTranslationCreateWithoutLanguageInput[] | GroupFooterTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutLanguageInput | GroupFooterTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: GroupFooterTranslationUpsertWithWhereUniqueWithoutLanguageInput | GroupFooterTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: GroupFooterTranslationCreateManyLanguageInputEnvelope
    set?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    disconnect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    delete?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    update?: GroupFooterTranslationUpdateWithWhereUniqueWithoutLanguageInput | GroupFooterTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: GroupFooterTranslationUpdateManyWithWhereWithoutLanguageInput | GroupFooterTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: GroupFooterTranslationScalarWhereInput | GroupFooterTranslationScalarWhereInput[]
  }

  export type GlobalTranslationCreateNestedManyWithoutGlobalInput = {
    create?: XOR<GlobalTranslationCreateWithoutGlobalInput, GlobalTranslationUncheckedCreateWithoutGlobalInput> | GlobalTranslationCreateWithoutGlobalInput[] | GlobalTranslationUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutGlobalInput | GlobalTranslationCreateOrConnectWithoutGlobalInput[]
    createMany?: GlobalTranslationCreateManyGlobalInputEnvelope
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
  }

  export type SocialLinkCreateNestedManyWithoutGlobalInput = {
    create?: XOR<SocialLinkCreateWithoutGlobalInput, SocialLinkUncheckedCreateWithoutGlobalInput> | SocialLinkCreateWithoutGlobalInput[] | SocialLinkUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGlobalInput | SocialLinkCreateOrConnectWithoutGlobalInput[]
    createMany?: SocialLinkCreateManyGlobalInputEnvelope
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
  }

  export type GlobalTranslationUncheckedCreateNestedManyWithoutGlobalInput = {
    create?: XOR<GlobalTranslationCreateWithoutGlobalInput, GlobalTranslationUncheckedCreateWithoutGlobalInput> | GlobalTranslationCreateWithoutGlobalInput[] | GlobalTranslationUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutGlobalInput | GlobalTranslationCreateOrConnectWithoutGlobalInput[]
    createMany?: GlobalTranslationCreateManyGlobalInputEnvelope
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
  }

  export type SocialLinkUncheckedCreateNestedManyWithoutGlobalInput = {
    create?: XOR<SocialLinkCreateWithoutGlobalInput, SocialLinkUncheckedCreateWithoutGlobalInput> | SocialLinkCreateWithoutGlobalInput[] | SocialLinkUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGlobalInput | SocialLinkCreateOrConnectWithoutGlobalInput[]
    createMany?: SocialLinkCreateManyGlobalInputEnvelope
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
  }

  export type GlobalTranslationUpdateManyWithoutGlobalNestedInput = {
    create?: XOR<GlobalTranslationCreateWithoutGlobalInput, GlobalTranslationUncheckedCreateWithoutGlobalInput> | GlobalTranslationCreateWithoutGlobalInput[] | GlobalTranslationUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutGlobalInput | GlobalTranslationCreateOrConnectWithoutGlobalInput[]
    upsert?: GlobalTranslationUpsertWithWhereUniqueWithoutGlobalInput | GlobalTranslationUpsertWithWhereUniqueWithoutGlobalInput[]
    createMany?: GlobalTranslationCreateManyGlobalInputEnvelope
    set?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    disconnect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    delete?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    update?: GlobalTranslationUpdateWithWhereUniqueWithoutGlobalInput | GlobalTranslationUpdateWithWhereUniqueWithoutGlobalInput[]
    updateMany?: GlobalTranslationUpdateManyWithWhereWithoutGlobalInput | GlobalTranslationUpdateManyWithWhereWithoutGlobalInput[]
    deleteMany?: GlobalTranslationScalarWhereInput | GlobalTranslationScalarWhereInput[]
  }

  export type SocialLinkUpdateManyWithoutGlobalNestedInput = {
    create?: XOR<SocialLinkCreateWithoutGlobalInput, SocialLinkUncheckedCreateWithoutGlobalInput> | SocialLinkCreateWithoutGlobalInput[] | SocialLinkUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGlobalInput | SocialLinkCreateOrConnectWithoutGlobalInput[]
    upsert?: SocialLinkUpsertWithWhereUniqueWithoutGlobalInput | SocialLinkUpsertWithWhereUniqueWithoutGlobalInput[]
    createMany?: SocialLinkCreateManyGlobalInputEnvelope
    set?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    disconnect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    delete?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    update?: SocialLinkUpdateWithWhereUniqueWithoutGlobalInput | SocialLinkUpdateWithWhereUniqueWithoutGlobalInput[]
    updateMany?: SocialLinkUpdateManyWithWhereWithoutGlobalInput | SocialLinkUpdateManyWithWhereWithoutGlobalInput[]
    deleteMany?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
  }

  export type GlobalTranslationUncheckedUpdateManyWithoutGlobalNestedInput = {
    create?: XOR<GlobalTranslationCreateWithoutGlobalInput, GlobalTranslationUncheckedCreateWithoutGlobalInput> | GlobalTranslationCreateWithoutGlobalInput[] | GlobalTranslationUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: GlobalTranslationCreateOrConnectWithoutGlobalInput | GlobalTranslationCreateOrConnectWithoutGlobalInput[]
    upsert?: GlobalTranslationUpsertWithWhereUniqueWithoutGlobalInput | GlobalTranslationUpsertWithWhereUniqueWithoutGlobalInput[]
    createMany?: GlobalTranslationCreateManyGlobalInputEnvelope
    set?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    disconnect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    delete?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    connect?: GlobalTranslationWhereUniqueInput | GlobalTranslationWhereUniqueInput[]
    update?: GlobalTranslationUpdateWithWhereUniqueWithoutGlobalInput | GlobalTranslationUpdateWithWhereUniqueWithoutGlobalInput[]
    updateMany?: GlobalTranslationUpdateManyWithWhereWithoutGlobalInput | GlobalTranslationUpdateManyWithWhereWithoutGlobalInput[]
    deleteMany?: GlobalTranslationScalarWhereInput | GlobalTranslationScalarWhereInput[]
  }

  export type SocialLinkUncheckedUpdateManyWithoutGlobalNestedInput = {
    create?: XOR<SocialLinkCreateWithoutGlobalInput, SocialLinkUncheckedCreateWithoutGlobalInput> | SocialLinkCreateWithoutGlobalInput[] | SocialLinkUncheckedCreateWithoutGlobalInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGlobalInput | SocialLinkCreateOrConnectWithoutGlobalInput[]
    upsert?: SocialLinkUpsertWithWhereUniqueWithoutGlobalInput | SocialLinkUpsertWithWhereUniqueWithoutGlobalInput[]
    createMany?: SocialLinkCreateManyGlobalInputEnvelope
    set?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    disconnect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    delete?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    update?: SocialLinkUpdateWithWhereUniqueWithoutGlobalInput | SocialLinkUpdateWithWhereUniqueWithoutGlobalInput[]
    updateMany?: SocialLinkUpdateManyWithWhereWithoutGlobalInput | SocialLinkUpdateManyWithWhereWithoutGlobalInput[]
    deleteMany?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
  }

  export type GlobalTranslationCreateimagesInput = {
    set: string[]
  }

  export type LanguageCreateNestedOneWithoutGlobalsInput = {
    create?: XOR<LanguageCreateWithoutGlobalsInput, LanguageUncheckedCreateWithoutGlobalsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutGlobalsInput
    connect?: LanguageWhereUniqueInput
  }

  export type GlobalCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<GlobalCreateWithoutTranslationsInput, GlobalUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: GlobalCreateOrConnectWithoutTranslationsInput
    connect?: GlobalWhereUniqueInput
  }

  export type GlobalTranslationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageUpdateOneRequiredWithoutGlobalsNestedInput = {
    create?: XOR<LanguageCreateWithoutGlobalsInput, LanguageUncheckedCreateWithoutGlobalsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutGlobalsInput
    upsert?: LanguageUpsertWithoutGlobalsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutGlobalsInput, LanguageUpdateWithoutGlobalsInput>, LanguageUncheckedUpdateWithoutGlobalsInput>
  }

  export type GlobalUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<GlobalCreateWithoutTranslationsInput, GlobalUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: GlobalCreateOrConnectWithoutTranslationsInput
    upsert?: GlobalUpsertWithoutTranslationsInput
    connect?: GlobalWhereUniqueInput
    update?: XOR<XOR<GlobalUpdateToOneWithWhereWithoutTranslationsInput, GlobalUpdateWithoutTranslationsInput>, GlobalUncheckedUpdateWithoutTranslationsInput>
  }

  export type GlobalCreateNestedOneWithoutSocialLinksInput = {
    create?: XOR<GlobalCreateWithoutSocialLinksInput, GlobalUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: GlobalCreateOrConnectWithoutSocialLinksInput
    connect?: GlobalWhereUniqueInput
  }

  export type GlobalUpdateOneWithoutSocialLinksNestedInput = {
    create?: XOR<GlobalCreateWithoutSocialLinksInput, GlobalUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: GlobalCreateOrConnectWithoutSocialLinksInput
    upsert?: GlobalUpsertWithoutSocialLinksInput
    disconnect?: GlobalWhereInput | boolean
    delete?: GlobalWhereInput | boolean
    connect?: GlobalWhereUniqueInput
    update?: XOR<XOR<GlobalUpdateToOneWithWhereWithoutSocialLinksInput, GlobalUpdateWithoutSocialLinksInput>, GlobalUncheckedUpdateWithoutSocialLinksInput>
  }

  export type NavbarItemTranslationCreateNestedManyWithoutNavbarItemInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutNavbarItemInput, NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput> | NavbarItemTranslationCreateWithoutNavbarItemInput[] | NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput | NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput[]
    createMany?: NavbarItemTranslationCreateManyNavbarItemInputEnvelope
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
  }

  export type DropDownGroupCreateNestedManyWithoutNavItemInput = {
    create?: XOR<DropDownGroupCreateWithoutNavItemInput, DropDownGroupUncheckedCreateWithoutNavItemInput> | DropDownGroupCreateWithoutNavItemInput[] | DropDownGroupUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutNavItemInput | DropDownGroupCreateOrConnectWithoutNavItemInput[]
    createMany?: DropDownGroupCreateManyNavItemInputEnvelope
    connect?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
  }

  export type DropdownItemCreateNestedManyWithoutNavItemInput = {
    create?: XOR<DropdownItemCreateWithoutNavItemInput, DropdownItemUncheckedCreateWithoutNavItemInput> | DropdownItemCreateWithoutNavItemInput[] | DropdownItemUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutNavItemInput | DropdownItemCreateOrConnectWithoutNavItemInput[]
    createMany?: DropdownItemCreateManyNavItemInputEnvelope
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
  }

  export type PageCreateNestedOneWithoutNavbarItemInput = {
    create?: XOR<PageCreateWithoutNavbarItemInput, PageUncheckedCreateWithoutNavbarItemInput>
    connectOrCreate?: PageCreateOrConnectWithoutNavbarItemInput
    connect?: PageWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutNavbarItemInput = {
    create?: XOR<ArticleCreateWithoutNavbarItemInput, ArticleUncheckedCreateWithoutNavbarItemInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutNavbarItemInput
    connect?: ArticleWhereUniqueInput
  }

  export type NavbarItemTranslationUncheckedCreateNestedManyWithoutNavbarItemInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutNavbarItemInput, NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput> | NavbarItemTranslationCreateWithoutNavbarItemInput[] | NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput | NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput[]
    createMany?: NavbarItemTranslationCreateManyNavbarItemInputEnvelope
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
  }

  export type DropDownGroupUncheckedCreateNestedManyWithoutNavItemInput = {
    create?: XOR<DropDownGroupCreateWithoutNavItemInput, DropDownGroupUncheckedCreateWithoutNavItemInput> | DropDownGroupCreateWithoutNavItemInput[] | DropDownGroupUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutNavItemInput | DropDownGroupCreateOrConnectWithoutNavItemInput[]
    createMany?: DropDownGroupCreateManyNavItemInputEnvelope
    connect?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
  }

  export type DropdownItemUncheckedCreateNestedManyWithoutNavItemInput = {
    create?: XOR<DropdownItemCreateWithoutNavItemInput, DropdownItemUncheckedCreateWithoutNavItemInput> | DropdownItemCreateWithoutNavItemInput[] | DropdownItemUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutNavItemInput | DropdownItemCreateOrConnectWithoutNavItemInput[]
    createMany?: DropdownItemCreateManyNavItemInputEnvelope
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NavbarItemTranslationUpdateManyWithoutNavbarItemNestedInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutNavbarItemInput, NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput> | NavbarItemTranslationCreateWithoutNavbarItemInput[] | NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput | NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput[]
    upsert?: NavbarItemTranslationUpsertWithWhereUniqueWithoutNavbarItemInput | NavbarItemTranslationUpsertWithWhereUniqueWithoutNavbarItemInput[]
    createMany?: NavbarItemTranslationCreateManyNavbarItemInputEnvelope
    set?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    disconnect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    delete?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    update?: NavbarItemTranslationUpdateWithWhereUniqueWithoutNavbarItemInput | NavbarItemTranslationUpdateWithWhereUniqueWithoutNavbarItemInput[]
    updateMany?: NavbarItemTranslationUpdateManyWithWhereWithoutNavbarItemInput | NavbarItemTranslationUpdateManyWithWhereWithoutNavbarItemInput[]
    deleteMany?: NavbarItemTranslationScalarWhereInput | NavbarItemTranslationScalarWhereInput[]
  }

  export type DropDownGroupUpdateManyWithoutNavItemNestedInput = {
    create?: XOR<DropDownGroupCreateWithoutNavItemInput, DropDownGroupUncheckedCreateWithoutNavItemInput> | DropDownGroupCreateWithoutNavItemInput[] | DropDownGroupUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutNavItemInput | DropDownGroupCreateOrConnectWithoutNavItemInput[]
    upsert?: DropDownGroupUpsertWithWhereUniqueWithoutNavItemInput | DropDownGroupUpsertWithWhereUniqueWithoutNavItemInput[]
    createMany?: DropDownGroupCreateManyNavItemInputEnvelope
    set?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    disconnect?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    delete?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    connect?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    update?: DropDownGroupUpdateWithWhereUniqueWithoutNavItemInput | DropDownGroupUpdateWithWhereUniqueWithoutNavItemInput[]
    updateMany?: DropDownGroupUpdateManyWithWhereWithoutNavItemInput | DropDownGroupUpdateManyWithWhereWithoutNavItemInput[]
    deleteMany?: DropDownGroupScalarWhereInput | DropDownGroupScalarWhereInput[]
  }

  export type DropdownItemUpdateManyWithoutNavItemNestedInput = {
    create?: XOR<DropdownItemCreateWithoutNavItemInput, DropdownItemUncheckedCreateWithoutNavItemInput> | DropdownItemCreateWithoutNavItemInput[] | DropdownItemUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutNavItemInput | DropdownItemCreateOrConnectWithoutNavItemInput[]
    upsert?: DropdownItemUpsertWithWhereUniqueWithoutNavItemInput | DropdownItemUpsertWithWhereUniqueWithoutNavItemInput[]
    createMany?: DropdownItemCreateManyNavItemInputEnvelope
    set?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    disconnect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    delete?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    update?: DropdownItemUpdateWithWhereUniqueWithoutNavItemInput | DropdownItemUpdateWithWhereUniqueWithoutNavItemInput[]
    updateMany?: DropdownItemUpdateManyWithWhereWithoutNavItemInput | DropdownItemUpdateManyWithWhereWithoutNavItemInput[]
    deleteMany?: DropdownItemScalarWhereInput | DropdownItemScalarWhereInput[]
  }

  export type PageUpdateOneWithoutNavbarItemNestedInput = {
    create?: XOR<PageCreateWithoutNavbarItemInput, PageUncheckedCreateWithoutNavbarItemInput>
    connectOrCreate?: PageCreateOrConnectWithoutNavbarItemInput
    upsert?: PageUpsertWithoutNavbarItemInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutNavbarItemInput, PageUpdateWithoutNavbarItemInput>, PageUncheckedUpdateWithoutNavbarItemInput>
  }

  export type ArticleUpdateOneWithoutNavbarItemNestedInput = {
    create?: XOR<ArticleCreateWithoutNavbarItemInput, ArticleUncheckedCreateWithoutNavbarItemInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutNavbarItemInput
    upsert?: ArticleUpsertWithoutNavbarItemInput
    disconnect?: ArticleWhereInput | boolean
    delete?: ArticleWhereInput | boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutNavbarItemInput, ArticleUpdateWithoutNavbarItemInput>, ArticleUncheckedUpdateWithoutNavbarItemInput>
  }

  export type NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemNestedInput = {
    create?: XOR<NavbarItemTranslationCreateWithoutNavbarItemInput, NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput> | NavbarItemTranslationCreateWithoutNavbarItemInput[] | NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput[]
    connectOrCreate?: NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput | NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput[]
    upsert?: NavbarItemTranslationUpsertWithWhereUniqueWithoutNavbarItemInput | NavbarItemTranslationUpsertWithWhereUniqueWithoutNavbarItemInput[]
    createMany?: NavbarItemTranslationCreateManyNavbarItemInputEnvelope
    set?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    disconnect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    delete?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    connect?: NavbarItemTranslationWhereUniqueInput | NavbarItemTranslationWhereUniqueInput[]
    update?: NavbarItemTranslationUpdateWithWhereUniqueWithoutNavbarItemInput | NavbarItemTranslationUpdateWithWhereUniqueWithoutNavbarItemInput[]
    updateMany?: NavbarItemTranslationUpdateManyWithWhereWithoutNavbarItemInput | NavbarItemTranslationUpdateManyWithWhereWithoutNavbarItemInput[]
    deleteMany?: NavbarItemTranslationScalarWhereInput | NavbarItemTranslationScalarWhereInput[]
  }

  export type DropDownGroupUncheckedUpdateManyWithoutNavItemNestedInput = {
    create?: XOR<DropDownGroupCreateWithoutNavItemInput, DropDownGroupUncheckedCreateWithoutNavItemInput> | DropDownGroupCreateWithoutNavItemInput[] | DropDownGroupUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutNavItemInput | DropDownGroupCreateOrConnectWithoutNavItemInput[]
    upsert?: DropDownGroupUpsertWithWhereUniqueWithoutNavItemInput | DropDownGroupUpsertWithWhereUniqueWithoutNavItemInput[]
    createMany?: DropDownGroupCreateManyNavItemInputEnvelope
    set?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    disconnect?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    delete?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    connect?: DropDownGroupWhereUniqueInput | DropDownGroupWhereUniqueInput[]
    update?: DropDownGroupUpdateWithWhereUniqueWithoutNavItemInput | DropDownGroupUpdateWithWhereUniqueWithoutNavItemInput[]
    updateMany?: DropDownGroupUpdateManyWithWhereWithoutNavItemInput | DropDownGroupUpdateManyWithWhereWithoutNavItemInput[]
    deleteMany?: DropDownGroupScalarWhereInput | DropDownGroupScalarWhereInput[]
  }

  export type DropdownItemUncheckedUpdateManyWithoutNavItemNestedInput = {
    create?: XOR<DropdownItemCreateWithoutNavItemInput, DropdownItemUncheckedCreateWithoutNavItemInput> | DropdownItemCreateWithoutNavItemInput[] | DropdownItemUncheckedCreateWithoutNavItemInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutNavItemInput | DropdownItemCreateOrConnectWithoutNavItemInput[]
    upsert?: DropdownItemUpsertWithWhereUniqueWithoutNavItemInput | DropdownItemUpsertWithWhereUniqueWithoutNavItemInput[]
    createMany?: DropdownItemCreateManyNavItemInputEnvelope
    set?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    disconnect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    delete?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    update?: DropdownItemUpdateWithWhereUniqueWithoutNavItemInput | DropdownItemUpdateWithWhereUniqueWithoutNavItemInput[]
    updateMany?: DropdownItemUpdateManyWithWhereWithoutNavItemInput | DropdownItemUpdateManyWithWhereWithoutNavItemInput[]
    deleteMany?: DropdownItemScalarWhereInput | DropdownItemScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutNavbarItemsInput = {
    create?: XOR<LanguageCreateWithoutNavbarItemsInput, LanguageUncheckedCreateWithoutNavbarItemsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutNavbarItemsInput
    connect?: LanguageWhereUniqueInput
  }

  export type NavbarItemCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<NavbarItemCreateWithoutTranslationsInput, NavbarItemUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutTranslationsInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutNavbarItemsNestedInput = {
    create?: XOR<LanguageCreateWithoutNavbarItemsInput, LanguageUncheckedCreateWithoutNavbarItemsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutNavbarItemsInput
    upsert?: LanguageUpsertWithoutNavbarItemsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutNavbarItemsInput, LanguageUpdateWithoutNavbarItemsInput>, LanguageUncheckedUpdateWithoutNavbarItemsInput>
  }

  export type NavbarItemUpdateOneWithoutTranslationsNestedInput = {
    create?: XOR<NavbarItemCreateWithoutTranslationsInput, NavbarItemUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutTranslationsInput
    upsert?: NavbarItemUpsertWithoutTranslationsInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutTranslationsInput, NavbarItemUpdateWithoutTranslationsInput>, NavbarItemUncheckedUpdateWithoutTranslationsInput>
  }

  export type DropDownGroupTranslationCreateNestedManyWithoutDropdownGroupInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput> | DropDownGroupTranslationCreateWithoutDropdownGroupInput[] | DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput | DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput[]
    createMany?: DropDownGroupTranslationCreateManyDropdownGroupInputEnvelope
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
  }

  export type NavbarItemCreateNestedOneWithoutDropdownGroupsInput = {
    create?: XOR<NavbarItemCreateWithoutDropdownGroupsInput, NavbarItemUncheckedCreateWithoutDropdownGroupsInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutDropdownGroupsInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type DropdownItemCreateNestedManyWithoutGroupInput = {
    create?: XOR<DropdownItemCreateWithoutGroupInput, DropdownItemUncheckedCreateWithoutGroupInput> | DropdownItemCreateWithoutGroupInput[] | DropdownItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutGroupInput | DropdownItemCreateOrConnectWithoutGroupInput[]
    createMany?: DropdownItemCreateManyGroupInputEnvelope
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
  }

  export type DropDownGroupTranslationUncheckedCreateNestedManyWithoutDropdownGroupInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput> | DropDownGroupTranslationCreateWithoutDropdownGroupInput[] | DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput | DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput[]
    createMany?: DropDownGroupTranslationCreateManyDropdownGroupInputEnvelope
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
  }

  export type DropdownItemUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<DropdownItemCreateWithoutGroupInput, DropdownItemUncheckedCreateWithoutGroupInput> | DropdownItemCreateWithoutGroupInput[] | DropdownItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutGroupInput | DropdownItemCreateOrConnectWithoutGroupInput[]
    createMany?: DropdownItemCreateManyGroupInputEnvelope
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
  }

  export type DropDownGroupTranslationUpdateManyWithoutDropdownGroupNestedInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput> | DropDownGroupTranslationCreateWithoutDropdownGroupInput[] | DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput | DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput[]
    upsert?: DropDownGroupTranslationUpsertWithWhereUniqueWithoutDropdownGroupInput | DropDownGroupTranslationUpsertWithWhereUniqueWithoutDropdownGroupInput[]
    createMany?: DropDownGroupTranslationCreateManyDropdownGroupInputEnvelope
    set?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    disconnect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    delete?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    update?: DropDownGroupTranslationUpdateWithWhereUniqueWithoutDropdownGroupInput | DropDownGroupTranslationUpdateWithWhereUniqueWithoutDropdownGroupInput[]
    updateMany?: DropDownGroupTranslationUpdateManyWithWhereWithoutDropdownGroupInput | DropDownGroupTranslationUpdateManyWithWhereWithoutDropdownGroupInput[]
    deleteMany?: DropDownGroupTranslationScalarWhereInput | DropDownGroupTranslationScalarWhereInput[]
  }

  export type NavbarItemUpdateOneWithoutDropdownGroupsNestedInput = {
    create?: XOR<NavbarItemCreateWithoutDropdownGroupsInput, NavbarItemUncheckedCreateWithoutDropdownGroupsInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutDropdownGroupsInput
    upsert?: NavbarItemUpsertWithoutDropdownGroupsInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutDropdownGroupsInput, NavbarItemUpdateWithoutDropdownGroupsInput>, NavbarItemUncheckedUpdateWithoutDropdownGroupsInput>
  }

  export type DropdownItemUpdateManyWithoutGroupNestedInput = {
    create?: XOR<DropdownItemCreateWithoutGroupInput, DropdownItemUncheckedCreateWithoutGroupInput> | DropdownItemCreateWithoutGroupInput[] | DropdownItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutGroupInput | DropdownItemCreateOrConnectWithoutGroupInput[]
    upsert?: DropdownItemUpsertWithWhereUniqueWithoutGroupInput | DropdownItemUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: DropdownItemCreateManyGroupInputEnvelope
    set?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    disconnect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    delete?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    update?: DropdownItemUpdateWithWhereUniqueWithoutGroupInput | DropdownItemUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: DropdownItemUpdateManyWithWhereWithoutGroupInput | DropdownItemUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: DropdownItemScalarWhereInput | DropdownItemScalarWhereInput[]
  }

  export type DropDownGroupTranslationUncheckedUpdateManyWithoutDropdownGroupNestedInput = {
    create?: XOR<DropDownGroupTranslationCreateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput> | DropDownGroupTranslationCreateWithoutDropdownGroupInput[] | DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput[]
    connectOrCreate?: DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput | DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput[]
    upsert?: DropDownGroupTranslationUpsertWithWhereUniqueWithoutDropdownGroupInput | DropDownGroupTranslationUpsertWithWhereUniqueWithoutDropdownGroupInput[]
    createMany?: DropDownGroupTranslationCreateManyDropdownGroupInputEnvelope
    set?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    disconnect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    delete?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    connect?: DropDownGroupTranslationWhereUniqueInput | DropDownGroupTranslationWhereUniqueInput[]
    update?: DropDownGroupTranslationUpdateWithWhereUniqueWithoutDropdownGroupInput | DropDownGroupTranslationUpdateWithWhereUniqueWithoutDropdownGroupInput[]
    updateMany?: DropDownGroupTranslationUpdateManyWithWhereWithoutDropdownGroupInput | DropDownGroupTranslationUpdateManyWithWhereWithoutDropdownGroupInput[]
    deleteMany?: DropDownGroupTranslationScalarWhereInput | DropDownGroupTranslationScalarWhereInput[]
  }

  export type DropdownItemUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<DropdownItemCreateWithoutGroupInput, DropdownItemUncheckedCreateWithoutGroupInput> | DropdownItemCreateWithoutGroupInput[] | DropdownItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DropdownItemCreateOrConnectWithoutGroupInput | DropdownItemCreateOrConnectWithoutGroupInput[]
    upsert?: DropdownItemUpsertWithWhereUniqueWithoutGroupInput | DropdownItemUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: DropdownItemCreateManyGroupInputEnvelope
    set?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    disconnect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    delete?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    connect?: DropdownItemWhereUniqueInput | DropdownItemWhereUniqueInput[]
    update?: DropdownItemUpdateWithWhereUniqueWithoutGroupInput | DropdownItemUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: DropdownItemUpdateManyWithWhereWithoutGroupInput | DropdownItemUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: DropdownItemScalarWhereInput | DropdownItemScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutDropdownGroupsInput = {
    create?: XOR<LanguageCreateWithoutDropdownGroupsInput, LanguageUncheckedCreateWithoutDropdownGroupsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutDropdownGroupsInput
    connect?: LanguageWhereUniqueInput
  }

  export type DropDownGroupCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<DropDownGroupCreateWithoutTranslationsInput, DropDownGroupUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutTranslationsInput
    connect?: DropDownGroupWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutDropdownGroupsNestedInput = {
    create?: XOR<LanguageCreateWithoutDropdownGroupsInput, LanguageUncheckedCreateWithoutDropdownGroupsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutDropdownGroupsInput
    upsert?: LanguageUpsertWithoutDropdownGroupsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutDropdownGroupsInput, LanguageUpdateWithoutDropdownGroupsInput>, LanguageUncheckedUpdateWithoutDropdownGroupsInput>
  }

  export type DropDownGroupUpdateOneWithoutTranslationsNestedInput = {
    create?: XOR<DropDownGroupCreateWithoutTranslationsInput, DropDownGroupUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutTranslationsInput
    upsert?: DropDownGroupUpsertWithoutTranslationsInput
    disconnect?: DropDownGroupWhereInput | boolean
    delete?: DropDownGroupWhereInput | boolean
    connect?: DropDownGroupWhereUniqueInput
    update?: XOR<XOR<DropDownGroupUpdateToOneWithWhereWithoutTranslationsInput, DropDownGroupUpdateWithoutTranslationsInput>, DropDownGroupUncheckedUpdateWithoutTranslationsInput>
  }

  export type DropdownItemTranslationCreateNestedManyWithoutDropdownItemInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutDropdownItemInput, DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput> | DropdownItemTranslationCreateWithoutDropdownItemInput[] | DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput | DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput[]
    createMany?: DropdownItemTranslationCreateManyDropdownItemInputEnvelope
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
  }

  export type DropDownGroupCreateNestedOneWithoutDropdownItemsInput = {
    create?: XOR<DropDownGroupCreateWithoutDropdownItemsInput, DropDownGroupUncheckedCreateWithoutDropdownItemsInput>
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutDropdownItemsInput
    connect?: DropDownGroupWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutDropdownItemInput = {
    create?: XOR<PageCreateWithoutDropdownItemInput, PageUncheckedCreateWithoutDropdownItemInput>
    connectOrCreate?: PageCreateOrConnectWithoutDropdownItemInput
    connect?: PageWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutDropdownItemInput = {
    create?: XOR<ArticleCreateWithoutDropdownItemInput, ArticleUncheckedCreateWithoutDropdownItemInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutDropdownItemInput
    connect?: ArticleWhereUniqueInput
  }

  export type NavbarItemCreateNestedOneWithoutDropdownItemsInput = {
    create?: XOR<NavbarItemCreateWithoutDropdownItemsInput, NavbarItemUncheckedCreateWithoutDropdownItemsInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutDropdownItemsInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type DropdownItemTranslationUncheckedCreateNestedManyWithoutDropdownItemInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutDropdownItemInput, DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput> | DropdownItemTranslationCreateWithoutDropdownItemInput[] | DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput | DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput[]
    createMany?: DropdownItemTranslationCreateManyDropdownItemInputEnvelope
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
  }

  export type DropdownItemTranslationUpdateManyWithoutDropdownItemNestedInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutDropdownItemInput, DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput> | DropdownItemTranslationCreateWithoutDropdownItemInput[] | DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput | DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput[]
    upsert?: DropdownItemTranslationUpsertWithWhereUniqueWithoutDropdownItemInput | DropdownItemTranslationUpsertWithWhereUniqueWithoutDropdownItemInput[]
    createMany?: DropdownItemTranslationCreateManyDropdownItemInputEnvelope
    set?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    disconnect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    delete?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    update?: DropdownItemTranslationUpdateWithWhereUniqueWithoutDropdownItemInput | DropdownItemTranslationUpdateWithWhereUniqueWithoutDropdownItemInput[]
    updateMany?: DropdownItemTranslationUpdateManyWithWhereWithoutDropdownItemInput | DropdownItemTranslationUpdateManyWithWhereWithoutDropdownItemInput[]
    deleteMany?: DropdownItemTranslationScalarWhereInput | DropdownItemTranslationScalarWhereInput[]
  }

  export type DropDownGroupUpdateOneWithoutDropdownItemsNestedInput = {
    create?: XOR<DropDownGroupCreateWithoutDropdownItemsInput, DropDownGroupUncheckedCreateWithoutDropdownItemsInput>
    connectOrCreate?: DropDownGroupCreateOrConnectWithoutDropdownItemsInput
    upsert?: DropDownGroupUpsertWithoutDropdownItemsInput
    disconnect?: DropDownGroupWhereInput | boolean
    delete?: DropDownGroupWhereInput | boolean
    connect?: DropDownGroupWhereUniqueInput
    update?: XOR<XOR<DropDownGroupUpdateToOneWithWhereWithoutDropdownItemsInput, DropDownGroupUpdateWithoutDropdownItemsInput>, DropDownGroupUncheckedUpdateWithoutDropdownItemsInput>
  }

  export type PageUpdateOneWithoutDropdownItemNestedInput = {
    create?: XOR<PageCreateWithoutDropdownItemInput, PageUncheckedCreateWithoutDropdownItemInput>
    connectOrCreate?: PageCreateOrConnectWithoutDropdownItemInput
    upsert?: PageUpsertWithoutDropdownItemInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutDropdownItemInput, PageUpdateWithoutDropdownItemInput>, PageUncheckedUpdateWithoutDropdownItemInput>
  }

  export type ArticleUpdateOneWithoutDropdownItemNestedInput = {
    create?: XOR<ArticleCreateWithoutDropdownItemInput, ArticleUncheckedCreateWithoutDropdownItemInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutDropdownItemInput
    upsert?: ArticleUpsertWithoutDropdownItemInput
    disconnect?: ArticleWhereInput | boolean
    delete?: ArticleWhereInput | boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutDropdownItemInput, ArticleUpdateWithoutDropdownItemInput>, ArticleUncheckedUpdateWithoutDropdownItemInput>
  }

  export type NavbarItemUpdateOneWithoutDropdownItemsNestedInput = {
    create?: XOR<NavbarItemCreateWithoutDropdownItemsInput, NavbarItemUncheckedCreateWithoutDropdownItemsInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutDropdownItemsInput
    upsert?: NavbarItemUpsertWithoutDropdownItemsInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutDropdownItemsInput, NavbarItemUpdateWithoutDropdownItemsInput>, NavbarItemUncheckedUpdateWithoutDropdownItemsInput>
  }

  export type DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemNestedInput = {
    create?: XOR<DropdownItemTranslationCreateWithoutDropdownItemInput, DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput> | DropdownItemTranslationCreateWithoutDropdownItemInput[] | DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput[]
    connectOrCreate?: DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput | DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput[]
    upsert?: DropdownItemTranslationUpsertWithWhereUniqueWithoutDropdownItemInput | DropdownItemTranslationUpsertWithWhereUniqueWithoutDropdownItemInput[]
    createMany?: DropdownItemTranslationCreateManyDropdownItemInputEnvelope
    set?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    disconnect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    delete?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    connect?: DropdownItemTranslationWhereUniqueInput | DropdownItemTranslationWhereUniqueInput[]
    update?: DropdownItemTranslationUpdateWithWhereUniqueWithoutDropdownItemInput | DropdownItemTranslationUpdateWithWhereUniqueWithoutDropdownItemInput[]
    updateMany?: DropdownItemTranslationUpdateManyWithWhereWithoutDropdownItemInput | DropdownItemTranslationUpdateManyWithWhereWithoutDropdownItemInput[]
    deleteMany?: DropdownItemTranslationScalarWhereInput | DropdownItemTranslationScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutDropdownItemsInput = {
    create?: XOR<LanguageCreateWithoutDropdownItemsInput, LanguageUncheckedCreateWithoutDropdownItemsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutDropdownItemsInput
    connect?: LanguageWhereUniqueInput
  }

  export type DropdownItemCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<DropdownItemCreateWithoutTranslationsInput, DropdownItemUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutTranslationsInput
    connect?: DropdownItemWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutDropdownItemsNestedInput = {
    create?: XOR<LanguageCreateWithoutDropdownItemsInput, LanguageUncheckedCreateWithoutDropdownItemsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutDropdownItemsInput
    upsert?: LanguageUpsertWithoutDropdownItemsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutDropdownItemsInput, LanguageUpdateWithoutDropdownItemsInput>, LanguageUncheckedUpdateWithoutDropdownItemsInput>
  }

  export type DropdownItemUpdateOneWithoutTranslationsNestedInput = {
    create?: XOR<DropdownItemCreateWithoutTranslationsInput, DropdownItemUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutTranslationsInput
    upsert?: DropdownItemUpsertWithoutTranslationsInput
    disconnect?: DropdownItemWhereInput | boolean
    delete?: DropdownItemWhereInput | boolean
    connect?: DropdownItemWhereUniqueInput
    update?: XOR<XOR<DropdownItemUpdateToOneWithWhereWithoutTranslationsInput, DropdownItemUpdateWithoutTranslationsInput>, DropdownItemUncheckedUpdateWithoutTranslationsInput>
  }

  export type FooterTranslationCreateNestedManyWithoutFooterInput = {
    create?: XOR<FooterTranslationCreateWithoutFooterInput, FooterTranslationUncheckedCreateWithoutFooterInput> | FooterTranslationCreateWithoutFooterInput[] | FooterTranslationUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutFooterInput | FooterTranslationCreateOrConnectWithoutFooterInput[]
    createMany?: FooterTranslationCreateManyFooterInputEnvelope
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
  }

  export type GroupFooterCreateNestedManyWithoutFooterInput = {
    create?: XOR<GroupFooterCreateWithoutFooterInput, GroupFooterUncheckedCreateWithoutFooterInput> | GroupFooterCreateWithoutFooterInput[] | GroupFooterUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: GroupFooterCreateOrConnectWithoutFooterInput | GroupFooterCreateOrConnectWithoutFooterInput[]
    createMany?: GroupFooterCreateManyFooterInputEnvelope
    connect?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutFooterInput = {
    create?: XOR<ArticleCreateWithoutFooterInput, ArticleUncheckedCreateWithoutFooterInput> | ArticleCreateWithoutFooterInput[] | ArticleUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutFooterInput | ArticleCreateOrConnectWithoutFooterInput[]
    createMany?: ArticleCreateManyFooterInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type FooterTranslationUncheckedCreateNestedManyWithoutFooterInput = {
    create?: XOR<FooterTranslationCreateWithoutFooterInput, FooterTranslationUncheckedCreateWithoutFooterInput> | FooterTranslationCreateWithoutFooterInput[] | FooterTranslationUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutFooterInput | FooterTranslationCreateOrConnectWithoutFooterInput[]
    createMany?: FooterTranslationCreateManyFooterInputEnvelope
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
  }

  export type GroupFooterUncheckedCreateNestedManyWithoutFooterInput = {
    create?: XOR<GroupFooterCreateWithoutFooterInput, GroupFooterUncheckedCreateWithoutFooterInput> | GroupFooterCreateWithoutFooterInput[] | GroupFooterUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: GroupFooterCreateOrConnectWithoutFooterInput | GroupFooterCreateOrConnectWithoutFooterInput[]
    createMany?: GroupFooterCreateManyFooterInputEnvelope
    connect?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutFooterInput = {
    create?: XOR<ArticleCreateWithoutFooterInput, ArticleUncheckedCreateWithoutFooterInput> | ArticleCreateWithoutFooterInput[] | ArticleUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutFooterInput | ArticleCreateOrConnectWithoutFooterInput[]
    createMany?: ArticleCreateManyFooterInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type FooterTranslationUpdateManyWithoutFooterNestedInput = {
    create?: XOR<FooterTranslationCreateWithoutFooterInput, FooterTranslationUncheckedCreateWithoutFooterInput> | FooterTranslationCreateWithoutFooterInput[] | FooterTranslationUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutFooterInput | FooterTranslationCreateOrConnectWithoutFooterInput[]
    upsert?: FooterTranslationUpsertWithWhereUniqueWithoutFooterInput | FooterTranslationUpsertWithWhereUniqueWithoutFooterInput[]
    createMany?: FooterTranslationCreateManyFooterInputEnvelope
    set?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    disconnect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    delete?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    update?: FooterTranslationUpdateWithWhereUniqueWithoutFooterInput | FooterTranslationUpdateWithWhereUniqueWithoutFooterInput[]
    updateMany?: FooterTranslationUpdateManyWithWhereWithoutFooterInput | FooterTranslationUpdateManyWithWhereWithoutFooterInput[]
    deleteMany?: FooterTranslationScalarWhereInput | FooterTranslationScalarWhereInput[]
  }

  export type GroupFooterUpdateManyWithoutFooterNestedInput = {
    create?: XOR<GroupFooterCreateWithoutFooterInput, GroupFooterUncheckedCreateWithoutFooterInput> | GroupFooterCreateWithoutFooterInput[] | GroupFooterUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: GroupFooterCreateOrConnectWithoutFooterInput | GroupFooterCreateOrConnectWithoutFooterInput[]
    upsert?: GroupFooterUpsertWithWhereUniqueWithoutFooterInput | GroupFooterUpsertWithWhereUniqueWithoutFooterInput[]
    createMany?: GroupFooterCreateManyFooterInputEnvelope
    set?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    disconnect?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    delete?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    connect?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    update?: GroupFooterUpdateWithWhereUniqueWithoutFooterInput | GroupFooterUpdateWithWhereUniqueWithoutFooterInput[]
    updateMany?: GroupFooterUpdateManyWithWhereWithoutFooterInput | GroupFooterUpdateManyWithWhereWithoutFooterInput[]
    deleteMany?: GroupFooterScalarWhereInput | GroupFooterScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutFooterNestedInput = {
    create?: XOR<ArticleCreateWithoutFooterInput, ArticleUncheckedCreateWithoutFooterInput> | ArticleCreateWithoutFooterInput[] | ArticleUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutFooterInput | ArticleCreateOrConnectWithoutFooterInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutFooterInput | ArticleUpsertWithWhereUniqueWithoutFooterInput[]
    createMany?: ArticleCreateManyFooterInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutFooterInput | ArticleUpdateWithWhereUniqueWithoutFooterInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutFooterInput | ArticleUpdateManyWithWhereWithoutFooterInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type FooterTranslationUncheckedUpdateManyWithoutFooterNestedInput = {
    create?: XOR<FooterTranslationCreateWithoutFooterInput, FooterTranslationUncheckedCreateWithoutFooterInput> | FooterTranslationCreateWithoutFooterInput[] | FooterTranslationUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: FooterTranslationCreateOrConnectWithoutFooterInput | FooterTranslationCreateOrConnectWithoutFooterInput[]
    upsert?: FooterTranslationUpsertWithWhereUniqueWithoutFooterInput | FooterTranslationUpsertWithWhereUniqueWithoutFooterInput[]
    createMany?: FooterTranslationCreateManyFooterInputEnvelope
    set?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    disconnect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    delete?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    connect?: FooterTranslationWhereUniqueInput | FooterTranslationWhereUniqueInput[]
    update?: FooterTranslationUpdateWithWhereUniqueWithoutFooterInput | FooterTranslationUpdateWithWhereUniqueWithoutFooterInput[]
    updateMany?: FooterTranslationUpdateManyWithWhereWithoutFooterInput | FooterTranslationUpdateManyWithWhereWithoutFooterInput[]
    deleteMany?: FooterTranslationScalarWhereInput | FooterTranslationScalarWhereInput[]
  }

  export type GroupFooterUncheckedUpdateManyWithoutFooterNestedInput = {
    create?: XOR<GroupFooterCreateWithoutFooterInput, GroupFooterUncheckedCreateWithoutFooterInput> | GroupFooterCreateWithoutFooterInput[] | GroupFooterUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: GroupFooterCreateOrConnectWithoutFooterInput | GroupFooterCreateOrConnectWithoutFooterInput[]
    upsert?: GroupFooterUpsertWithWhereUniqueWithoutFooterInput | GroupFooterUpsertWithWhereUniqueWithoutFooterInput[]
    createMany?: GroupFooterCreateManyFooterInputEnvelope
    set?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    disconnect?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    delete?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    connect?: GroupFooterWhereUniqueInput | GroupFooterWhereUniqueInput[]
    update?: GroupFooterUpdateWithWhereUniqueWithoutFooterInput | GroupFooterUpdateWithWhereUniqueWithoutFooterInput[]
    updateMany?: GroupFooterUpdateManyWithWhereWithoutFooterInput | GroupFooterUpdateManyWithWhereWithoutFooterInput[]
    deleteMany?: GroupFooterScalarWhereInput | GroupFooterScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutFooterNestedInput = {
    create?: XOR<ArticleCreateWithoutFooterInput, ArticleUncheckedCreateWithoutFooterInput> | ArticleCreateWithoutFooterInput[] | ArticleUncheckedCreateWithoutFooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutFooterInput | ArticleCreateOrConnectWithoutFooterInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutFooterInput | ArticleUpsertWithWhereUniqueWithoutFooterInput[]
    createMany?: ArticleCreateManyFooterInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutFooterInput | ArticleUpdateWithWhereUniqueWithoutFooterInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutFooterInput | ArticleUpdateManyWithWhereWithoutFooterInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutFootersInput = {
    create?: XOR<LanguageCreateWithoutFootersInput, LanguageUncheckedCreateWithoutFootersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutFootersInput
    connect?: LanguageWhereUniqueInput
  }

  export type FooterCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<FooterCreateWithoutTranslationsInput, FooterUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: FooterCreateOrConnectWithoutTranslationsInput
    connect?: FooterWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutFootersNestedInput = {
    create?: XOR<LanguageCreateWithoutFootersInput, LanguageUncheckedCreateWithoutFootersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutFootersInput
    upsert?: LanguageUpsertWithoutFootersInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutFootersInput, LanguageUpdateWithoutFootersInput>, LanguageUncheckedUpdateWithoutFootersInput>
  }

  export type FooterUpdateOneWithoutTranslationsNestedInput = {
    create?: XOR<FooterCreateWithoutTranslationsInput, FooterUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: FooterCreateOrConnectWithoutTranslationsInput
    upsert?: FooterUpsertWithoutTranslationsInput
    disconnect?: FooterWhereInput | boolean
    delete?: FooterWhereInput | boolean
    connect?: FooterWhereUniqueInput
    update?: XOR<XOR<FooterUpdateToOneWithWhereWithoutTranslationsInput, FooterUpdateWithoutTranslationsInput>, FooterUncheckedUpdateWithoutTranslationsInput>
  }

  export type GroupFooterTranslationCreateNestedManyWithoutGroupfooterInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutGroupfooterInput, GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput> | GroupFooterTranslationCreateWithoutGroupfooterInput[] | GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput | GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput[]
    createMany?: GroupFooterTranslationCreateManyGroupfooterInputEnvelope
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
  }

  export type FooterCreateNestedOneWithoutGroupsInput = {
    create?: XOR<FooterCreateWithoutGroupsInput, FooterUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: FooterCreateOrConnectWithoutGroupsInput
    connect?: FooterWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutGroupfooterInput = {
    create?: XOR<ArticleCreateWithoutGroupfooterInput, ArticleUncheckedCreateWithoutGroupfooterInput> | ArticleCreateWithoutGroupfooterInput[] | ArticleUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupfooterInput | ArticleCreateOrConnectWithoutGroupfooterInput[]
    createMany?: ArticleCreateManyGroupfooterInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutGroupFooterInput = {
    create?: XOR<PageCreateWithoutGroupFooterInput, PageUncheckedCreateWithoutGroupFooterInput> | PageCreateWithoutGroupFooterInput[] | PageUncheckedCreateWithoutGroupFooterInput[]
    connectOrCreate?: PageCreateOrConnectWithoutGroupFooterInput | PageCreateOrConnectWithoutGroupFooterInput[]
    createMany?: PageCreateManyGroupFooterInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type GroupFooterTranslationUncheckedCreateNestedManyWithoutGroupfooterInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutGroupfooterInput, GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput> | GroupFooterTranslationCreateWithoutGroupfooterInput[] | GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput | GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput[]
    createMany?: GroupFooterTranslationCreateManyGroupfooterInputEnvelope
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutGroupfooterInput = {
    create?: XOR<ArticleCreateWithoutGroupfooterInput, ArticleUncheckedCreateWithoutGroupfooterInput> | ArticleCreateWithoutGroupfooterInput[] | ArticleUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupfooterInput | ArticleCreateOrConnectWithoutGroupfooterInput[]
    createMany?: ArticleCreateManyGroupfooterInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutGroupFooterInput = {
    create?: XOR<PageCreateWithoutGroupFooterInput, PageUncheckedCreateWithoutGroupFooterInput> | PageCreateWithoutGroupFooterInput[] | PageUncheckedCreateWithoutGroupFooterInput[]
    connectOrCreate?: PageCreateOrConnectWithoutGroupFooterInput | PageCreateOrConnectWithoutGroupFooterInput[]
    createMany?: PageCreateManyGroupFooterInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type GroupFooterTranslationUpdateManyWithoutGroupfooterNestedInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutGroupfooterInput, GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput> | GroupFooterTranslationCreateWithoutGroupfooterInput[] | GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput | GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput[]
    upsert?: GroupFooterTranslationUpsertWithWhereUniqueWithoutGroupfooterInput | GroupFooterTranslationUpsertWithWhereUniqueWithoutGroupfooterInput[]
    createMany?: GroupFooterTranslationCreateManyGroupfooterInputEnvelope
    set?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    disconnect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    delete?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    update?: GroupFooterTranslationUpdateWithWhereUniqueWithoutGroupfooterInput | GroupFooterTranslationUpdateWithWhereUniqueWithoutGroupfooterInput[]
    updateMany?: GroupFooterTranslationUpdateManyWithWhereWithoutGroupfooterInput | GroupFooterTranslationUpdateManyWithWhereWithoutGroupfooterInput[]
    deleteMany?: GroupFooterTranslationScalarWhereInput | GroupFooterTranslationScalarWhereInput[]
  }

  export type FooterUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<FooterCreateWithoutGroupsInput, FooterUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: FooterCreateOrConnectWithoutGroupsInput
    upsert?: FooterUpsertWithoutGroupsInput
    disconnect?: FooterWhereInput | boolean
    delete?: FooterWhereInput | boolean
    connect?: FooterWhereUniqueInput
    update?: XOR<XOR<FooterUpdateToOneWithWhereWithoutGroupsInput, FooterUpdateWithoutGroupsInput>, FooterUncheckedUpdateWithoutGroupsInput>
  }

  export type ArticleUpdateManyWithoutGroupfooterNestedInput = {
    create?: XOR<ArticleCreateWithoutGroupfooterInput, ArticleUncheckedCreateWithoutGroupfooterInput> | ArticleCreateWithoutGroupfooterInput[] | ArticleUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupfooterInput | ArticleCreateOrConnectWithoutGroupfooterInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutGroupfooterInput | ArticleUpsertWithWhereUniqueWithoutGroupfooterInput[]
    createMany?: ArticleCreateManyGroupfooterInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutGroupfooterInput | ArticleUpdateWithWhereUniqueWithoutGroupfooterInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutGroupfooterInput | ArticleUpdateManyWithWhereWithoutGroupfooterInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type PageUpdateManyWithoutGroupFooterNestedInput = {
    create?: XOR<PageCreateWithoutGroupFooterInput, PageUncheckedCreateWithoutGroupFooterInput> | PageCreateWithoutGroupFooterInput[] | PageUncheckedCreateWithoutGroupFooterInput[]
    connectOrCreate?: PageCreateOrConnectWithoutGroupFooterInput | PageCreateOrConnectWithoutGroupFooterInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutGroupFooterInput | PageUpsertWithWhereUniqueWithoutGroupFooterInput[]
    createMany?: PageCreateManyGroupFooterInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutGroupFooterInput | PageUpdateWithWhereUniqueWithoutGroupFooterInput[]
    updateMany?: PageUpdateManyWithWhereWithoutGroupFooterInput | PageUpdateManyWithWhereWithoutGroupFooterInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterNestedInput = {
    create?: XOR<GroupFooterTranslationCreateWithoutGroupfooterInput, GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput> | GroupFooterTranslationCreateWithoutGroupfooterInput[] | GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput | GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput[]
    upsert?: GroupFooterTranslationUpsertWithWhereUniqueWithoutGroupfooterInput | GroupFooterTranslationUpsertWithWhereUniqueWithoutGroupfooterInput[]
    createMany?: GroupFooterTranslationCreateManyGroupfooterInputEnvelope
    set?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    disconnect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    delete?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    connect?: GroupFooterTranslationWhereUniqueInput | GroupFooterTranslationWhereUniqueInput[]
    update?: GroupFooterTranslationUpdateWithWhereUniqueWithoutGroupfooterInput | GroupFooterTranslationUpdateWithWhereUniqueWithoutGroupfooterInput[]
    updateMany?: GroupFooterTranslationUpdateManyWithWhereWithoutGroupfooterInput | GroupFooterTranslationUpdateManyWithWhereWithoutGroupfooterInput[]
    deleteMany?: GroupFooterTranslationScalarWhereInput | GroupFooterTranslationScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutGroupfooterNestedInput = {
    create?: XOR<ArticleCreateWithoutGroupfooterInput, ArticleUncheckedCreateWithoutGroupfooterInput> | ArticleCreateWithoutGroupfooterInput[] | ArticleUncheckedCreateWithoutGroupfooterInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupfooterInput | ArticleCreateOrConnectWithoutGroupfooterInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutGroupfooterInput | ArticleUpsertWithWhereUniqueWithoutGroupfooterInput[]
    createMany?: ArticleCreateManyGroupfooterInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutGroupfooterInput | ArticleUpdateWithWhereUniqueWithoutGroupfooterInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutGroupfooterInput | ArticleUpdateManyWithWhereWithoutGroupfooterInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutGroupFooterNestedInput = {
    create?: XOR<PageCreateWithoutGroupFooterInput, PageUncheckedCreateWithoutGroupFooterInput> | PageCreateWithoutGroupFooterInput[] | PageUncheckedCreateWithoutGroupFooterInput[]
    connectOrCreate?: PageCreateOrConnectWithoutGroupFooterInput | PageCreateOrConnectWithoutGroupFooterInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutGroupFooterInput | PageUpsertWithWhereUniqueWithoutGroupFooterInput[]
    createMany?: PageCreateManyGroupFooterInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutGroupFooterInput | PageUpdateWithWhereUniqueWithoutGroupFooterInput[]
    updateMany?: PageUpdateManyWithWhereWithoutGroupFooterInput | PageUpdateManyWithWhereWithoutGroupFooterInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type GroupFooterCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<GroupFooterCreateWithoutTranslationsInput, GroupFooterUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: GroupFooterCreateOrConnectWithoutTranslationsInput
    connect?: GroupFooterWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutGroupFootersInput = {
    create?: XOR<LanguageCreateWithoutGroupFootersInput, LanguageUncheckedCreateWithoutGroupFootersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutGroupFootersInput
    connect?: LanguageWhereUniqueInput
  }

  export type GroupFooterUpdateOneWithoutTranslationsNestedInput = {
    create?: XOR<GroupFooterCreateWithoutTranslationsInput, GroupFooterUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: GroupFooterCreateOrConnectWithoutTranslationsInput
    upsert?: GroupFooterUpsertWithoutTranslationsInput
    disconnect?: GroupFooterWhereInput | boolean
    delete?: GroupFooterWhereInput | boolean
    connect?: GroupFooterWhereUniqueInput
    update?: XOR<XOR<GroupFooterUpdateToOneWithWhereWithoutTranslationsInput, GroupFooterUpdateWithoutTranslationsInput>, GroupFooterUncheckedUpdateWithoutTranslationsInput>
  }

  export type LanguageUpdateOneRequiredWithoutGroupFootersNestedInput = {
    create?: XOR<LanguageCreateWithoutGroupFootersInput, LanguageUncheckedCreateWithoutGroupFootersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutGroupFootersInput
    upsert?: LanguageUpsertWithoutGroupFootersInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutGroupFootersInput, LanguageUpdateWithoutGroupFootersInput>, LanguageUncheckedUpdateWithoutGroupFootersInput>
  }

  export type PageTranslationCreateNestedManyWithoutPageInput = {
    create?: XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput> | PageTranslationCreateWithoutPageInput[] | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutPageInput | PageTranslationCreateOrConnectWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type NavbarItemCreateNestedOneWithoutPageInput = {
    create?: XOR<NavbarItemCreateWithoutPageInput, NavbarItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutPageInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type DropdownItemCreateNestedOneWithoutPageInput = {
    create?: XOR<DropdownItemCreateWithoutPageInput, DropdownItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutPageInput
    connect?: DropdownItemWhereUniqueInput
  }

  export type GroupFooterCreateNestedOneWithoutPagesInput = {
    create?: XOR<GroupFooterCreateWithoutPagesInput, GroupFooterUncheckedCreateWithoutPagesInput>
    connectOrCreate?: GroupFooterCreateOrConnectWithoutPagesInput
    connect?: GroupFooterWhereUniqueInput
  }

  export type PageTranslationUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput> | PageTranslationCreateWithoutPageInput[] | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutPageInput | PageTranslationCreateOrConnectWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type NavbarItemUncheckedCreateNestedOneWithoutPageInput = {
    create?: XOR<NavbarItemCreateWithoutPageInput, NavbarItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutPageInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type DropdownItemUncheckedCreateNestedOneWithoutPageInput = {
    create?: XOR<DropdownItemCreateWithoutPageInput, DropdownItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutPageInput
    connect?: DropdownItemWhereUniqueInput
  }

  export type PageTranslationUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput> | PageTranslationCreateWithoutPageInput[] | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutPageInput | PageTranslationCreateOrConnectWithoutPageInput[]
    upsert?: PageTranslationUpsertWithWhereUniqueWithoutPageInput | PageTranslationUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?: PageTranslationUpdateWithWhereUniqueWithoutPageInput | PageTranslationUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageTranslationUpdateManyWithWhereWithoutPageInput | PageTranslationUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type NavbarItemUpdateOneWithoutPageNestedInput = {
    create?: XOR<NavbarItemCreateWithoutPageInput, NavbarItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutPageInput
    upsert?: NavbarItemUpsertWithoutPageInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutPageInput, NavbarItemUpdateWithoutPageInput>, NavbarItemUncheckedUpdateWithoutPageInput>
  }

  export type DropdownItemUpdateOneWithoutPageNestedInput = {
    create?: XOR<DropdownItemCreateWithoutPageInput, DropdownItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutPageInput
    upsert?: DropdownItemUpsertWithoutPageInput
    disconnect?: DropdownItemWhereInput | boolean
    delete?: DropdownItemWhereInput | boolean
    connect?: DropdownItemWhereUniqueInput
    update?: XOR<XOR<DropdownItemUpdateToOneWithWhereWithoutPageInput, DropdownItemUpdateWithoutPageInput>, DropdownItemUncheckedUpdateWithoutPageInput>
  }

  export type GroupFooterUpdateOneWithoutPagesNestedInput = {
    create?: XOR<GroupFooterCreateWithoutPagesInput, GroupFooterUncheckedCreateWithoutPagesInput>
    connectOrCreate?: GroupFooterCreateOrConnectWithoutPagesInput
    upsert?: GroupFooterUpsertWithoutPagesInput
    disconnect?: GroupFooterWhereInput | boolean
    delete?: GroupFooterWhereInput | boolean
    connect?: GroupFooterWhereUniqueInput
    update?: XOR<XOR<GroupFooterUpdateToOneWithWhereWithoutPagesInput, GroupFooterUpdateWithoutPagesInput>, GroupFooterUncheckedUpdateWithoutPagesInput>
  }

  export type PageTranslationUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput> | PageTranslationCreateWithoutPageInput[] | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTranslationCreateOrConnectWithoutPageInput | PageTranslationCreateOrConnectWithoutPageInput[]
    upsert?: PageTranslationUpsertWithWhereUniqueWithoutPageInput | PageTranslationUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?: PageTranslationUpdateWithWhereUniqueWithoutPageInput | PageTranslationUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageTranslationUpdateManyWithWhereWithoutPageInput | PageTranslationUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type NavbarItemUncheckedUpdateOneWithoutPageNestedInput = {
    create?: XOR<NavbarItemCreateWithoutPageInput, NavbarItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutPageInput
    upsert?: NavbarItemUpsertWithoutPageInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutPageInput, NavbarItemUpdateWithoutPageInput>, NavbarItemUncheckedUpdateWithoutPageInput>
  }

  export type DropdownItemUncheckedUpdateOneWithoutPageNestedInput = {
    create?: XOR<DropdownItemCreateWithoutPageInput, DropdownItemUncheckedCreateWithoutPageInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutPageInput
    upsert?: DropdownItemUpsertWithoutPageInput
    disconnect?: DropdownItemWhereInput | boolean
    delete?: DropdownItemWhereInput | boolean
    connect?: DropdownItemWhereUniqueInput
    update?: XOR<XOR<DropdownItemUpdateToOneWithWhereWithoutPageInput, DropdownItemUpdateWithoutPageInput>, DropdownItemUncheckedUpdateWithoutPageInput>
  }

  export type PageTranslationCreateimagesInput = {
    set: string[]
  }

  export type LanguageCreateNestedOneWithoutPagesInput = {
    create?: XOR<LanguageCreateWithoutPagesInput, LanguageUncheckedCreateWithoutPagesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutPagesInput
    connect?: LanguageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPagesInput = {
    create?: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesInput
    connect?: UserWhereUniqueInput
  }

  export type BlockCreateNestedManyWithoutPageInput = {
    create?: XOR<BlockCreateWithoutPageInput, BlockUncheckedCreateWithoutPageInput> | BlockCreateWithoutPageInput[] | BlockUncheckedCreateWithoutPageInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutPageInput | BlockCreateOrConnectWithoutPageInput[]
    createMany?: BlockCreateManyPageInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type PageCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: PageCreateOrConnectWithoutTranslationsInput
    connect?: PageWhereUniqueInput
  }

  export type BlockUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<BlockCreateWithoutPageInput, BlockUncheckedCreateWithoutPageInput> | BlockCreateWithoutPageInput[] | BlockUncheckedCreateWithoutPageInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutPageInput | BlockCreateOrConnectWithoutPageInput[]
    createMany?: BlockCreateManyPageInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type PageTranslationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<LanguageCreateWithoutPagesInput, LanguageUncheckedCreateWithoutPagesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutPagesInput
    upsert?: LanguageUpsertWithoutPagesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutPagesInput, LanguageUpdateWithoutPagesInput>, LanguageUncheckedUpdateWithoutPagesInput>
  }

  export type UserUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesInput
    upsert?: UserUpsertWithoutPagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPagesInput, UserUpdateWithoutPagesInput>, UserUncheckedUpdateWithoutPagesInput>
  }

  export type BlockUpdateManyWithoutPageNestedInput = {
    create?: XOR<BlockCreateWithoutPageInput, BlockUncheckedCreateWithoutPageInput> | BlockCreateWithoutPageInput[] | BlockUncheckedCreateWithoutPageInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutPageInput | BlockCreateOrConnectWithoutPageInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutPageInput | BlockUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: BlockCreateManyPageInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutPageInput | BlockUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutPageInput | BlockUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type PageUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: PageCreateOrConnectWithoutTranslationsInput
    upsert?: PageUpsertWithoutTranslationsInput
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutTranslationsInput, PageUpdateWithoutTranslationsInput>, PageUncheckedUpdateWithoutTranslationsInput>
  }

  export type BlockUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<BlockCreateWithoutPageInput, BlockUncheckedCreateWithoutPageInput> | BlockCreateWithoutPageInput[] | BlockUncheckedCreateWithoutPageInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutPageInput | BlockCreateOrConnectWithoutPageInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutPageInput | BlockUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: BlockCreateManyPageInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutPageInput | BlockUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutPageInput | BlockUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type CategoryTranslationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type CategoryTranslationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutCategoryInput | CategoryTranslationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutCategoryInput | ArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutCategoryInput | ArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutCategoryInput | ArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutCategoryInput | CategoryTranslationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutCategoryInput | ArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutCategoryInput | ArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutCategoryInput | ArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type CategoryTranslationCreateimagesInput = {
    set: string[]
  }

  export type LanguageCreateNestedOneWithoutCategoreisInput = {
    create?: XOR<LanguageCreateWithoutCategoreisInput, LanguageUncheckedCreateWithoutCategoreisInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCategoreisInput
    connect?: LanguageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTranslationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryTranslationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageUpdateOneRequiredWithoutCategoreisNestedInput = {
    create?: XOR<LanguageCreateWithoutCategoreisInput, LanguageUncheckedCreateWithoutCategoreisInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCategoreisInput
    upsert?: LanguageUpsertWithoutCategoreisInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutCategoreisInput, LanguageUpdateWithoutCategoreisInput>, LanguageUncheckedUpdateWithoutCategoreisInput>
  }

  export type UserUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    upsert?: UserUpsertWithoutCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCategoriesInput, UserUpdateWithoutCategoriesInput>, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTranslationsInput
    upsert?: CategoryUpsertWithoutTranslationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTranslationsInput, CategoryUpdateWithoutTranslationsInput>, CategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type ArticleTranslationCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleTranslationCreateWithoutArticleInput, ArticleTranslationUncheckedCreateWithoutArticleInput> | ArticleTranslationCreateWithoutArticleInput[] | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutArticleInput | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutArticlesInput
    connect?: CategoryWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutArticlesInput = {
    create?: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput> | TagCreateWithoutArticlesInput[] | TagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArticlesInput | TagCreateOrConnectWithoutArticlesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FooterCreateNestedOneWithoutArticlesInput = {
    create?: XOR<FooterCreateWithoutArticlesInput, FooterUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: FooterCreateOrConnectWithoutArticlesInput
    connect?: FooterWhereUniqueInput
  }

  export type GroupFooterCreateNestedOneWithoutArticlesInput = {
    create?: XOR<GroupFooterCreateWithoutArticlesInput, GroupFooterUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: GroupFooterCreateOrConnectWithoutArticlesInput
    connect?: GroupFooterWhereUniqueInput
  }

  export type NavbarItemCreateNestedOneWithoutArticleInput = {
    create?: XOR<NavbarItemCreateWithoutArticleInput, NavbarItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutArticleInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type DropdownItemCreateNestedOneWithoutArticleInput = {
    create?: XOR<DropdownItemCreateWithoutArticleInput, DropdownItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutArticleInput
    connect?: DropdownItemWhereUniqueInput
  }

  export type ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleTranslationCreateWithoutArticleInput, ArticleTranslationUncheckedCreateWithoutArticleInput> | ArticleTranslationCreateWithoutArticleInput[] | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutArticleInput | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutArticlesInput = {
    create?: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput> | TagCreateWithoutArticlesInput[] | TagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArticlesInput | TagCreateOrConnectWithoutArticlesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NavbarItemUncheckedCreateNestedOneWithoutArticleInput = {
    create?: XOR<NavbarItemCreateWithoutArticleInput, NavbarItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutArticleInput
    connect?: NavbarItemWhereUniqueInput
  }

  export type DropdownItemUncheckedCreateNestedOneWithoutArticleInput = {
    create?: XOR<DropdownItemCreateWithoutArticleInput, DropdownItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutArticleInput
    connect?: DropdownItemWhereUniqueInput
  }

  export type ArticleTranslationUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutArticleInput, ArticleTranslationUncheckedCreateWithoutArticleInput> | ArticleTranslationCreateWithoutArticleInput[] | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutArticleInput | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput | ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?: ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput | ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleTranslationUpdateManyWithWhereWithoutArticleInput | ArticleTranslationUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutArticlesInput
    upsert?: CategoryUpsertWithoutArticlesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutArticlesInput, CategoryUpdateWithoutArticlesInput>, CategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type TagUpdateManyWithoutArticlesNestedInput = {
    create?: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput> | TagCreateWithoutArticlesInput[] | TagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArticlesInput | TagCreateOrConnectWithoutArticlesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutArticlesInput | TagUpsertWithWhereUniqueWithoutArticlesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutArticlesInput | TagUpdateWithWhereUniqueWithoutArticlesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutArticlesInput | TagUpdateManyWithWhereWithoutArticlesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutArticleInput | CommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutArticleInput | CommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutArticleInput | CommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FooterUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<FooterCreateWithoutArticlesInput, FooterUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: FooterCreateOrConnectWithoutArticlesInput
    upsert?: FooterUpsertWithoutArticlesInput
    disconnect?: FooterWhereInput | boolean
    delete?: FooterWhereInput | boolean
    connect?: FooterWhereUniqueInput
    update?: XOR<XOR<FooterUpdateToOneWithWhereWithoutArticlesInput, FooterUpdateWithoutArticlesInput>, FooterUncheckedUpdateWithoutArticlesInput>
  }

  export type GroupFooterUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<GroupFooterCreateWithoutArticlesInput, GroupFooterUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: GroupFooterCreateOrConnectWithoutArticlesInput
    upsert?: GroupFooterUpsertWithoutArticlesInput
    disconnect?: GroupFooterWhereInput | boolean
    delete?: GroupFooterWhereInput | boolean
    connect?: GroupFooterWhereUniqueInput
    update?: XOR<XOR<GroupFooterUpdateToOneWithWhereWithoutArticlesInput, GroupFooterUpdateWithoutArticlesInput>, GroupFooterUncheckedUpdateWithoutArticlesInput>
  }

  export type NavbarItemUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NavbarItemCreateWithoutArticleInput, NavbarItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutArticleInput
    upsert?: NavbarItemUpsertWithoutArticleInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutArticleInput, NavbarItemUpdateWithoutArticleInput>, NavbarItemUncheckedUpdateWithoutArticleInput>
  }

  export type DropdownItemUpdateOneWithoutArticleNestedInput = {
    create?: XOR<DropdownItemCreateWithoutArticleInput, DropdownItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutArticleInput
    upsert?: DropdownItemUpsertWithoutArticleInput
    disconnect?: DropdownItemWhereInput | boolean
    delete?: DropdownItemWhereInput | boolean
    connect?: DropdownItemWhereUniqueInput
    update?: XOR<XOR<DropdownItemUpdateToOneWithWhereWithoutArticleInput, DropdownItemUpdateWithoutArticleInput>, DropdownItemUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutArticleInput, ArticleTranslationUncheckedCreateWithoutArticleInput> | ArticleTranslationCreateWithoutArticleInput[] | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutArticleInput | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput | ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?: ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput | ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleTranslationUpdateManyWithWhereWithoutArticleInput | ArticleTranslationUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutArticlesNestedInput = {
    create?: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput> | TagCreateWithoutArticlesInput[] | TagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArticlesInput | TagCreateOrConnectWithoutArticlesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutArticlesInput | TagUpsertWithWhereUniqueWithoutArticlesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutArticlesInput | TagUpdateWithWhereUniqueWithoutArticlesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutArticlesInput | TagUpdateManyWithWhereWithoutArticlesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutArticleInput | CommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutArticleInput | CommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutArticleInput | CommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NavbarItemUncheckedUpdateOneWithoutArticleNestedInput = {
    create?: XOR<NavbarItemCreateWithoutArticleInput, NavbarItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: NavbarItemCreateOrConnectWithoutArticleInput
    upsert?: NavbarItemUpsertWithoutArticleInput
    disconnect?: NavbarItemWhereInput | boolean
    delete?: NavbarItemWhereInput | boolean
    connect?: NavbarItemWhereUniqueInput
    update?: XOR<XOR<NavbarItemUpdateToOneWithWhereWithoutArticleInput, NavbarItemUpdateWithoutArticleInput>, NavbarItemUncheckedUpdateWithoutArticleInput>
  }

  export type DropdownItemUncheckedUpdateOneWithoutArticleNestedInput = {
    create?: XOR<DropdownItemCreateWithoutArticleInput, DropdownItemUncheckedCreateWithoutArticleInput>
    connectOrCreate?: DropdownItemCreateOrConnectWithoutArticleInput
    upsert?: DropdownItemUpsertWithoutArticleInput
    disconnect?: DropdownItemWhereInput | boolean
    delete?: DropdownItemWhereInput | boolean
    connect?: DropdownItemWhereUniqueInput
    update?: XOR<XOR<DropdownItemUpdateToOneWithWhereWithoutArticleInput, DropdownItemUpdateWithoutArticleInput>, DropdownItemUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleTranslationCreateimagesInput = {
    set: string[]
  }

  export type LanguageCreateNestedOneWithoutArticlesInput = {
    create?: XOR<LanguageCreateWithoutArticlesInput, LanguageUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutArticlesInput
    connect?: LanguageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArticlesInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ArticleCreateWithoutTranslationsInput, ArticleUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutTranslationsInput
    connect?: ArticleWhereUniqueInput
  }

  export type BlockCreateNestedManyWithoutArticleInput = {
    create?: XOR<BlockCreateWithoutArticleInput, BlockUncheckedCreateWithoutArticleInput> | BlockCreateWithoutArticleInput[] | BlockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutArticleInput | BlockCreateOrConnectWithoutArticleInput[]
    createMany?: BlockCreateManyArticleInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<BlockCreateWithoutArticleInput, BlockUncheckedCreateWithoutArticleInput> | BlockCreateWithoutArticleInput[] | BlockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutArticleInput | BlockCreateOrConnectWithoutArticleInput[]
    createMany?: BlockCreateManyArticleInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ArticleTranslationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<LanguageCreateWithoutArticlesInput, LanguageUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutArticlesInput
    upsert?: LanguageUpsertWithoutArticlesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutArticlesInput, LanguageUpdateWithoutArticlesInput>, LanguageUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    upsert?: UserUpsertWithoutArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArticlesInput, UserUpdateWithoutArticlesInput>, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ArticleCreateWithoutTranslationsInput, ArticleUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutTranslationsInput
    upsert?: ArticleUpsertWithoutTranslationsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutTranslationsInput, ArticleUpdateWithoutTranslationsInput>, ArticleUncheckedUpdateWithoutTranslationsInput>
  }

  export type BlockUpdateManyWithoutArticleNestedInput = {
    create?: XOR<BlockCreateWithoutArticleInput, BlockUncheckedCreateWithoutArticleInput> | BlockCreateWithoutArticleInput[] | BlockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutArticleInput | BlockCreateOrConnectWithoutArticleInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutArticleInput | BlockUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: BlockCreateManyArticleInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutArticleInput | BlockUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutArticleInput | BlockUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<BlockCreateWithoutArticleInput, BlockUncheckedCreateWithoutArticleInput> | BlockCreateWithoutArticleInput[] | BlockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutArticleInput | BlockCreateOrConnectWithoutArticleInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutArticleInput | BlockUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: BlockCreateManyArticleInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutArticleInput | BlockUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutArticleInput | BlockUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type TagTranslationCreateNestedManyWithoutTagInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutTagsInput = {
    create?: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput> | ArticleCreateWithoutTagsInput[] | ArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutTagsInput | ArticleCreateOrConnectWithoutTagsInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type TagTranslationUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput> | ArticleCreateWithoutTagsInput[] | ArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutTagsInput | ArticleCreateOrConnectWithoutTagsInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type TagTranslationUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    upsert?: TagTranslationUpsertWithWhereUniqueWithoutTagInput | TagTranslationUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    set?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    disconnect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    delete?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    update?: TagTranslationUpdateWithWhereUniqueWithoutTagInput | TagTranslationUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagTranslationUpdateManyWithWhereWithoutTagInput | TagTranslationUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput> | ArticleCreateWithoutTagsInput[] | ArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutTagsInput | ArticleCreateOrConnectWithoutTagsInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutTagsInput | ArticleUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutTagsInput | ArticleUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutTagsInput | ArticleUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type TagTranslationUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    upsert?: TagTranslationUpsertWithWhereUniqueWithoutTagInput | TagTranslationUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    set?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    disconnect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    delete?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    update?: TagTranslationUpdateWithWhereUniqueWithoutTagInput | TagTranslationUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagTranslationUpdateManyWithWhereWithoutTagInput | TagTranslationUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput> | ArticleCreateWithoutTagsInput[] | ArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutTagsInput | ArticleCreateOrConnectWithoutTagsInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutTagsInput | ArticleUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutTagsInput | ArticleUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutTagsInput | ArticleUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutTagsInput = {
    create?: XOR<LanguageCreateWithoutTagsInput, LanguageUncheckedCreateWithoutTagsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTagsInput
    connect?: LanguageWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTranslationsInput
    connect?: TagWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<LanguageCreateWithoutTagsInput, LanguageUncheckedCreateWithoutTagsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTagsInput
    upsert?: LanguageUpsertWithoutTagsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutTagsInput, LanguageUpdateWithoutTagsInput>, LanguageUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTranslationsInput
    upsert?: TagUpsertWithoutTranslationsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTranslationsInput, TagUpdateWithoutTranslationsInput>, TagUncheckedUpdateWithoutTranslationsInput>
  }

  export type CommentTranslationCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentTranslationCreateWithoutCommentInput, CommentTranslationUncheckedCreateWithoutCommentInput> | CommentTranslationCreateWithoutCommentInput[] | CommentTranslationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutCommentInput | CommentTranslationCreateOrConnectWithoutCommentInput[]
    createMany?: CommentTranslationCreateManyCommentInputEnvelope
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
  }

  export type ArticleCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentsInput
    connect?: ArticleWhereUniqueInput
  }

  export type CommentTranslationUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentTranslationCreateWithoutCommentInput, CommentTranslationUncheckedCreateWithoutCommentInput> | CommentTranslationCreateWithoutCommentInput[] | CommentTranslationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutCommentInput | CommentTranslationCreateOrConnectWithoutCommentInput[]
    createMany?: CommentTranslationCreateManyCommentInputEnvelope
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
  }

  export type CommentTranslationUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentTranslationCreateWithoutCommentInput, CommentTranslationUncheckedCreateWithoutCommentInput> | CommentTranslationCreateWithoutCommentInput[] | CommentTranslationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutCommentInput | CommentTranslationCreateOrConnectWithoutCommentInput[]
    upsert?: CommentTranslationUpsertWithWhereUniqueWithoutCommentInput | CommentTranslationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentTranslationCreateManyCommentInputEnvelope
    set?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    disconnect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    delete?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    update?: CommentTranslationUpdateWithWhereUniqueWithoutCommentInput | CommentTranslationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentTranslationUpdateManyWithWhereWithoutCommentInput | CommentTranslationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
  }

  export type ArticleUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentsInput
    upsert?: ArticleUpsertWithoutCommentsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutCommentsInput, ArticleUpdateWithoutCommentsInput>, ArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentTranslationUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentTranslationCreateWithoutCommentInput, CommentTranslationUncheckedCreateWithoutCommentInput> | CommentTranslationCreateWithoutCommentInput[] | CommentTranslationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentTranslationCreateOrConnectWithoutCommentInput | CommentTranslationCreateOrConnectWithoutCommentInput[]
    upsert?: CommentTranslationUpsertWithWhereUniqueWithoutCommentInput | CommentTranslationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentTranslationCreateManyCommentInputEnvelope
    set?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    disconnect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    delete?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    connect?: CommentTranslationWhereUniqueInput | CommentTranslationWhereUniqueInput[]
    update?: CommentTranslationUpdateWithWhereUniqueWithoutCommentInput | CommentTranslationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentTranslationUpdateManyWithWhereWithoutCommentInput | CommentTranslationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutCommentsInput = {
    create?: XOR<LanguageCreateWithoutCommentsInput, LanguageUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCommentsInput
    connect?: LanguageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CommentCreateWithoutTranslationsInput, CommentUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutTranslationsInput
    connect?: CommentWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<LanguageCreateWithoutCommentsInput, LanguageUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCommentsInput
    upsert?: LanguageUpsertWithoutCommentsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutCommentsInput, LanguageUpdateWithoutCommentsInput>, LanguageUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CommentCreateWithoutTranslationsInput, CommentUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutTranslationsInput
    upsert?: CommentUpsertWithoutTranslationsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutTranslationsInput, CommentUpdateWithoutTranslationsInput>, CommentUncheckedUpdateWithoutTranslationsInput>
  }

  export type PageTranslationCreateNestedOneWithoutBlocksInput = {
    create?: XOR<PageTranslationCreateWithoutBlocksInput, PageTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: PageTranslationCreateOrConnectWithoutBlocksInput
    connect?: PageTranslationWhereUniqueInput
  }

  export type ArticleTranslationCreateNestedOneWithoutBlocksInput = {
    create?: XOR<ArticleTranslationCreateWithoutBlocksInput, ArticleTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutBlocksInput
    connect?: ArticleTranslationWhereUniqueInput
  }

  export type CategoryServiceTranslationCreateNestedOneWithoutBlocksInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutBlocksInput, CategoryServiceTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutBlocksInput
    connect?: CategoryServiceTranslationWhereUniqueInput
  }

  export type ServiceTranslationCreateNestedOneWithoutBlocksInput = {
    create?: XOR<ServiceTranslationCreateWithoutBlocksInput, ServiceTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutBlocksInput
    connect?: ServiceTranslationWhereUniqueInput
  }

  export type PageTranslationUpdateOneWithoutBlocksNestedInput = {
    create?: XOR<PageTranslationCreateWithoutBlocksInput, PageTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: PageTranslationCreateOrConnectWithoutBlocksInput
    upsert?: PageTranslationUpsertWithoutBlocksInput
    disconnect?: PageTranslationWhereInput | boolean
    delete?: PageTranslationWhereInput | boolean
    connect?: PageTranslationWhereUniqueInput
    update?: XOR<XOR<PageTranslationUpdateToOneWithWhereWithoutBlocksInput, PageTranslationUpdateWithoutBlocksInput>, PageTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type ArticleTranslationUpdateOneWithoutBlocksNestedInput = {
    create?: XOR<ArticleTranslationCreateWithoutBlocksInput, ArticleTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ArticleTranslationCreateOrConnectWithoutBlocksInput
    upsert?: ArticleTranslationUpsertWithoutBlocksInput
    disconnect?: ArticleTranslationWhereInput | boolean
    delete?: ArticleTranslationWhereInput | boolean
    connect?: ArticleTranslationWhereUniqueInput
    update?: XOR<XOR<ArticleTranslationUpdateToOneWithWhereWithoutBlocksInput, ArticleTranslationUpdateWithoutBlocksInput>, ArticleTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type CategoryServiceTranslationUpdateOneWithoutBlocksNestedInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutBlocksInput, CategoryServiceTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutBlocksInput
    upsert?: CategoryServiceTranslationUpsertWithoutBlocksInput
    disconnect?: CategoryServiceTranslationWhereInput | boolean
    delete?: CategoryServiceTranslationWhereInput | boolean
    connect?: CategoryServiceTranslationWhereUniqueInput
    update?: XOR<XOR<CategoryServiceTranslationUpdateToOneWithWhereWithoutBlocksInput, CategoryServiceTranslationUpdateWithoutBlocksInput>, CategoryServiceTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type ServiceTranslationUpdateOneWithoutBlocksNestedInput = {
    create?: XOR<ServiceTranslationCreateWithoutBlocksInput, ServiceTranslationUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutBlocksInput
    upsert?: ServiceTranslationUpsertWithoutBlocksInput
    disconnect?: ServiceTranslationWhereInput | boolean
    delete?: ServiceTranslationWhereInput | boolean
    connect?: ServiceTranslationWhereUniqueInput
    update?: XOR<XOR<ServiceTranslationUpdateToOneWithWhereWithoutBlocksInput, ServiceTranslationUpdateWithoutBlocksInput>, ServiceTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryServiceInput = {
    create?: XOR<ServiceCreateWithoutCategoryServiceInput, ServiceUncheckedCreateWithoutCategoryServiceInput> | ServiceCreateWithoutCategoryServiceInput[] | ServiceUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryServiceInput | ServiceCreateOrConnectWithoutCategoryServiceInput[]
    createMany?: ServiceCreateManyCategoryServiceInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type CategoryServiceTranslationCreateNestedManyWithoutCategoryServiceInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput> | CategoryServiceTranslationCreateWithoutCategoryServiceInput[] | CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput | CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput[]
    createMany?: CategoryServiceTranslationCreateManyCategoryServiceInputEnvelope
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryServiceInput = {
    create?: XOR<ServiceCreateWithoutCategoryServiceInput, ServiceUncheckedCreateWithoutCategoryServiceInput> | ServiceCreateWithoutCategoryServiceInput[] | ServiceUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryServiceInput | ServiceCreateOrConnectWithoutCategoryServiceInput[]
    createMany?: ServiceCreateManyCategoryServiceInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type CategoryServiceTranslationUncheckedCreateNestedManyWithoutCategoryServiceInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput> | CategoryServiceTranslationCreateWithoutCategoryServiceInput[] | CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput | CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput[]
    createMany?: CategoryServiceTranslationCreateManyCategoryServiceInputEnvelope
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryServiceInput, ServiceUncheckedCreateWithoutCategoryServiceInput> | ServiceCreateWithoutCategoryServiceInput[] | ServiceUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryServiceInput | ServiceCreateOrConnectWithoutCategoryServiceInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryServiceInput | ServiceUpsertWithWhereUniqueWithoutCategoryServiceInput[]
    createMany?: ServiceCreateManyCategoryServiceInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryServiceInput | ServiceUpdateWithWhereUniqueWithoutCategoryServiceInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryServiceInput | ServiceUpdateManyWithWhereWithoutCategoryServiceInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type CategoryServiceTranslationUpdateManyWithoutCategoryServiceNestedInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput> | CategoryServiceTranslationCreateWithoutCategoryServiceInput[] | CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput | CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput[]
    upsert?: CategoryServiceTranslationUpsertWithWhereUniqueWithoutCategoryServiceInput | CategoryServiceTranslationUpsertWithWhereUniqueWithoutCategoryServiceInput[]
    createMany?: CategoryServiceTranslationCreateManyCategoryServiceInputEnvelope
    set?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    disconnect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    delete?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    update?: CategoryServiceTranslationUpdateWithWhereUniqueWithoutCategoryServiceInput | CategoryServiceTranslationUpdateWithWhereUniqueWithoutCategoryServiceInput[]
    updateMany?: CategoryServiceTranslationUpdateManyWithWhereWithoutCategoryServiceInput | CategoryServiceTranslationUpdateManyWithWhereWithoutCategoryServiceInput[]
    deleteMany?: CategoryServiceTranslationScalarWhereInput | CategoryServiceTranslationScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryServiceInput, ServiceUncheckedCreateWithoutCategoryServiceInput> | ServiceCreateWithoutCategoryServiceInput[] | ServiceUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryServiceInput | ServiceCreateOrConnectWithoutCategoryServiceInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryServiceInput | ServiceUpsertWithWhereUniqueWithoutCategoryServiceInput[]
    createMany?: ServiceCreateManyCategoryServiceInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryServiceInput | ServiceUpdateWithWhereUniqueWithoutCategoryServiceInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryServiceInput | ServiceUpdateManyWithWhereWithoutCategoryServiceInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type CategoryServiceTranslationUncheckedUpdateManyWithoutCategoryServiceNestedInput = {
    create?: XOR<CategoryServiceTranslationCreateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput> | CategoryServiceTranslationCreateWithoutCategoryServiceInput[] | CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput | CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput[]
    upsert?: CategoryServiceTranslationUpsertWithWhereUniqueWithoutCategoryServiceInput | CategoryServiceTranslationUpsertWithWhereUniqueWithoutCategoryServiceInput[]
    createMany?: CategoryServiceTranslationCreateManyCategoryServiceInputEnvelope
    set?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    disconnect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    delete?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    connect?: CategoryServiceTranslationWhereUniqueInput | CategoryServiceTranslationWhereUniqueInput[]
    update?: CategoryServiceTranslationUpdateWithWhereUniqueWithoutCategoryServiceInput | CategoryServiceTranslationUpdateWithWhereUniqueWithoutCategoryServiceInput[]
    updateMany?: CategoryServiceTranslationUpdateManyWithWhereWithoutCategoryServiceInput | CategoryServiceTranslationUpdateManyWithWhereWithoutCategoryServiceInput[]
    deleteMany?: CategoryServiceTranslationScalarWhereInput | CategoryServiceTranslationScalarWhereInput[]
  }

  export type CategoryServiceTranslationCreateimagesInput = {
    set: string[]
  }

  export type LanguageCreateNestedOneWithoutCategoriesServicesInput = {
    create?: XOR<LanguageCreateWithoutCategoriesServicesInput, LanguageUncheckedCreateWithoutCategoriesServicesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCategoriesServicesInput
    connect?: LanguageWhereUniqueInput
  }

  export type CategoryServiceCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CategoryServiceCreateWithoutTranslationsInput, CategoryServiceUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryServiceCreateOrConnectWithoutTranslationsInput
    connect?: CategoryServiceWhereUniqueInput
  }

  export type BlockCreateNestedManyWithoutCategoryServiceInput = {
    create?: XOR<BlockCreateWithoutCategoryServiceInput, BlockUncheckedCreateWithoutCategoryServiceInput> | BlockCreateWithoutCategoryServiceInput[] | BlockUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutCategoryServiceInput | BlockCreateOrConnectWithoutCategoryServiceInput[]
    createMany?: BlockCreateManyCategoryServiceInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutCategoryServiceInput = {
    create?: XOR<BlockCreateWithoutCategoryServiceInput, BlockUncheckedCreateWithoutCategoryServiceInput> | BlockCreateWithoutCategoryServiceInput[] | BlockUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutCategoryServiceInput | BlockCreateOrConnectWithoutCategoryServiceInput[]
    createMany?: BlockCreateManyCategoryServiceInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type CategoryServiceTranslationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageUpdateOneRequiredWithoutCategoriesServicesNestedInput = {
    create?: XOR<LanguageCreateWithoutCategoriesServicesInput, LanguageUncheckedCreateWithoutCategoriesServicesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCategoriesServicesInput
    upsert?: LanguageUpsertWithoutCategoriesServicesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutCategoriesServicesInput, LanguageUpdateWithoutCategoriesServicesInput>, LanguageUncheckedUpdateWithoutCategoriesServicesInput>
  }

  export type CategoryServiceUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CategoryServiceCreateWithoutTranslationsInput, CategoryServiceUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryServiceCreateOrConnectWithoutTranslationsInput
    upsert?: CategoryServiceUpsertWithoutTranslationsInput
    connect?: CategoryServiceWhereUniqueInput
    update?: XOR<XOR<CategoryServiceUpdateToOneWithWhereWithoutTranslationsInput, CategoryServiceUpdateWithoutTranslationsInput>, CategoryServiceUncheckedUpdateWithoutTranslationsInput>
  }

  export type BlockUpdateManyWithoutCategoryServiceNestedInput = {
    create?: XOR<BlockCreateWithoutCategoryServiceInput, BlockUncheckedCreateWithoutCategoryServiceInput> | BlockCreateWithoutCategoryServiceInput[] | BlockUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutCategoryServiceInput | BlockCreateOrConnectWithoutCategoryServiceInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutCategoryServiceInput | BlockUpsertWithWhereUniqueWithoutCategoryServiceInput[]
    createMany?: BlockCreateManyCategoryServiceInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutCategoryServiceInput | BlockUpdateWithWhereUniqueWithoutCategoryServiceInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutCategoryServiceInput | BlockUpdateManyWithWhereWithoutCategoryServiceInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutCategoryServiceNestedInput = {
    create?: XOR<BlockCreateWithoutCategoryServiceInput, BlockUncheckedCreateWithoutCategoryServiceInput> | BlockCreateWithoutCategoryServiceInput[] | BlockUncheckedCreateWithoutCategoryServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutCategoryServiceInput | BlockCreateOrConnectWithoutCategoryServiceInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutCategoryServiceInput | BlockUpsertWithWhereUniqueWithoutCategoryServiceInput[]
    createMany?: BlockCreateManyCategoryServiceInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutCategoryServiceInput | BlockUpdateWithWhereUniqueWithoutCategoryServiceInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutCategoryServiceInput | BlockUpdateManyWithWhereWithoutCategoryServiceInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type CategoryServiceCreateNestedOneWithoutServicesInput = {
    create?: XOR<CategoryServiceCreateWithoutServicesInput, CategoryServiceUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CategoryServiceCreateOrConnectWithoutServicesInput
    connect?: CategoryServiceWhereUniqueInput
  }

  export type ServiceTranslationCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceTranslationCreateWithoutServiceInput, ServiceTranslationUncheckedCreateWithoutServiceInput> | ServiceTranslationCreateWithoutServiceInput[] | ServiceTranslationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutServiceInput | ServiceTranslationCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceTranslationCreateManyServiceInputEnvelope
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceTranslationUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceTranslationCreateWithoutServiceInput, ServiceTranslationUncheckedCreateWithoutServiceInput> | ServiceTranslationCreateWithoutServiceInput[] | ServiceTranslationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutServiceInput | ServiceTranslationCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceTranslationCreateManyServiceInputEnvelope
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CategoryServiceUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<CategoryServiceCreateWithoutServicesInput, CategoryServiceUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CategoryServiceCreateOrConnectWithoutServicesInput
    upsert?: CategoryServiceUpsertWithoutServicesInput
    connect?: CategoryServiceWhereUniqueInput
    update?: XOR<XOR<CategoryServiceUpdateToOneWithWhereWithoutServicesInput, CategoryServiceUpdateWithoutServicesInput>, CategoryServiceUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceTranslationUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceTranslationCreateWithoutServiceInput, ServiceTranslationUncheckedCreateWithoutServiceInput> | ServiceTranslationCreateWithoutServiceInput[] | ServiceTranslationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutServiceInput | ServiceTranslationCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceTranslationUpsertWithWhereUniqueWithoutServiceInput | ServiceTranslationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceTranslationCreateManyServiceInputEnvelope
    set?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    disconnect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    delete?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    update?: ServiceTranslationUpdateWithWhereUniqueWithoutServiceInput | ServiceTranslationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceTranslationUpdateManyWithWhereWithoutServiceInput | ServiceTranslationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceTranslationScalarWhereInput | ServiceTranslationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutServiceInput | OrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutServiceInput | OrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutServiceInput | OrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceTranslationUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceTranslationCreateWithoutServiceInput, ServiceTranslationUncheckedCreateWithoutServiceInput> | ServiceTranslationCreateWithoutServiceInput[] | ServiceTranslationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceTranslationCreateOrConnectWithoutServiceInput | ServiceTranslationCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceTranslationUpsertWithWhereUniqueWithoutServiceInput | ServiceTranslationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceTranslationCreateManyServiceInputEnvelope
    set?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    disconnect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    delete?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    connect?: ServiceTranslationWhereUniqueInput | ServiceTranslationWhereUniqueInput[]
    update?: ServiceTranslationUpdateWithWhereUniqueWithoutServiceInput | ServiceTranslationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceTranslationUpdateManyWithWhereWithoutServiceInput | ServiceTranslationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceTranslationScalarWhereInput | ServiceTranslationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutServiceInput | OrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutServiceInput | OrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutServiceInput | OrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutServicesInput = {
    create?: XOR<LanguageCreateWithoutServicesInput, LanguageUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutServicesInput
    connect?: LanguageWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ServiceCreateWithoutTranslationsInput, ServiceUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTranslationsInput
    connect?: ServiceWhereUniqueInput
  }

  export type BlockCreateNestedManyWithoutServiceInput = {
    create?: XOR<BlockCreateWithoutServiceInput, BlockUncheckedCreateWithoutServiceInput> | BlockCreateWithoutServiceInput[] | BlockUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutServiceInput | BlockCreateOrConnectWithoutServiceInput[]
    createMany?: BlockCreateManyServiceInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BlockCreateWithoutServiceInput, BlockUncheckedCreateWithoutServiceInput> | BlockCreateWithoutServiceInput[] | BlockUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutServiceInput | BlockCreateOrConnectWithoutServiceInput[]
    createMany?: BlockCreateManyServiceInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type LanguageUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<LanguageCreateWithoutServicesInput, LanguageUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutServicesInput
    upsert?: LanguageUpsertWithoutServicesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutServicesInput, LanguageUpdateWithoutServicesInput>, LanguageUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ServiceCreateWithoutTranslationsInput, ServiceUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTranslationsInput
    upsert?: ServiceUpsertWithoutTranslationsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutTranslationsInput, ServiceUpdateWithoutTranslationsInput>, ServiceUncheckedUpdateWithoutTranslationsInput>
  }

  export type BlockUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BlockCreateWithoutServiceInput, BlockUncheckedCreateWithoutServiceInput> | BlockCreateWithoutServiceInput[] | BlockUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutServiceInput | BlockCreateOrConnectWithoutServiceInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutServiceInput | BlockUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BlockCreateManyServiceInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutServiceInput | BlockUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutServiceInput | BlockUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BlockCreateWithoutServiceInput, BlockUncheckedCreateWithoutServiceInput> | BlockCreateWithoutServiceInput[] | BlockUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutServiceInput | BlockCreateOrConnectWithoutServiceInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutServiceInput | BlockUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BlockCreateManyServiceInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutServiceInput | BlockUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutServiceInput | BlockUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type ServiceUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput
    upsert?: ServiceUpsertWithoutOrdersInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutOrdersInput, ServiceUpdateWithoutOrdersInput>, ServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    sessions?: SessionCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PageTranslationCreateWithoutAuthorInput = {
    id?: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutPagesInput
    blocks?: BlockCreateNestedManyWithoutPageInput
    page: PageCreateNestedOneWithoutTranslationsInput
  }

  export type PageTranslationUncheckedCreateWithoutAuthorInput = {
    id?: string
    lang: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageTranslationCreateOrConnectWithoutAuthorInput = {
    where: PageTranslationWhereUniqueInput
    create: XOR<PageTranslationCreateWithoutAuthorInput, PageTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type PageTranslationCreateManyAuthorInputEnvelope = {
    data: PageTranslationCreateManyAuthorInput | PageTranslationCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ArticleTranslationCreateWithoutAuthorInput = {
    id?: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutArticlesInput
    article: ArticleCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationUncheckedCreateWithoutAuthorInput = {
    id?: string
    lang: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationCreateOrConnectWithoutAuthorInput = {
    where: ArticleTranslationWhereUniqueInput
    create: XOR<ArticleTranslationCreateWithoutAuthorInput, ArticleTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleTranslationCreateManyAuthorInputEnvelope = {
    data: ArticleTranslationCreateManyAuthorInput | ArticleTranslationCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CategoryTranslationCreateWithoutAuthorInput = {
    id?: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCategoreisInput
    category: CategoryCreateNestedOneWithoutTranslationsInput
  }

  export type CategoryTranslationUncheckedCreateWithoutAuthorInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationCreateOrConnectWithoutAuthorInput = {
    where: CategoryTranslationWhereUniqueInput
    create: XOR<CategoryTranslationCreateWithoutAuthorInput, CategoryTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type CategoryTranslationCreateManyAuthorInputEnvelope = {
    data: CategoryTranslationCreateManyAuthorInput | CategoryTranslationCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentTranslationCreateWithoutAuthorInput = {
    id?: string
    name?: string | null
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCommentsInput
    comment: CommentCreateNestedOneWithoutTranslationsInput
  }

  export type CommentTranslationUncheckedCreateWithoutAuthorInput = {
    id?: string
    lang: string
    name?: string | null
    body: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationCreateOrConnectWithoutAuthorInput = {
    where: CommentTranslationWhereUniqueInput
    create: XOR<CommentTranslationCreateWithoutAuthorInput, CommentTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type CommentTranslationCreateManyAuthorInputEnvelope = {
    data: CommentTranslationCreateManyAuthorInput | CommentTranslationCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutStudentInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutStudentInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    serviceId?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutStudentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStudentInput, OrderUncheckedCreateWithoutStudentInput>
  }

  export type OrderCreateManyStudentInputEnvelope = {
    data: OrderCreateManyStudentInput | OrderCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PageTranslationUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PageTranslationWhereUniqueInput
    update: XOR<PageTranslationUpdateWithoutAuthorInput, PageTranslationUncheckedUpdateWithoutAuthorInput>
    create: XOR<PageTranslationCreateWithoutAuthorInput, PageTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type PageTranslationUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PageTranslationWhereUniqueInput
    data: XOR<PageTranslationUpdateWithoutAuthorInput, PageTranslationUncheckedUpdateWithoutAuthorInput>
  }

  export type PageTranslationUpdateManyWithWhereWithoutAuthorInput = {
    where: PageTranslationScalarWhereInput
    data: XOR<PageTranslationUpdateManyMutationInput, PageTranslationUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PageTranslationScalarWhereInput = {
    AND?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
    OR?: PageTranslationScalarWhereInput[]
    NOT?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
    id?: StringFilter<"PageTranslation"> | string
    lang?: StringFilter<"PageTranslation"> | string
    userId?: StringFilter<"PageTranslation"> | string
    title?: StringFilter<"PageTranslation"> | string
    description?: StringNullableFilter<"PageTranslation"> | string | null
    images?: StringNullableListFilter<"PageTranslation">
    published?: BoolFilter<"PageTranslation"> | boolean
    pageId?: StringFilter<"PageTranslation"> | string
    createdAt?: DateTimeFilter<"PageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PageTranslation"> | Date | string
  }

  export type ArticleTranslationUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ArticleTranslationWhereUniqueInput
    update: XOR<ArticleTranslationUpdateWithoutAuthorInput, ArticleTranslationUncheckedUpdateWithoutAuthorInput>
    create: XOR<ArticleTranslationCreateWithoutAuthorInput, ArticleTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleTranslationUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ArticleTranslationWhereUniqueInput
    data: XOR<ArticleTranslationUpdateWithoutAuthorInput, ArticleTranslationUncheckedUpdateWithoutAuthorInput>
  }

  export type ArticleTranslationUpdateManyWithWhereWithoutAuthorInput = {
    where: ArticleTranslationScalarWhereInput
    data: XOR<ArticleTranslationUpdateManyMutationInput, ArticleTranslationUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ArticleTranslationScalarWhereInput = {
    AND?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
    OR?: ArticleTranslationScalarWhereInput[]
    NOT?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
    id?: StringFilter<"ArticleTranslation"> | string
    lang?: StringFilter<"ArticleTranslation"> | string
    userId?: StringFilter<"ArticleTranslation"> | string
    slug?: StringNullableFilter<"ArticleTranslation"> | string | null
    published?: BoolFilter<"ArticleTranslation"> | boolean
    title?: StringNullableFilter<"ArticleTranslation"> | string | null
    description?: StringNullableFilter<"ArticleTranslation"> | string | null
    articleId?: StringFilter<"ArticleTranslation"> | string
    images?: StringNullableListFilter<"ArticleTranslation">
    createdAt?: DateTimeFilter<"ArticleTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ArticleTranslation"> | Date | string
  }

  export type CategoryTranslationUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CategoryTranslationWhereUniqueInput
    update: XOR<CategoryTranslationUpdateWithoutAuthorInput, CategoryTranslationUncheckedUpdateWithoutAuthorInput>
    create: XOR<CategoryTranslationCreateWithoutAuthorInput, CategoryTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type CategoryTranslationUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CategoryTranslationWhereUniqueInput
    data: XOR<CategoryTranslationUpdateWithoutAuthorInput, CategoryTranslationUncheckedUpdateWithoutAuthorInput>
  }

  export type CategoryTranslationUpdateManyWithWhereWithoutAuthorInput = {
    where: CategoryTranslationScalarWhereInput
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CategoryTranslationScalarWhereInput = {
    AND?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
    OR?: CategoryTranslationScalarWhereInput[]
    NOT?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
    id?: StringFilter<"CategoryTranslation"> | string
    lang?: StringFilter<"CategoryTranslation"> | string
    userId?: StringFilter<"CategoryTranslation"> | string
    name?: StringFilter<"CategoryTranslation"> | string
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryTranslation">
    categoryId?: StringFilter<"CategoryTranslation"> | string
    createdAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
  }

  export type CommentTranslationUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentTranslationWhereUniqueInput
    update: XOR<CommentTranslationUpdateWithoutAuthorInput, CommentTranslationUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentTranslationCreateWithoutAuthorInput, CommentTranslationUncheckedCreateWithoutAuthorInput>
  }

  export type CommentTranslationUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentTranslationWhereUniqueInput
    data: XOR<CommentTranslationUpdateWithoutAuthorInput, CommentTranslationUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentTranslationUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentTranslationScalarWhereInput
    data: XOR<CommentTranslationUpdateManyMutationInput, CommentTranslationUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentTranslationScalarWhereInput = {
    AND?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
    OR?: CommentTranslationScalarWhereInput[]
    NOT?: CommentTranslationScalarWhereInput | CommentTranslationScalarWhereInput[]
    id?: StringFilter<"CommentTranslation"> | string
    lang?: StringFilter<"CommentTranslation"> | string
    userId?: StringNullableFilter<"CommentTranslation"> | string | null
    name?: StringNullableFilter<"CommentTranslation"> | string | null
    body?: StringFilter<"CommentTranslation"> | string
    commentId?: StringFilter<"CommentTranslation"> | string
    createdAt?: DateTimeFilter<"CommentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CommentTranslation"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutStudentInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStudentInput, OrderUncheckedUpdateWithoutStudentInput>
    create: XOR<OrderCreateWithoutStudentInput, OrderUncheckedCreateWithoutStudentInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStudentInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStudentInput, OrderUncheckedUpdateWithoutStudentInput>
  }

  export type OrderUpdateManyWithWhereWithoutStudentInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStudentInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    name?: StringNullableFilter<"Order"> | string | null
    email?: StringNullableFilter<"Order"> | string | null
    phone?: StringNullableFilter<"Order"> | string | null
    studentId?: StringNullableFilter<"Order"> | string | null
    serviceId?: StringNullableFilter<"Order"> | string | null
    DescriptionOtherService?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type GlobalTranslationCreateWithoutLanguageInput = {
    id?: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    global: GlobalCreateNestedOneWithoutTranslationsInput
  }

  export type GlobalTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    globalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalTranslationCreateOrConnectWithoutLanguageInput = {
    where: GlobalTranslationWhereUniqueInput
    create: XOR<GlobalTranslationCreateWithoutLanguageInput, GlobalTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type GlobalTranslationCreateManyLanguageInputEnvelope = {
    data: GlobalTranslationCreateManyLanguageInput | GlobalTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type PageTranslationCreateWithoutLanguageInput = {
    id?: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    blocks?: BlockCreateNestedManyWithoutPageInput
    page: PageCreateNestedOneWithoutTranslationsInput
  }

  export type PageTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageTranslationCreateOrConnectWithoutLanguageInput = {
    where: PageTranslationWhereUniqueInput
    create: XOR<PageTranslationCreateWithoutLanguageInput, PageTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type PageTranslationCreateManyLanguageInputEnvelope = {
    data: PageTranslationCreateManyLanguageInput | PageTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type CategoryTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutTranslationsInput
  }

  export type CategoryTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationCreateOrConnectWithoutLanguageInput = {
    where: CategoryTranslationWhereUniqueInput
    create: XOR<CategoryTranslationCreateWithoutLanguageInput, CategoryTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type CategoryTranslationCreateManyLanguageInputEnvelope = {
    data: CategoryTranslationCreateManyLanguageInput | CategoryTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type CategoryServiceTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryService: CategoryServiceCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    categoryServiceId: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceTranslationCreateOrConnectWithoutLanguageInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    create: XOR<CategoryServiceTranslationCreateWithoutLanguageInput, CategoryServiceTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type CategoryServiceTranslationCreateManyLanguageInputEnvelope = {
    data: CategoryServiceTranslationCreateManyLanguageInput | CategoryServiceTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutServiceInput
  }

  export type ServiceTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    name: string
    description?: string | null
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceTranslationCreateOrConnectWithoutLanguageInput = {
    where: ServiceTranslationWhereUniqueInput
    create: XOR<ServiceTranslationCreateWithoutLanguageInput, ServiceTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type ServiceTranslationCreateManyLanguageInputEnvelope = {
    data: ServiceTranslationCreateManyLanguageInput | ServiceTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type ArticleTranslationCreateWithoutLanguageInput = {
    id?: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    article: ArticleCreateNestedOneWithoutTranslationsInput
    blocks?: BlockCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationCreateOrConnectWithoutLanguageInput = {
    where: ArticleTranslationWhereUniqueInput
    create: XOR<ArticleTranslationCreateWithoutLanguageInput, ArticleTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type ArticleTranslationCreateManyLanguageInputEnvelope = {
    data: ArticleTranslationCreateManyLanguageInput | ArticleTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type TagTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tag: TagCreateNestedOneWithoutTranslationsInput
  }

  export type TagTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    tagId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationCreateOrConnectWithoutLanguageInput = {
    where: TagTranslationWhereUniqueInput
    create: XOR<TagTranslationCreateWithoutLanguageInput, TagTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type TagTranslationCreateManyLanguageInputEnvelope = {
    data: TagTranslationCreateManyLanguageInput | TagTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type CommentTranslationCreateWithoutLanguageInput = {
    id?: string
    name?: string | null
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutCommentInput
    comment: CommentCreateNestedOneWithoutTranslationsInput
  }

  export type CommentTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    userId?: string | null
    name?: string | null
    body: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationCreateOrConnectWithoutLanguageInput = {
    where: CommentTranslationWhereUniqueInput
    create: XOR<CommentTranslationCreateWithoutLanguageInput, CommentTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type CommentTranslationCreateManyLanguageInputEnvelope = {
    data: CommentTranslationCreateManyLanguageInput | CommentTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type NavbarItemTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    navbarItem?: NavbarItemCreateNestedOneWithoutTranslationsInput
  }

  export type NavbarItemTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    name: string
    navbarItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemTranslationCreateOrConnectWithoutLanguageInput = {
    where: NavbarItemTranslationWhereUniqueInput
    create: XOR<NavbarItemTranslationCreateWithoutLanguageInput, NavbarItemTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type NavbarItemTranslationCreateManyLanguageInputEnvelope = {
    data: NavbarItemTranslationCreateManyLanguageInput | NavbarItemTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type DropDownGroupTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dropdownGroup?: DropDownGroupCreateNestedOneWithoutTranslationsInput
  }

  export type DropDownGroupTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    name: string
    dropdownGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupTranslationCreateOrConnectWithoutLanguageInput = {
    where: DropDownGroupTranslationWhereUniqueInput
    create: XOR<DropDownGroupTranslationCreateWithoutLanguageInput, DropDownGroupTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type DropDownGroupTranslationCreateManyLanguageInputEnvelope = {
    data: DropDownGroupTranslationCreateManyLanguageInput | DropDownGroupTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type DropdownItemTranslationCreateWithoutLanguageInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dropdownItem?: DropdownItemCreateNestedOneWithoutTranslationsInput
  }

  export type DropdownItemTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    name: string
    dropdownItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemTranslationCreateOrConnectWithoutLanguageInput = {
    where: DropdownItemTranslationWhereUniqueInput
    create: XOR<DropdownItemTranslationCreateWithoutLanguageInput, DropdownItemTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type DropdownItemTranslationCreateManyLanguageInputEnvelope = {
    data: DropdownItemTranslationCreateManyLanguageInput | DropdownItemTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type FooterTranslationCreateWithoutLanguageInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    footer?: FooterCreateNestedOneWithoutTranslationsInput
  }

  export type FooterTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterTranslationCreateOrConnectWithoutLanguageInput = {
    where: FooterTranslationWhereUniqueInput
    create: XOR<FooterTranslationCreateWithoutLanguageInput, FooterTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type FooterTranslationCreateManyLanguageInputEnvelope = {
    data: FooterTranslationCreateManyLanguageInput | FooterTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type GroupFooterTranslationCreateWithoutLanguageInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupfooter?: GroupFooterCreateNestedOneWithoutTranslationsInput
  }

  export type GroupFooterTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    title?: string | null
    groupfooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterTranslationCreateOrConnectWithoutLanguageInput = {
    where: GroupFooterTranslationWhereUniqueInput
    create: XOR<GroupFooterTranslationCreateWithoutLanguageInput, GroupFooterTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type GroupFooterTranslationCreateManyLanguageInputEnvelope = {
    data: GroupFooterTranslationCreateManyLanguageInput | GroupFooterTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type GlobalTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: GlobalTranslationWhereUniqueInput
    update: XOR<GlobalTranslationUpdateWithoutLanguageInput, GlobalTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<GlobalTranslationCreateWithoutLanguageInput, GlobalTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type GlobalTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: GlobalTranslationWhereUniqueInput
    data: XOR<GlobalTranslationUpdateWithoutLanguageInput, GlobalTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type GlobalTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: GlobalTranslationScalarWhereInput
    data: XOR<GlobalTranslationUpdateManyMutationInput, GlobalTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type GlobalTranslationScalarWhereInput = {
    AND?: GlobalTranslationScalarWhereInput | GlobalTranslationScalarWhereInput[]
    OR?: GlobalTranslationScalarWhereInput[]
    NOT?: GlobalTranslationScalarWhereInput | GlobalTranslationScalarWhereInput[]
    id?: StringFilter<"GlobalTranslation"> | string
    lang?: StringFilter<"GlobalTranslation"> | string
    name?: StringNullableFilter<"GlobalTranslation"> | string | null
    logo?: StringNullableFilter<"GlobalTranslation"> | string | null
    favicon?: StringNullableFilter<"GlobalTranslation"> | string | null
    images?: StringNullableListFilter<"GlobalTranslation">
    description?: StringNullableFilter<"GlobalTranslation"> | string | null
    globalId?: StringFilter<"GlobalTranslation"> | string
    createdAt?: DateTimeFilter<"GlobalTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalTranslation"> | Date | string
  }

  export type PageTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: PageTranslationWhereUniqueInput
    update: XOR<PageTranslationUpdateWithoutLanguageInput, PageTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<PageTranslationCreateWithoutLanguageInput, PageTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type PageTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: PageTranslationWhereUniqueInput
    data: XOR<PageTranslationUpdateWithoutLanguageInput, PageTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type PageTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: PageTranslationScalarWhereInput
    data: XOR<PageTranslationUpdateManyMutationInput, PageTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type CategoryTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: CategoryTranslationWhereUniqueInput
    update: XOR<CategoryTranslationUpdateWithoutLanguageInput, CategoryTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<CategoryTranslationCreateWithoutLanguageInput, CategoryTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type CategoryTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: CategoryTranslationWhereUniqueInput
    data: XOR<CategoryTranslationUpdateWithoutLanguageInput, CategoryTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type CategoryTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: CategoryTranslationScalarWhereInput
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type CategoryServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    update: XOR<CategoryServiceTranslationUpdateWithoutLanguageInput, CategoryServiceTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<CategoryServiceTranslationCreateWithoutLanguageInput, CategoryServiceTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type CategoryServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    data: XOR<CategoryServiceTranslationUpdateWithoutLanguageInput, CategoryServiceTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type CategoryServiceTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: CategoryServiceTranslationScalarWhereInput
    data: XOR<CategoryServiceTranslationUpdateManyMutationInput, CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type CategoryServiceTranslationScalarWhereInput = {
    AND?: CategoryServiceTranslationScalarWhereInput | CategoryServiceTranslationScalarWhereInput[]
    OR?: CategoryServiceTranslationScalarWhereInput[]
    NOT?: CategoryServiceTranslationScalarWhereInput | CategoryServiceTranslationScalarWhereInput[]
    id?: StringFilter<"CategoryServiceTranslation"> | string
    lang?: StringFilter<"CategoryServiceTranslation"> | string
    name?: StringFilter<"CategoryServiceTranslation"> | string
    descriprion?: StringNullableFilter<"CategoryServiceTranslation"> | string | null
    images?: StringNullableListFilter<"CategoryServiceTranslation">
    categoryServiceId?: StringFilter<"CategoryServiceTranslation"> | string
    published?: BoolFilter<"CategoryServiceTranslation"> | boolean
    createdAt?: DateTimeFilter<"CategoryServiceTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryServiceTranslation"> | Date | string
  }

  export type ServiceTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: ServiceTranslationWhereUniqueInput
    update: XOR<ServiceTranslationUpdateWithoutLanguageInput, ServiceTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<ServiceTranslationCreateWithoutLanguageInput, ServiceTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type ServiceTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: ServiceTranslationWhereUniqueInput
    data: XOR<ServiceTranslationUpdateWithoutLanguageInput, ServiceTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type ServiceTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: ServiceTranslationScalarWhereInput
    data: XOR<ServiceTranslationUpdateManyMutationInput, ServiceTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type ServiceTranslationScalarWhereInput = {
    AND?: ServiceTranslationScalarWhereInput | ServiceTranslationScalarWhereInput[]
    OR?: ServiceTranslationScalarWhereInput[]
    NOT?: ServiceTranslationScalarWhereInput | ServiceTranslationScalarWhereInput[]
    id?: StringFilter<"ServiceTranslation"> | string
    lang?: StringFilter<"ServiceTranslation"> | string
    name?: StringFilter<"ServiceTranslation"> | string
    description?: StringNullableFilter<"ServiceTranslation"> | string | null
    serviceId?: StringFilter<"ServiceTranslation"> | string
    createdAt?: DateTimeFilter<"ServiceTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTranslation"> | Date | string
  }

  export type ArticleTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: ArticleTranslationWhereUniqueInput
    update: XOR<ArticleTranslationUpdateWithoutLanguageInput, ArticleTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<ArticleTranslationCreateWithoutLanguageInput, ArticleTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type ArticleTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: ArticleTranslationWhereUniqueInput
    data: XOR<ArticleTranslationUpdateWithoutLanguageInput, ArticleTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type ArticleTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: ArticleTranslationScalarWhereInput
    data: XOR<ArticleTranslationUpdateManyMutationInput, ArticleTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type TagTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: TagTranslationWhereUniqueInput
    update: XOR<TagTranslationUpdateWithoutLanguageInput, TagTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<TagTranslationCreateWithoutLanguageInput, TagTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type TagTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: TagTranslationWhereUniqueInput
    data: XOR<TagTranslationUpdateWithoutLanguageInput, TagTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type TagTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: TagTranslationScalarWhereInput
    data: XOR<TagTranslationUpdateManyMutationInput, TagTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type TagTranslationScalarWhereInput = {
    AND?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
    OR?: TagTranslationScalarWhereInput[]
    NOT?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
    id?: StringFilter<"TagTranslation"> | string
    lang?: StringFilter<"TagTranslation"> | string
    tagId?: StringFilter<"TagTranslation"> | string
    name?: StringFilter<"TagTranslation"> | string
    createdAt?: DateTimeFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TagTranslation"> | Date | string
  }

  export type CommentTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: CommentTranslationWhereUniqueInput
    update: XOR<CommentTranslationUpdateWithoutLanguageInput, CommentTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<CommentTranslationCreateWithoutLanguageInput, CommentTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type CommentTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: CommentTranslationWhereUniqueInput
    data: XOR<CommentTranslationUpdateWithoutLanguageInput, CommentTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type CommentTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: CommentTranslationScalarWhereInput
    data: XOR<CommentTranslationUpdateManyMutationInput, CommentTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type NavbarItemTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: NavbarItemTranslationWhereUniqueInput
    update: XOR<NavbarItemTranslationUpdateWithoutLanguageInput, NavbarItemTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<NavbarItemTranslationCreateWithoutLanguageInput, NavbarItemTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type NavbarItemTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: NavbarItemTranslationWhereUniqueInput
    data: XOR<NavbarItemTranslationUpdateWithoutLanguageInput, NavbarItemTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type NavbarItemTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: NavbarItemTranslationScalarWhereInput
    data: XOR<NavbarItemTranslationUpdateManyMutationInput, NavbarItemTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type NavbarItemTranslationScalarWhereInput = {
    AND?: NavbarItemTranslationScalarWhereInput | NavbarItemTranslationScalarWhereInput[]
    OR?: NavbarItemTranslationScalarWhereInput[]
    NOT?: NavbarItemTranslationScalarWhereInput | NavbarItemTranslationScalarWhereInput[]
    id?: StringFilter<"NavbarItemTranslation"> | string
    name?: StringFilter<"NavbarItemTranslation"> | string
    lang?: StringFilter<"NavbarItemTranslation"> | string
    navbarItemId?: StringNullableFilter<"NavbarItemTranslation"> | string | null
    createdAt?: DateTimeFilter<"NavbarItemTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"NavbarItemTranslation"> | Date | string
  }

  export type DropDownGroupTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: DropDownGroupTranslationWhereUniqueInput
    update: XOR<DropDownGroupTranslationUpdateWithoutLanguageInput, DropDownGroupTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<DropDownGroupTranslationCreateWithoutLanguageInput, DropDownGroupTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type DropDownGroupTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: DropDownGroupTranslationWhereUniqueInput
    data: XOR<DropDownGroupTranslationUpdateWithoutLanguageInput, DropDownGroupTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type DropDownGroupTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: DropDownGroupTranslationScalarWhereInput
    data: XOR<DropDownGroupTranslationUpdateManyMutationInput, DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type DropDownGroupTranslationScalarWhereInput = {
    AND?: DropDownGroupTranslationScalarWhereInput | DropDownGroupTranslationScalarWhereInput[]
    OR?: DropDownGroupTranslationScalarWhereInput[]
    NOT?: DropDownGroupTranslationScalarWhereInput | DropDownGroupTranslationScalarWhereInput[]
    id?: StringFilter<"DropDownGroupTranslation"> | string
    name?: StringFilter<"DropDownGroupTranslation"> | string
    lang?: StringFilter<"DropDownGroupTranslation"> | string
    dropdownGroupId?: StringNullableFilter<"DropDownGroupTranslation"> | string | null
    createdAt?: DateTimeFilter<"DropDownGroupTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DropDownGroupTranslation"> | Date | string
  }

  export type DropdownItemTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: DropdownItemTranslationWhereUniqueInput
    update: XOR<DropdownItemTranslationUpdateWithoutLanguageInput, DropdownItemTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<DropdownItemTranslationCreateWithoutLanguageInput, DropdownItemTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type DropdownItemTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: DropdownItemTranslationWhereUniqueInput
    data: XOR<DropdownItemTranslationUpdateWithoutLanguageInput, DropdownItemTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type DropdownItemTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: DropdownItemTranslationScalarWhereInput
    data: XOR<DropdownItemTranslationUpdateManyMutationInput, DropdownItemTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type DropdownItemTranslationScalarWhereInput = {
    AND?: DropdownItemTranslationScalarWhereInput | DropdownItemTranslationScalarWhereInput[]
    OR?: DropdownItemTranslationScalarWhereInput[]
    NOT?: DropdownItemTranslationScalarWhereInput | DropdownItemTranslationScalarWhereInput[]
    id?: StringFilter<"DropdownItemTranslation"> | string
    name?: StringFilter<"DropdownItemTranslation"> | string
    lang?: StringFilter<"DropdownItemTranslation"> | string
    dropdownItemId?: StringNullableFilter<"DropdownItemTranslation"> | string | null
    createdAt?: DateTimeFilter<"DropdownItemTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownItemTranslation"> | Date | string
  }

  export type FooterTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: FooterTranslationWhereUniqueInput
    update: XOR<FooterTranslationUpdateWithoutLanguageInput, FooterTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<FooterTranslationCreateWithoutLanguageInput, FooterTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type FooterTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: FooterTranslationWhereUniqueInput
    data: XOR<FooterTranslationUpdateWithoutLanguageInput, FooterTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type FooterTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: FooterTranslationScalarWhereInput
    data: XOR<FooterTranslationUpdateManyMutationInput, FooterTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type FooterTranslationScalarWhereInput = {
    AND?: FooterTranslationScalarWhereInput | FooterTranslationScalarWhereInput[]
    OR?: FooterTranslationScalarWhereInput[]
    NOT?: FooterTranslationScalarWhereInput | FooterTranslationScalarWhereInput[]
    id?: StringFilter<"FooterTranslation"> | string
    lang?: StringFilter<"FooterTranslation"> | string
    footerId?: StringNullableFilter<"FooterTranslation"> | string | null
    createdAt?: DateTimeFilter<"FooterTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"FooterTranslation"> | Date | string
  }

  export type GroupFooterTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: GroupFooterTranslationWhereUniqueInput
    update: XOR<GroupFooterTranslationUpdateWithoutLanguageInput, GroupFooterTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<GroupFooterTranslationCreateWithoutLanguageInput, GroupFooterTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type GroupFooterTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: GroupFooterTranslationWhereUniqueInput
    data: XOR<GroupFooterTranslationUpdateWithoutLanguageInput, GroupFooterTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type GroupFooterTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: GroupFooterTranslationScalarWhereInput
    data: XOR<GroupFooterTranslationUpdateManyMutationInput, GroupFooterTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type GroupFooterTranslationScalarWhereInput = {
    AND?: GroupFooterTranslationScalarWhereInput | GroupFooterTranslationScalarWhereInput[]
    OR?: GroupFooterTranslationScalarWhereInput[]
    NOT?: GroupFooterTranslationScalarWhereInput | GroupFooterTranslationScalarWhereInput[]
    id?: StringFilter<"GroupFooterTranslation"> | string
    title?: StringNullableFilter<"GroupFooterTranslation"> | string | null
    groupfooterId?: StringNullableFilter<"GroupFooterTranslation"> | string | null
    lang?: StringFilter<"GroupFooterTranslation"> | string
    createdAt?: DateTimeFilter<"GroupFooterTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GroupFooterTranslation"> | Date | string
  }

  export type GlobalTranslationCreateWithoutGlobalInput = {
    id?: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutGlobalsInput
  }

  export type GlobalTranslationUncheckedCreateWithoutGlobalInput = {
    id?: string
    lang: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalTranslationCreateOrConnectWithoutGlobalInput = {
    where: GlobalTranslationWhereUniqueInput
    create: XOR<GlobalTranslationCreateWithoutGlobalInput, GlobalTranslationUncheckedCreateWithoutGlobalInput>
  }

  export type GlobalTranslationCreateManyGlobalInputEnvelope = {
    data: GlobalTranslationCreateManyGlobalInput | GlobalTranslationCreateManyGlobalInput[]
    skipDuplicates?: boolean
  }

  export type SocialLinkCreateWithoutGlobalInput = {
    id?: string
    social: string
    url: string
  }

  export type SocialLinkUncheckedCreateWithoutGlobalInput = {
    id?: string
    social: string
    url: string
  }

  export type SocialLinkCreateOrConnectWithoutGlobalInput = {
    where: SocialLinkWhereUniqueInput
    create: XOR<SocialLinkCreateWithoutGlobalInput, SocialLinkUncheckedCreateWithoutGlobalInput>
  }

  export type SocialLinkCreateManyGlobalInputEnvelope = {
    data: SocialLinkCreateManyGlobalInput | SocialLinkCreateManyGlobalInput[]
    skipDuplicates?: boolean
  }

  export type GlobalTranslationUpsertWithWhereUniqueWithoutGlobalInput = {
    where: GlobalTranslationWhereUniqueInput
    update: XOR<GlobalTranslationUpdateWithoutGlobalInput, GlobalTranslationUncheckedUpdateWithoutGlobalInput>
    create: XOR<GlobalTranslationCreateWithoutGlobalInput, GlobalTranslationUncheckedCreateWithoutGlobalInput>
  }

  export type GlobalTranslationUpdateWithWhereUniqueWithoutGlobalInput = {
    where: GlobalTranslationWhereUniqueInput
    data: XOR<GlobalTranslationUpdateWithoutGlobalInput, GlobalTranslationUncheckedUpdateWithoutGlobalInput>
  }

  export type GlobalTranslationUpdateManyWithWhereWithoutGlobalInput = {
    where: GlobalTranslationScalarWhereInput
    data: XOR<GlobalTranslationUpdateManyMutationInput, GlobalTranslationUncheckedUpdateManyWithoutGlobalInput>
  }

  export type SocialLinkUpsertWithWhereUniqueWithoutGlobalInput = {
    where: SocialLinkWhereUniqueInput
    update: XOR<SocialLinkUpdateWithoutGlobalInput, SocialLinkUncheckedUpdateWithoutGlobalInput>
    create: XOR<SocialLinkCreateWithoutGlobalInput, SocialLinkUncheckedCreateWithoutGlobalInput>
  }

  export type SocialLinkUpdateWithWhereUniqueWithoutGlobalInput = {
    where: SocialLinkWhereUniqueInput
    data: XOR<SocialLinkUpdateWithoutGlobalInput, SocialLinkUncheckedUpdateWithoutGlobalInput>
  }

  export type SocialLinkUpdateManyWithWhereWithoutGlobalInput = {
    where: SocialLinkScalarWhereInput
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyWithoutGlobalInput>
  }

  export type SocialLinkScalarWhereInput = {
    AND?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
    OR?: SocialLinkScalarWhereInput[]
    NOT?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    social?: StringFilter<"SocialLink"> | string
    url?: StringFilter<"SocialLink"> | string
    globalId?: StringNullableFilter<"SocialLink"> | string | null
  }

  export type LanguageCreateWithoutGlobalsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutGlobalsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutGlobalsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutGlobalsInput, LanguageUncheckedCreateWithoutGlobalsInput>
  }

  export type GlobalCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinkCreateNestedManyWithoutGlobalInput
  }

  export type GlobalUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinkUncheckedCreateNestedManyWithoutGlobalInput
  }

  export type GlobalCreateOrConnectWithoutTranslationsInput = {
    where: GlobalWhereUniqueInput
    create: XOR<GlobalCreateWithoutTranslationsInput, GlobalUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutGlobalsInput = {
    update: XOR<LanguageUpdateWithoutGlobalsInput, LanguageUncheckedUpdateWithoutGlobalsInput>
    create: XOR<LanguageCreateWithoutGlobalsInput, LanguageUncheckedCreateWithoutGlobalsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutGlobalsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutGlobalsInput, LanguageUncheckedUpdateWithoutGlobalsInput>
  }

  export type LanguageUpdateWithoutGlobalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutGlobalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type GlobalUpsertWithoutTranslationsInput = {
    update: XOR<GlobalUpdateWithoutTranslationsInput, GlobalUncheckedUpdateWithoutTranslationsInput>
    create: XOR<GlobalCreateWithoutTranslationsInput, GlobalUncheckedCreateWithoutTranslationsInput>
    where?: GlobalWhereInput
  }

  export type GlobalUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: GlobalWhereInput
    data: XOR<GlobalUpdateWithoutTranslationsInput, GlobalUncheckedUpdateWithoutTranslationsInput>
  }

  export type GlobalUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinkUpdateManyWithoutGlobalNestedInput
  }

  export type GlobalUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinkUncheckedUpdateManyWithoutGlobalNestedInput
  }

  export type GlobalCreateWithoutSocialLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GlobalTranslationCreateNestedManyWithoutGlobalInput
  }

  export type GlobalUncheckedCreateWithoutSocialLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GlobalTranslationUncheckedCreateNestedManyWithoutGlobalInput
  }

  export type GlobalCreateOrConnectWithoutSocialLinksInput = {
    where: GlobalWhereUniqueInput
    create: XOR<GlobalCreateWithoutSocialLinksInput, GlobalUncheckedCreateWithoutSocialLinksInput>
  }

  export type GlobalUpsertWithoutSocialLinksInput = {
    update: XOR<GlobalUpdateWithoutSocialLinksInput, GlobalUncheckedUpdateWithoutSocialLinksInput>
    create: XOR<GlobalCreateWithoutSocialLinksInput, GlobalUncheckedCreateWithoutSocialLinksInput>
    where?: GlobalWhereInput
  }

  export type GlobalUpdateToOneWithWhereWithoutSocialLinksInput = {
    where?: GlobalWhereInput
    data: XOR<GlobalUpdateWithoutSocialLinksInput, GlobalUncheckedUpdateWithoutSocialLinksInput>
  }

  export type GlobalUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GlobalTranslationUpdateManyWithoutGlobalNestedInput
  }

  export type GlobalUncheckedUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GlobalTranslationUncheckedUpdateManyWithoutGlobalNestedInput
  }

  export type NavbarItemTranslationCreateWithoutNavbarItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutNavbarItemsInput
  }

  export type NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput = {
    id?: string
    name: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemTranslationCreateOrConnectWithoutNavbarItemInput = {
    where: NavbarItemTranslationWhereUniqueInput
    create: XOR<NavbarItemTranslationCreateWithoutNavbarItemInput, NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput>
  }

  export type NavbarItemTranslationCreateManyNavbarItemInputEnvelope = {
    data: NavbarItemTranslationCreateManyNavbarItemInput | NavbarItemTranslationCreateManyNavbarItemInput[]
    skipDuplicates?: boolean
  }

  export type DropDownGroupCreateWithoutNavItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropDownGroupTranslationCreateNestedManyWithoutDropdownGroupInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutGroupInput
  }

  export type DropDownGroupUncheckedCreateWithoutNavItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutDropdownGroupInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutGroupInput
  }

  export type DropDownGroupCreateOrConnectWithoutNavItemInput = {
    where: DropDownGroupWhereUniqueInput
    create: XOR<DropDownGroupCreateWithoutNavItemInput, DropDownGroupUncheckedCreateWithoutNavItemInput>
  }

  export type DropDownGroupCreateManyNavItemInputEnvelope = {
    data: DropDownGroupCreateManyNavItemInput | DropDownGroupCreateManyNavItemInput[]
    skipDuplicates?: boolean
  }

  export type DropdownItemCreateWithoutNavItemInput = {
    id?: string
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationCreateNestedManyWithoutDropdownItemInput
    group?: DropDownGroupCreateNestedOneWithoutDropdownItemsInput
    page?: PageCreateNestedOneWithoutDropdownItemInput
    article?: ArticleCreateNestedOneWithoutDropdownItemInput
  }

  export type DropdownItemUncheckedCreateWithoutNavItemInput = {
    id?: string
    groupId?: string | null
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationUncheckedCreateNestedManyWithoutDropdownItemInput
  }

  export type DropdownItemCreateOrConnectWithoutNavItemInput = {
    where: DropdownItemWhereUniqueInput
    create: XOR<DropdownItemCreateWithoutNavItemInput, DropdownItemUncheckedCreateWithoutNavItemInput>
  }

  export type DropdownItemCreateManyNavItemInputEnvelope = {
    data: DropdownItemCreateManyNavItemInput | DropdownItemCreateManyNavItemInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutNavbarItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutPageInput
    groupFooter?: GroupFooterCreateNestedOneWithoutPagesInput
  }

  export type PageUncheckedCreateWithoutNavbarItemInput = {
    id?: string
    groupFooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageCreateOrConnectWithoutNavbarItemInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutNavbarItemInput, PageUncheckedCreateWithoutNavbarItemInput>
  }

  export type ArticleCreateWithoutNavbarItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutNavbarItemInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutNavbarItemInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutNavbarItemInput, ArticleUncheckedCreateWithoutNavbarItemInput>
  }

  export type NavbarItemTranslationUpsertWithWhereUniqueWithoutNavbarItemInput = {
    where: NavbarItemTranslationWhereUniqueInput
    update: XOR<NavbarItemTranslationUpdateWithoutNavbarItemInput, NavbarItemTranslationUncheckedUpdateWithoutNavbarItemInput>
    create: XOR<NavbarItemTranslationCreateWithoutNavbarItemInput, NavbarItemTranslationUncheckedCreateWithoutNavbarItemInput>
  }

  export type NavbarItemTranslationUpdateWithWhereUniqueWithoutNavbarItemInput = {
    where: NavbarItemTranslationWhereUniqueInput
    data: XOR<NavbarItemTranslationUpdateWithoutNavbarItemInput, NavbarItemTranslationUncheckedUpdateWithoutNavbarItemInput>
  }

  export type NavbarItemTranslationUpdateManyWithWhereWithoutNavbarItemInput = {
    where: NavbarItemTranslationScalarWhereInput
    data: XOR<NavbarItemTranslationUpdateManyMutationInput, NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemInput>
  }

  export type DropDownGroupUpsertWithWhereUniqueWithoutNavItemInput = {
    where: DropDownGroupWhereUniqueInput
    update: XOR<DropDownGroupUpdateWithoutNavItemInput, DropDownGroupUncheckedUpdateWithoutNavItemInput>
    create: XOR<DropDownGroupCreateWithoutNavItemInput, DropDownGroupUncheckedCreateWithoutNavItemInput>
  }

  export type DropDownGroupUpdateWithWhereUniqueWithoutNavItemInput = {
    where: DropDownGroupWhereUniqueInput
    data: XOR<DropDownGroupUpdateWithoutNavItemInput, DropDownGroupUncheckedUpdateWithoutNavItemInput>
  }

  export type DropDownGroupUpdateManyWithWhereWithoutNavItemInput = {
    where: DropDownGroupScalarWhereInput
    data: XOR<DropDownGroupUpdateManyMutationInput, DropDownGroupUncheckedUpdateManyWithoutNavItemInput>
  }

  export type DropDownGroupScalarWhereInput = {
    AND?: DropDownGroupScalarWhereInput | DropDownGroupScalarWhereInput[]
    OR?: DropDownGroupScalarWhereInput[]
    NOT?: DropDownGroupScalarWhereInput | DropDownGroupScalarWhereInput[]
    id?: StringFilter<"DropDownGroup"> | string
    navItemId?: StringNullableFilter<"DropDownGroup"> | string | null
    createdAt?: DateTimeFilter<"DropDownGroup"> | Date | string
    updatedAt?: DateTimeFilter<"DropDownGroup"> | Date | string
  }

  export type DropdownItemUpsertWithWhereUniqueWithoutNavItemInput = {
    where: DropdownItemWhereUniqueInput
    update: XOR<DropdownItemUpdateWithoutNavItemInput, DropdownItemUncheckedUpdateWithoutNavItemInput>
    create: XOR<DropdownItemCreateWithoutNavItemInput, DropdownItemUncheckedCreateWithoutNavItemInput>
  }

  export type DropdownItemUpdateWithWhereUniqueWithoutNavItemInput = {
    where: DropdownItemWhereUniqueInput
    data: XOR<DropdownItemUpdateWithoutNavItemInput, DropdownItemUncheckedUpdateWithoutNavItemInput>
  }

  export type DropdownItemUpdateManyWithWhereWithoutNavItemInput = {
    where: DropdownItemScalarWhereInput
    data: XOR<DropdownItemUpdateManyMutationInput, DropdownItemUncheckedUpdateManyWithoutNavItemInput>
  }

  export type DropdownItemScalarWhereInput = {
    AND?: DropdownItemScalarWhereInput | DropdownItemScalarWhereInput[]
    OR?: DropdownItemScalarWhereInput[]
    NOT?: DropdownItemScalarWhereInput | DropdownItemScalarWhereInput[]
    id?: StringFilter<"DropdownItem"> | string
    groupId?: StringNullableFilter<"DropdownItem"> | string | null
    pageId?: StringNullableFilter<"DropdownItem"> | string | null
    forGroup?: BoolFilter<"DropdownItem"> | boolean
    forArticle?: BoolFilter<"DropdownItem"> | boolean
    forPage?: BoolFilter<"DropdownItem"> | boolean
    articleId?: StringNullableFilter<"DropdownItem"> | string | null
    navItemId?: StringNullableFilter<"DropdownItem"> | string | null
    createdAt?: DateTimeFilter<"DropdownItem"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownItem"> | Date | string
  }

  export type PageUpsertWithoutNavbarItemInput = {
    update: XOR<PageUpdateWithoutNavbarItemInput, PageUncheckedUpdateWithoutNavbarItemInput>
    create: XOR<PageCreateWithoutNavbarItemInput, PageUncheckedCreateWithoutNavbarItemInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutNavbarItemInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutNavbarItemInput, PageUncheckedUpdateWithoutNavbarItemInput>
  }

  export type PageUpdateWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutPageNestedInput
    groupFooter?: GroupFooterUpdateOneWithoutPagesNestedInput
  }

  export type PageUncheckedUpdateWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupFooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutPageNestedInput
  }

  export type ArticleUpsertWithoutNavbarItemInput = {
    update: XOR<ArticleUpdateWithoutNavbarItemInput, ArticleUncheckedUpdateWithoutNavbarItemInput>
    create: XOR<ArticleCreateWithoutNavbarItemInput, ArticleUncheckedCreateWithoutNavbarItemInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutNavbarItemInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutNavbarItemInput, ArticleUncheckedUpdateWithoutNavbarItemInput>
  }

  export type ArticleUpdateWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type LanguageCreateWithoutNavbarItemsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutNavbarItemsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutNavbarItemsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutNavbarItemsInput, LanguageUncheckedCreateWithoutNavbarItemsInput>
  }

  export type NavbarItemCreateWithoutTranslationsInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dropdownGroups?: DropDownGroupCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutNavItemInput
    page?: PageCreateNestedOneWithoutNavbarItemInput
    article?: ArticleCreateNestedOneWithoutNavbarItemInput
  }

  export type NavbarItemUncheckedCreateWithoutTranslationsInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: string | null
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropdownGroups?: DropDownGroupUncheckedCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutNavItemInput
  }

  export type NavbarItemCreateOrConnectWithoutTranslationsInput = {
    where: NavbarItemWhereUniqueInput
    create: XOR<NavbarItemCreateWithoutTranslationsInput, NavbarItemUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutNavbarItemsInput = {
    update: XOR<LanguageUpdateWithoutNavbarItemsInput, LanguageUncheckedUpdateWithoutNavbarItemsInput>
    create: XOR<LanguageCreateWithoutNavbarItemsInput, LanguageUncheckedCreateWithoutNavbarItemsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutNavbarItemsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutNavbarItemsInput, LanguageUncheckedUpdateWithoutNavbarItemsInput>
  }

  export type LanguageUpdateWithoutNavbarItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutNavbarItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type NavbarItemUpsertWithoutTranslationsInput = {
    update: XOR<NavbarItemUpdateWithoutTranslationsInput, NavbarItemUncheckedUpdateWithoutTranslationsInput>
    create: XOR<NavbarItemCreateWithoutTranslationsInput, NavbarItemUncheckedCreateWithoutTranslationsInput>
    where?: NavbarItemWhereInput
  }

  export type NavbarItemUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: NavbarItemWhereInput
    data: XOR<NavbarItemUpdateWithoutTranslationsInput, NavbarItemUncheckedUpdateWithoutTranslationsInput>
  }

  export type NavbarItemUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropdownGroups?: DropDownGroupUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutNavItemNestedInput
    page?: PageUpdateOneWithoutNavbarItemNestedInput
    article?: ArticleUpdateOneWithoutNavbarItemNestedInput
  }

  export type NavbarItemUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropdownGroups?: DropDownGroupUncheckedUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutNavItemNestedInput
  }

  export type DropDownGroupTranslationCreateWithoutDropdownGroupInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutDropdownGroupsInput
  }

  export type DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput = {
    id?: string
    name: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupTranslationCreateOrConnectWithoutDropdownGroupInput = {
    where: DropDownGroupTranslationWhereUniqueInput
    create: XOR<DropDownGroupTranslationCreateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput>
  }

  export type DropDownGroupTranslationCreateManyDropdownGroupInputEnvelope = {
    data: DropDownGroupTranslationCreateManyDropdownGroupInput | DropDownGroupTranslationCreateManyDropdownGroupInput[]
    skipDuplicates?: boolean
  }

  export type NavbarItemCreateWithoutDropdownGroupsInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationCreateNestedManyWithoutNavbarItemInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutNavItemInput
    page?: PageCreateNestedOneWithoutNavbarItemInput
    article?: ArticleCreateNestedOneWithoutNavbarItemInput
  }

  export type NavbarItemUncheckedCreateWithoutDropdownGroupsInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: string | null
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationUncheckedCreateNestedManyWithoutNavbarItemInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutNavItemInput
  }

  export type NavbarItemCreateOrConnectWithoutDropdownGroupsInput = {
    where: NavbarItemWhereUniqueInput
    create: XOR<NavbarItemCreateWithoutDropdownGroupsInput, NavbarItemUncheckedCreateWithoutDropdownGroupsInput>
  }

  export type DropdownItemCreateWithoutGroupInput = {
    id?: string
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationCreateNestedManyWithoutDropdownItemInput
    page?: PageCreateNestedOneWithoutDropdownItemInput
    article?: ArticleCreateNestedOneWithoutDropdownItemInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownItemsInput
  }

  export type DropdownItemUncheckedCreateWithoutGroupInput = {
    id?: string
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationUncheckedCreateNestedManyWithoutDropdownItemInput
  }

  export type DropdownItemCreateOrConnectWithoutGroupInput = {
    where: DropdownItemWhereUniqueInput
    create: XOR<DropdownItemCreateWithoutGroupInput, DropdownItemUncheckedCreateWithoutGroupInput>
  }

  export type DropdownItemCreateManyGroupInputEnvelope = {
    data: DropdownItemCreateManyGroupInput | DropdownItemCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type DropDownGroupTranslationUpsertWithWhereUniqueWithoutDropdownGroupInput = {
    where: DropDownGroupTranslationWhereUniqueInput
    update: XOR<DropDownGroupTranslationUpdateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedUpdateWithoutDropdownGroupInput>
    create: XOR<DropDownGroupTranslationCreateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedCreateWithoutDropdownGroupInput>
  }

  export type DropDownGroupTranslationUpdateWithWhereUniqueWithoutDropdownGroupInput = {
    where: DropDownGroupTranslationWhereUniqueInput
    data: XOR<DropDownGroupTranslationUpdateWithoutDropdownGroupInput, DropDownGroupTranslationUncheckedUpdateWithoutDropdownGroupInput>
  }

  export type DropDownGroupTranslationUpdateManyWithWhereWithoutDropdownGroupInput = {
    where: DropDownGroupTranslationScalarWhereInput
    data: XOR<DropDownGroupTranslationUpdateManyMutationInput, DropDownGroupTranslationUncheckedUpdateManyWithoutDropdownGroupInput>
  }

  export type NavbarItemUpsertWithoutDropdownGroupsInput = {
    update: XOR<NavbarItemUpdateWithoutDropdownGroupsInput, NavbarItemUncheckedUpdateWithoutDropdownGroupsInput>
    create: XOR<NavbarItemCreateWithoutDropdownGroupsInput, NavbarItemUncheckedCreateWithoutDropdownGroupsInput>
    where?: NavbarItemWhereInput
  }

  export type NavbarItemUpdateToOneWithWhereWithoutDropdownGroupsInput = {
    where?: NavbarItemWhereInput
    data: XOR<NavbarItemUpdateWithoutDropdownGroupsInput, NavbarItemUncheckedUpdateWithoutDropdownGroupsInput>
  }

  export type NavbarItemUpdateWithoutDropdownGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUpdateManyWithoutNavbarItemNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutNavItemNestedInput
    page?: PageUpdateOneWithoutNavbarItemNestedInput
    article?: ArticleUpdateOneWithoutNavbarItemNestedInput
  }

  export type NavbarItemUncheckedUpdateWithoutDropdownGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutNavItemNestedInput
  }

  export type DropdownItemUpsertWithWhereUniqueWithoutGroupInput = {
    where: DropdownItemWhereUniqueInput
    update: XOR<DropdownItemUpdateWithoutGroupInput, DropdownItemUncheckedUpdateWithoutGroupInput>
    create: XOR<DropdownItemCreateWithoutGroupInput, DropdownItemUncheckedCreateWithoutGroupInput>
  }

  export type DropdownItemUpdateWithWhereUniqueWithoutGroupInput = {
    where: DropdownItemWhereUniqueInput
    data: XOR<DropdownItemUpdateWithoutGroupInput, DropdownItemUncheckedUpdateWithoutGroupInput>
  }

  export type DropdownItemUpdateManyWithWhereWithoutGroupInput = {
    where: DropdownItemScalarWhereInput
    data: XOR<DropdownItemUpdateManyMutationInput, DropdownItemUncheckedUpdateManyWithoutGroupInput>
  }

  export type LanguageCreateWithoutDropdownGroupsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutDropdownGroupsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutDropdownGroupsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutDropdownGroupsInput, LanguageUncheckedCreateWithoutDropdownGroupsInput>
  }

  export type DropDownGroupCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    navItem?: NavbarItemCreateNestedOneWithoutDropdownGroupsInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutGroupInput
  }

  export type DropDownGroupUncheckedCreateWithoutTranslationsInput = {
    id?: string
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutGroupInput
  }

  export type DropDownGroupCreateOrConnectWithoutTranslationsInput = {
    where: DropDownGroupWhereUniqueInput
    create: XOR<DropDownGroupCreateWithoutTranslationsInput, DropDownGroupUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutDropdownGroupsInput = {
    update: XOR<LanguageUpdateWithoutDropdownGroupsInput, LanguageUncheckedUpdateWithoutDropdownGroupsInput>
    create: XOR<LanguageCreateWithoutDropdownGroupsInput, LanguageUncheckedCreateWithoutDropdownGroupsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutDropdownGroupsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutDropdownGroupsInput, LanguageUncheckedUpdateWithoutDropdownGroupsInput>
  }

  export type LanguageUpdateWithoutDropdownGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutDropdownGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type DropDownGroupUpsertWithoutTranslationsInput = {
    update: XOR<DropDownGroupUpdateWithoutTranslationsInput, DropDownGroupUncheckedUpdateWithoutTranslationsInput>
    create: XOR<DropDownGroupCreateWithoutTranslationsInput, DropDownGroupUncheckedCreateWithoutTranslationsInput>
    where?: DropDownGroupWhereInput
  }

  export type DropDownGroupUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: DropDownGroupWhereInput
    data: XOR<DropDownGroupUpdateWithoutTranslationsInput, DropDownGroupUncheckedUpdateWithoutTranslationsInput>
  }

  export type DropDownGroupUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    navItem?: NavbarItemUpdateOneWithoutDropdownGroupsNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutGroupNestedInput
  }

  export type DropDownGroupUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type DropdownItemTranslationCreateWithoutDropdownItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutDropdownItemsInput
  }

  export type DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput = {
    id?: string
    name: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemTranslationCreateOrConnectWithoutDropdownItemInput = {
    where: DropdownItemTranslationWhereUniqueInput
    create: XOR<DropdownItemTranslationCreateWithoutDropdownItemInput, DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput>
  }

  export type DropdownItemTranslationCreateManyDropdownItemInputEnvelope = {
    data: DropdownItemTranslationCreateManyDropdownItemInput | DropdownItemTranslationCreateManyDropdownItemInput[]
    skipDuplicates?: boolean
  }

  export type DropDownGroupCreateWithoutDropdownItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropDownGroupTranslationCreateNestedManyWithoutDropdownGroupInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownGroupsInput
  }

  export type DropDownGroupUncheckedCreateWithoutDropdownItemsInput = {
    id?: string
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutDropdownGroupInput
  }

  export type DropDownGroupCreateOrConnectWithoutDropdownItemsInput = {
    where: DropDownGroupWhereUniqueInput
    create: XOR<DropDownGroupCreateWithoutDropdownItemsInput, DropDownGroupUncheckedCreateWithoutDropdownItemsInput>
  }

  export type PageCreateWithoutDropdownItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    navbarItem?: NavbarItemCreateNestedOneWithoutPageInput
    groupFooter?: GroupFooterCreateNestedOneWithoutPagesInput
  }

  export type PageUncheckedCreateWithoutDropdownItemInput = {
    id?: string
    groupFooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageCreateOrConnectWithoutDropdownItemInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutDropdownItemInput, PageUncheckedCreateWithoutDropdownItemInput>
  }

  export type ArticleCreateWithoutDropdownItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutDropdownItemInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutDropdownItemInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutDropdownItemInput, ArticleUncheckedCreateWithoutDropdownItemInput>
  }

  export type NavbarItemCreateWithoutDropdownItemsInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupCreateNestedManyWithoutNavItemInput
    page?: PageCreateNestedOneWithoutNavbarItemInput
    article?: ArticleCreateNestedOneWithoutNavbarItemInput
  }

  export type NavbarItemUncheckedCreateWithoutDropdownItemsInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: string | null
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationUncheckedCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupUncheckedCreateNestedManyWithoutNavItemInput
  }

  export type NavbarItemCreateOrConnectWithoutDropdownItemsInput = {
    where: NavbarItemWhereUniqueInput
    create: XOR<NavbarItemCreateWithoutDropdownItemsInput, NavbarItemUncheckedCreateWithoutDropdownItemsInput>
  }

  export type DropdownItemTranslationUpsertWithWhereUniqueWithoutDropdownItemInput = {
    where: DropdownItemTranslationWhereUniqueInput
    update: XOR<DropdownItemTranslationUpdateWithoutDropdownItemInput, DropdownItemTranslationUncheckedUpdateWithoutDropdownItemInput>
    create: XOR<DropdownItemTranslationCreateWithoutDropdownItemInput, DropdownItemTranslationUncheckedCreateWithoutDropdownItemInput>
  }

  export type DropdownItemTranslationUpdateWithWhereUniqueWithoutDropdownItemInput = {
    where: DropdownItemTranslationWhereUniqueInput
    data: XOR<DropdownItemTranslationUpdateWithoutDropdownItemInput, DropdownItemTranslationUncheckedUpdateWithoutDropdownItemInput>
  }

  export type DropdownItemTranslationUpdateManyWithWhereWithoutDropdownItemInput = {
    where: DropdownItemTranslationScalarWhereInput
    data: XOR<DropdownItemTranslationUpdateManyMutationInput, DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemInput>
  }

  export type DropDownGroupUpsertWithoutDropdownItemsInput = {
    update: XOR<DropDownGroupUpdateWithoutDropdownItemsInput, DropDownGroupUncheckedUpdateWithoutDropdownItemsInput>
    create: XOR<DropDownGroupCreateWithoutDropdownItemsInput, DropDownGroupUncheckedCreateWithoutDropdownItemsInput>
    where?: DropDownGroupWhereInput
  }

  export type DropDownGroupUpdateToOneWithWhereWithoutDropdownItemsInput = {
    where?: DropDownGroupWhereInput
    data: XOR<DropDownGroupUpdateWithoutDropdownItemsInput, DropDownGroupUncheckedUpdateWithoutDropdownItemsInput>
  }

  export type DropDownGroupUpdateWithoutDropdownItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropDownGroupTranslationUpdateManyWithoutDropdownGroupNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownGroupsNestedInput
  }

  export type DropDownGroupUncheckedUpdateWithoutDropdownItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropDownGroupTranslationUncheckedUpdateManyWithoutDropdownGroupNestedInput
  }

  export type PageUpsertWithoutDropdownItemInput = {
    update: XOR<PageUpdateWithoutDropdownItemInput, PageUncheckedUpdateWithoutDropdownItemInput>
    create: XOR<PageCreateWithoutDropdownItemInput, PageUncheckedCreateWithoutDropdownItemInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutDropdownItemInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutDropdownItemInput, PageUncheckedUpdateWithoutDropdownItemInput>
  }

  export type PageUpdateWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutPageNestedInput
    groupFooter?: GroupFooterUpdateOneWithoutPagesNestedInput
  }

  export type PageUncheckedUpdateWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupFooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutPageNestedInput
  }

  export type ArticleUpsertWithoutDropdownItemInput = {
    update: XOR<ArticleUpdateWithoutDropdownItemInput, ArticleUncheckedUpdateWithoutDropdownItemInput>
    create: XOR<ArticleCreateWithoutDropdownItemInput, ArticleUncheckedCreateWithoutDropdownItemInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutDropdownItemInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutDropdownItemInput, ArticleUncheckedUpdateWithoutDropdownItemInput>
  }

  export type ArticleUpdateWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type NavbarItemUpsertWithoutDropdownItemsInput = {
    update: XOR<NavbarItemUpdateWithoutDropdownItemsInput, NavbarItemUncheckedUpdateWithoutDropdownItemsInput>
    create: XOR<NavbarItemCreateWithoutDropdownItemsInput, NavbarItemUncheckedCreateWithoutDropdownItemsInput>
    where?: NavbarItemWhereInput
  }

  export type NavbarItemUpdateToOneWithWhereWithoutDropdownItemsInput = {
    where?: NavbarItemWhereInput
    data: XOR<NavbarItemUpdateWithoutDropdownItemsInput, NavbarItemUncheckedUpdateWithoutDropdownItemsInput>
  }

  export type NavbarItemUpdateWithoutDropdownItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUpdateManyWithoutNavItemNestedInput
    page?: PageUpdateOneWithoutNavbarItemNestedInput
    article?: ArticleUpdateOneWithoutNavbarItemNestedInput
  }

  export type NavbarItemUncheckedUpdateWithoutDropdownItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUncheckedUpdateManyWithoutNavItemNestedInput
  }

  export type LanguageCreateWithoutDropdownItemsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutDropdownItemsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutDropdownItemsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutDropdownItemsInput, LanguageUncheckedCreateWithoutDropdownItemsInput>
  }

  export type DropdownItemCreateWithoutTranslationsInput = {
    id?: string
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: DropDownGroupCreateNestedOneWithoutDropdownItemsInput
    page?: PageCreateNestedOneWithoutDropdownItemInput
    article?: ArticleCreateNestedOneWithoutDropdownItemInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownItemsInput
  }

  export type DropdownItemUncheckedCreateWithoutTranslationsInput = {
    id?: string
    groupId?: string | null
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemCreateOrConnectWithoutTranslationsInput = {
    where: DropdownItemWhereUniqueInput
    create: XOR<DropdownItemCreateWithoutTranslationsInput, DropdownItemUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutDropdownItemsInput = {
    update: XOR<LanguageUpdateWithoutDropdownItemsInput, LanguageUncheckedUpdateWithoutDropdownItemsInput>
    create: XOR<LanguageCreateWithoutDropdownItemsInput, LanguageUncheckedCreateWithoutDropdownItemsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutDropdownItemsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutDropdownItemsInput, LanguageUncheckedUpdateWithoutDropdownItemsInput>
  }

  export type LanguageUpdateWithoutDropdownItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutDropdownItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type DropdownItemUpsertWithoutTranslationsInput = {
    update: XOR<DropdownItemUpdateWithoutTranslationsInput, DropdownItemUncheckedUpdateWithoutTranslationsInput>
    create: XOR<DropdownItemCreateWithoutTranslationsInput, DropdownItemUncheckedCreateWithoutTranslationsInput>
    where?: DropdownItemWhereInput
  }

  export type DropdownItemUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: DropdownItemWhereInput
    data: XOR<DropdownItemUpdateWithoutTranslationsInput, DropdownItemUncheckedUpdateWithoutTranslationsInput>
  }

  export type DropdownItemUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: DropDownGroupUpdateOneWithoutDropdownItemsNestedInput
    page?: PageUpdateOneWithoutDropdownItemNestedInput
    article?: ArticleUpdateOneWithoutDropdownItemNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownItemsNestedInput
  }

  export type DropdownItemUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationCreateWithoutFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutFootersInput
  }

  export type FooterTranslationUncheckedCreateWithoutFooterInput = {
    id?: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterTranslationCreateOrConnectWithoutFooterInput = {
    where: FooterTranslationWhereUniqueInput
    create: XOR<FooterTranslationCreateWithoutFooterInput, FooterTranslationUncheckedCreateWithoutFooterInput>
  }

  export type FooterTranslationCreateManyFooterInputEnvelope = {
    data: FooterTranslationCreateManyFooterInput | FooterTranslationCreateManyFooterInput[]
    skipDuplicates?: boolean
  }

  export type GroupFooterCreateWithoutFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationCreateNestedManyWithoutGroupfooterInput
    articles?: ArticleCreateNestedManyWithoutGroupfooterInput
    pages?: PageCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterUncheckedCreateWithoutFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationUncheckedCreateNestedManyWithoutGroupfooterInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupfooterInput
    pages?: PageUncheckedCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterCreateOrConnectWithoutFooterInput = {
    where: GroupFooterWhereUniqueInput
    create: XOR<GroupFooterCreateWithoutFooterInput, GroupFooterUncheckedCreateWithoutFooterInput>
  }

  export type GroupFooterCreateManyFooterInputEnvelope = {
    data: GroupFooterCreateManyFooterInput | GroupFooterCreateManyFooterInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutFooterInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutFooterInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutFooterInput, ArticleUncheckedCreateWithoutFooterInput>
  }

  export type ArticleCreateManyFooterInputEnvelope = {
    data: ArticleCreateManyFooterInput | ArticleCreateManyFooterInput[]
    skipDuplicates?: boolean
  }

  export type FooterTranslationUpsertWithWhereUniqueWithoutFooterInput = {
    where: FooterTranslationWhereUniqueInput
    update: XOR<FooterTranslationUpdateWithoutFooterInput, FooterTranslationUncheckedUpdateWithoutFooterInput>
    create: XOR<FooterTranslationCreateWithoutFooterInput, FooterTranslationUncheckedCreateWithoutFooterInput>
  }

  export type FooterTranslationUpdateWithWhereUniqueWithoutFooterInput = {
    where: FooterTranslationWhereUniqueInput
    data: XOR<FooterTranslationUpdateWithoutFooterInput, FooterTranslationUncheckedUpdateWithoutFooterInput>
  }

  export type FooterTranslationUpdateManyWithWhereWithoutFooterInput = {
    where: FooterTranslationScalarWhereInput
    data: XOR<FooterTranslationUpdateManyMutationInput, FooterTranslationUncheckedUpdateManyWithoutFooterInput>
  }

  export type GroupFooterUpsertWithWhereUniqueWithoutFooterInput = {
    where: GroupFooterWhereUniqueInput
    update: XOR<GroupFooterUpdateWithoutFooterInput, GroupFooterUncheckedUpdateWithoutFooterInput>
    create: XOR<GroupFooterCreateWithoutFooterInput, GroupFooterUncheckedCreateWithoutFooterInput>
  }

  export type GroupFooterUpdateWithWhereUniqueWithoutFooterInput = {
    where: GroupFooterWhereUniqueInput
    data: XOR<GroupFooterUpdateWithoutFooterInput, GroupFooterUncheckedUpdateWithoutFooterInput>
  }

  export type GroupFooterUpdateManyWithWhereWithoutFooterInput = {
    where: GroupFooterScalarWhereInput
    data: XOR<GroupFooterUpdateManyMutationInput, GroupFooterUncheckedUpdateManyWithoutFooterInput>
  }

  export type GroupFooterScalarWhereInput = {
    AND?: GroupFooterScalarWhereInput | GroupFooterScalarWhereInput[]
    OR?: GroupFooterScalarWhereInput[]
    NOT?: GroupFooterScalarWhereInput | GroupFooterScalarWhereInput[]
    id?: StringFilter<"GroupFooter"> | string
    footerId?: StringNullableFilter<"GroupFooter"> | string | null
    createdAt?: DateTimeFilter<"GroupFooter"> | Date | string
    updatedAt?: DateTimeFilter<"GroupFooter"> | Date | string
  }

  export type ArticleUpsertWithWhereUniqueWithoutFooterInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutFooterInput, ArticleUncheckedUpdateWithoutFooterInput>
    create: XOR<ArticleCreateWithoutFooterInput, ArticleUncheckedCreateWithoutFooterInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutFooterInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutFooterInput, ArticleUncheckedUpdateWithoutFooterInput>
  }

  export type ArticleUpdateManyWithWhereWithoutFooterInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutFooterInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    OR?: ArticleScalarWhereInput[]
    NOT?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    id?: StringFilter<"Article"> | string
    categoryId?: StringNullableFilter<"Article"> | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    footerId?: StringNullableFilter<"Article"> | string | null
    groupfooterId?: StringNullableFilter<"Article"> | string | null
  }

  export type LanguageCreateWithoutFootersInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutFootersInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutFootersInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutFootersInput, LanguageUncheckedCreateWithoutFootersInput>
  }

  export type FooterCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupFooterCreateNestedManyWithoutFooterInput
    articles?: ArticleCreateNestedManyWithoutFooterInput
  }

  export type FooterUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupFooterUncheckedCreateNestedManyWithoutFooterInput
    articles?: ArticleUncheckedCreateNestedManyWithoutFooterInput
  }

  export type FooterCreateOrConnectWithoutTranslationsInput = {
    where: FooterWhereUniqueInput
    create: XOR<FooterCreateWithoutTranslationsInput, FooterUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutFootersInput = {
    update: XOR<LanguageUpdateWithoutFootersInput, LanguageUncheckedUpdateWithoutFootersInput>
    create: XOR<LanguageCreateWithoutFootersInput, LanguageUncheckedCreateWithoutFootersInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutFootersInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutFootersInput, LanguageUncheckedUpdateWithoutFootersInput>
  }

  export type LanguageUpdateWithoutFootersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutFootersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type FooterUpsertWithoutTranslationsInput = {
    update: XOR<FooterUpdateWithoutTranslationsInput, FooterUncheckedUpdateWithoutTranslationsInput>
    create: XOR<FooterCreateWithoutTranslationsInput, FooterUncheckedCreateWithoutTranslationsInput>
    where?: FooterWhereInput
  }

  export type FooterUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: FooterWhereInput
    data: XOR<FooterUpdateWithoutTranslationsInput, FooterUncheckedUpdateWithoutTranslationsInput>
  }

  export type FooterUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupFooterUpdateManyWithoutFooterNestedInput
    articles?: ArticleUpdateManyWithoutFooterNestedInput
  }

  export type FooterUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupFooterUncheckedUpdateManyWithoutFooterNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutFooterNestedInput
  }

  export type GroupFooterTranslationCreateWithoutGroupfooterInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutGroupFootersInput
  }

  export type GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput = {
    id?: string
    title?: string | null
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterTranslationCreateOrConnectWithoutGroupfooterInput = {
    where: GroupFooterTranslationWhereUniqueInput
    create: XOR<GroupFooterTranslationCreateWithoutGroupfooterInput, GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput>
  }

  export type GroupFooterTranslationCreateManyGroupfooterInputEnvelope = {
    data: GroupFooterTranslationCreateManyGroupfooterInput | GroupFooterTranslationCreateManyGroupfooterInput[]
    skipDuplicates?: boolean
  }

  export type FooterCreateWithoutGroupsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: FooterTranslationCreateNestedManyWithoutFooterInput
    articles?: ArticleCreateNestedManyWithoutFooterInput
  }

  export type FooterUncheckedCreateWithoutGroupsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: FooterTranslationUncheckedCreateNestedManyWithoutFooterInput
    articles?: ArticleUncheckedCreateNestedManyWithoutFooterInput
  }

  export type FooterCreateOrConnectWithoutGroupsInput = {
    where: FooterWhereUniqueInput
    create: XOR<FooterCreateWithoutGroupsInput, FooterUncheckedCreateWithoutGroupsInput>
  }

  export type ArticleCreateWithoutGroupfooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutGroupfooterInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutGroupfooterInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutGroupfooterInput, ArticleUncheckedCreateWithoutGroupfooterInput>
  }

  export type ArticleCreateManyGroupfooterInputEnvelope = {
    data: ArticleCreateManyGroupfooterInput | ArticleCreateManyGroupfooterInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutGroupFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    navbarItem?: NavbarItemCreateNestedOneWithoutPageInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutPageInput
  }

  export type PageUncheckedCreateWithoutGroupFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutPageInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageCreateOrConnectWithoutGroupFooterInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutGroupFooterInput, PageUncheckedCreateWithoutGroupFooterInput>
  }

  export type PageCreateManyGroupFooterInputEnvelope = {
    data: PageCreateManyGroupFooterInput | PageCreateManyGroupFooterInput[]
    skipDuplicates?: boolean
  }

  export type GroupFooterTranslationUpsertWithWhereUniqueWithoutGroupfooterInput = {
    where: GroupFooterTranslationWhereUniqueInput
    update: XOR<GroupFooterTranslationUpdateWithoutGroupfooterInput, GroupFooterTranslationUncheckedUpdateWithoutGroupfooterInput>
    create: XOR<GroupFooterTranslationCreateWithoutGroupfooterInput, GroupFooterTranslationUncheckedCreateWithoutGroupfooterInput>
  }

  export type GroupFooterTranslationUpdateWithWhereUniqueWithoutGroupfooterInput = {
    where: GroupFooterTranslationWhereUniqueInput
    data: XOR<GroupFooterTranslationUpdateWithoutGroupfooterInput, GroupFooterTranslationUncheckedUpdateWithoutGroupfooterInput>
  }

  export type GroupFooterTranslationUpdateManyWithWhereWithoutGroupfooterInput = {
    where: GroupFooterTranslationScalarWhereInput
    data: XOR<GroupFooterTranslationUpdateManyMutationInput, GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterInput>
  }

  export type FooterUpsertWithoutGroupsInput = {
    update: XOR<FooterUpdateWithoutGroupsInput, FooterUncheckedUpdateWithoutGroupsInput>
    create: XOR<FooterCreateWithoutGroupsInput, FooterUncheckedCreateWithoutGroupsInput>
    where?: FooterWhereInput
  }

  export type FooterUpdateToOneWithWhereWithoutGroupsInput = {
    where?: FooterWhereInput
    data: XOR<FooterUpdateWithoutGroupsInput, FooterUncheckedUpdateWithoutGroupsInput>
  }

  export type FooterUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: FooterTranslationUpdateManyWithoutFooterNestedInput
    articles?: ArticleUpdateManyWithoutFooterNestedInput
  }

  export type FooterUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: FooterTranslationUncheckedUpdateManyWithoutFooterNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutFooterNestedInput
  }

  export type ArticleUpsertWithWhereUniqueWithoutGroupfooterInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutGroupfooterInput, ArticleUncheckedUpdateWithoutGroupfooterInput>
    create: XOR<ArticleCreateWithoutGroupfooterInput, ArticleUncheckedCreateWithoutGroupfooterInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutGroupfooterInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutGroupfooterInput, ArticleUncheckedUpdateWithoutGroupfooterInput>
  }

  export type ArticleUpdateManyWithWhereWithoutGroupfooterInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutGroupfooterInput>
  }

  export type PageUpsertWithWhereUniqueWithoutGroupFooterInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutGroupFooterInput, PageUncheckedUpdateWithoutGroupFooterInput>
    create: XOR<PageCreateWithoutGroupFooterInput, PageUncheckedCreateWithoutGroupFooterInput>
  }

  export type PageUpdateWithWhereUniqueWithoutGroupFooterInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutGroupFooterInput, PageUncheckedUpdateWithoutGroupFooterInput>
  }

  export type PageUpdateManyWithWhereWithoutGroupFooterInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutGroupFooterInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: StringFilter<"Page"> | string
    groupFooterId?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }

  export type GroupFooterCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    footer?: FooterCreateNestedOneWithoutGroupsInput
    articles?: ArticleCreateNestedManyWithoutGroupfooterInput
    pages?: PageCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterUncheckedCreateWithoutTranslationsInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupfooterInput
    pages?: PageUncheckedCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterCreateOrConnectWithoutTranslationsInput = {
    where: GroupFooterWhereUniqueInput
    create: XOR<GroupFooterCreateWithoutTranslationsInput, GroupFooterUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageCreateWithoutGroupFootersInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutGroupFootersInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutGroupFootersInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutGroupFootersInput, LanguageUncheckedCreateWithoutGroupFootersInput>
  }

  export type GroupFooterUpsertWithoutTranslationsInput = {
    update: XOR<GroupFooterUpdateWithoutTranslationsInput, GroupFooterUncheckedUpdateWithoutTranslationsInput>
    create: XOR<GroupFooterCreateWithoutTranslationsInput, GroupFooterUncheckedCreateWithoutTranslationsInput>
    where?: GroupFooterWhereInput
  }

  export type GroupFooterUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: GroupFooterWhereInput
    data: XOR<GroupFooterUpdateWithoutTranslationsInput, GroupFooterUncheckedUpdateWithoutTranslationsInput>
  }

  export type GroupFooterUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footer?: FooterUpdateOneWithoutGroupsNestedInput
    articles?: ArticleUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUpdateManyWithoutGroupFooterNestedInput
  }

  export type GroupFooterUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUncheckedUpdateManyWithoutGroupFooterNestedInput
  }

  export type LanguageUpsertWithoutGroupFootersInput = {
    update: XOR<LanguageUpdateWithoutGroupFootersInput, LanguageUncheckedUpdateWithoutGroupFootersInput>
    create: XOR<LanguageCreateWithoutGroupFootersInput, LanguageUncheckedCreateWithoutGroupFootersInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutGroupFootersInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutGroupFootersInput, LanguageUncheckedUpdateWithoutGroupFootersInput>
  }

  export type LanguageUpdateWithoutGroupFootersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutGroupFootersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type PageTranslationCreateWithoutPageInput = {
    id?: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutPagesInput
    author: UserCreateNestedOneWithoutPagesInput
    blocks?: BlockCreateNestedManyWithoutPageInput
  }

  export type PageTranslationUncheckedCreateWithoutPageInput = {
    id?: string
    lang: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageTranslationCreateOrConnectWithoutPageInput = {
    where: PageTranslationWhereUniqueInput
    create: XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput>
  }

  export type PageTranslationCreateManyPageInputEnvelope = {
    data: PageTranslationCreateManyPageInput | PageTranslationCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type NavbarItemCreateWithoutPageInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutNavItemInput
    article?: ArticleCreateNestedOneWithoutNavbarItemInput
  }

  export type NavbarItemUncheckedCreateWithoutPageInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationUncheckedCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupUncheckedCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutNavItemInput
  }

  export type NavbarItemCreateOrConnectWithoutPageInput = {
    where: NavbarItemWhereUniqueInput
    create: XOR<NavbarItemCreateWithoutPageInput, NavbarItemUncheckedCreateWithoutPageInput>
  }

  export type DropdownItemCreateWithoutPageInput = {
    id?: string
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationCreateNestedManyWithoutDropdownItemInput
    group?: DropDownGroupCreateNestedOneWithoutDropdownItemsInput
    article?: ArticleCreateNestedOneWithoutDropdownItemInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownItemsInput
  }

  export type DropdownItemUncheckedCreateWithoutPageInput = {
    id?: string
    groupId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationUncheckedCreateNestedManyWithoutDropdownItemInput
  }

  export type DropdownItemCreateOrConnectWithoutPageInput = {
    where: DropdownItemWhereUniqueInput
    create: XOR<DropdownItemCreateWithoutPageInput, DropdownItemUncheckedCreateWithoutPageInput>
  }

  export type GroupFooterCreateWithoutPagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationCreateNestedManyWithoutGroupfooterInput
    footer?: FooterCreateNestedOneWithoutGroupsInput
    articles?: ArticleCreateNestedManyWithoutGroupfooterInput
  }

  export type GroupFooterUncheckedCreateWithoutPagesInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationUncheckedCreateNestedManyWithoutGroupfooterInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupfooterInput
  }

  export type GroupFooterCreateOrConnectWithoutPagesInput = {
    where: GroupFooterWhereUniqueInput
    create: XOR<GroupFooterCreateWithoutPagesInput, GroupFooterUncheckedCreateWithoutPagesInput>
  }

  export type PageTranslationUpsertWithWhereUniqueWithoutPageInput = {
    where: PageTranslationWhereUniqueInput
    update: XOR<PageTranslationUpdateWithoutPageInput, PageTranslationUncheckedUpdateWithoutPageInput>
    create: XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput>
  }

  export type PageTranslationUpdateWithWhereUniqueWithoutPageInput = {
    where: PageTranslationWhereUniqueInput
    data: XOR<PageTranslationUpdateWithoutPageInput, PageTranslationUncheckedUpdateWithoutPageInput>
  }

  export type PageTranslationUpdateManyWithWhereWithoutPageInput = {
    where: PageTranslationScalarWhereInput
    data: XOR<PageTranslationUpdateManyMutationInput, PageTranslationUncheckedUpdateManyWithoutPageInput>
  }

  export type NavbarItemUpsertWithoutPageInput = {
    update: XOR<NavbarItemUpdateWithoutPageInput, NavbarItemUncheckedUpdateWithoutPageInput>
    create: XOR<NavbarItemCreateWithoutPageInput, NavbarItemUncheckedCreateWithoutPageInput>
    where?: NavbarItemWhereInput
  }

  export type NavbarItemUpdateToOneWithWhereWithoutPageInput = {
    where?: NavbarItemWhereInput
    data: XOR<NavbarItemUpdateWithoutPageInput, NavbarItemUncheckedUpdateWithoutPageInput>
  }

  export type NavbarItemUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutNavItemNestedInput
    article?: ArticleUpdateOneWithoutNavbarItemNestedInput
  }

  export type NavbarItemUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUncheckedUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutNavItemNestedInput
  }

  export type DropdownItemUpsertWithoutPageInput = {
    update: XOR<DropdownItemUpdateWithoutPageInput, DropdownItemUncheckedUpdateWithoutPageInput>
    create: XOR<DropdownItemCreateWithoutPageInput, DropdownItemUncheckedCreateWithoutPageInput>
    where?: DropdownItemWhereInput
  }

  export type DropdownItemUpdateToOneWithWhereWithoutPageInput = {
    where?: DropdownItemWhereInput
    data: XOR<DropdownItemUpdateWithoutPageInput, DropdownItemUncheckedUpdateWithoutPageInput>
  }

  export type DropdownItemUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUpdateManyWithoutDropdownItemNestedInput
    group?: DropDownGroupUpdateOneWithoutDropdownItemsNestedInput
    article?: ArticleUpdateOneWithoutDropdownItemNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownItemsNestedInput
  }

  export type DropdownItemUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemNestedInput
  }

  export type GroupFooterUpsertWithoutPagesInput = {
    update: XOR<GroupFooterUpdateWithoutPagesInput, GroupFooterUncheckedUpdateWithoutPagesInput>
    create: XOR<GroupFooterCreateWithoutPagesInput, GroupFooterUncheckedCreateWithoutPagesInput>
    where?: GroupFooterWhereInput
  }

  export type GroupFooterUpdateToOneWithWhereWithoutPagesInput = {
    where?: GroupFooterWhereInput
    data: XOR<GroupFooterUpdateWithoutPagesInput, GroupFooterUncheckedUpdateWithoutPagesInput>
  }

  export type GroupFooterUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUpdateManyWithoutGroupfooterNestedInput
    footer?: FooterUpdateOneWithoutGroupsNestedInput
    articles?: ArticleUpdateManyWithoutGroupfooterNestedInput
  }

  export type GroupFooterUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupfooterNestedInput
  }

  export type LanguageCreateWithoutPagesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutPagesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutPagesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutPagesInput, LanguageUncheckedCreateWithoutPagesInput>
  }

  export type UserCreateWithoutPagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutPagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutPagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
  }

  export type BlockCreateWithoutPageInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    article?: ArticleTranslationCreateNestedOneWithoutBlocksInput
    categoryService?: CategoryServiceTranslationCreateNestedOneWithoutBlocksInput
    service?: ServiceTranslationCreateNestedOneWithoutBlocksInput
  }

  export type BlockUncheckedCreateWithoutPageInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    articleId?: string | null
    categoryServiceId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutPageInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutPageInput, BlockUncheckedCreateWithoutPageInput>
  }

  export type BlockCreateManyPageInputEnvelope = {
    data: BlockCreateManyPageInput | BlockCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    navbarItem?: NavbarItemCreateNestedOneWithoutPageInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutPageInput
    groupFooter?: GroupFooterCreateNestedOneWithoutPagesInput
  }

  export type PageUncheckedCreateWithoutTranslationsInput = {
    id?: string
    groupFooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutPageInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageCreateOrConnectWithoutTranslationsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutPagesInput = {
    update: XOR<LanguageUpdateWithoutPagesInput, LanguageUncheckedUpdateWithoutPagesInput>
    create: XOR<LanguageCreateWithoutPagesInput, LanguageUncheckedCreateWithoutPagesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutPagesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutPagesInput, LanguageUncheckedUpdateWithoutPagesInput>
  }

  export type LanguageUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type UserUpsertWithoutPagesInput = {
    update: XOR<UserUpdateWithoutPagesInput, UserUncheckedUpdateWithoutPagesInput>
    create: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPagesInput, UserUncheckedUpdateWithoutPagesInput>
  }

  export type UserUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type BlockUpsertWithWhereUniqueWithoutPageInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutPageInput, BlockUncheckedUpdateWithoutPageInput>
    create: XOR<BlockCreateWithoutPageInput, BlockUncheckedCreateWithoutPageInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutPageInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutPageInput, BlockUncheckedUpdateWithoutPageInput>
  }

  export type BlockUpdateManyWithWhereWithoutPageInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutPageInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: StringFilter<"Block"> | string
    type?: StringNullableFilter<"Block"> | string | null
    content?: JsonNullableFilter<"Block">
    pageId?: StringNullableFilter<"Block"> | string | null
    articleId?: StringNullableFilter<"Block"> | string | null
    categoryServiceId?: StringNullableFilter<"Block"> | string | null
    serviceId?: StringNullableFilter<"Block"> | string | null
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type PageUpsertWithoutTranslationsInput = {
    update: XOR<PageUpdateWithoutTranslationsInput, PageUncheckedUpdateWithoutTranslationsInput>
    create: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutTranslationsInput, PageUncheckedUpdateWithoutTranslationsInput>
  }

  export type PageUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    navbarItem?: NavbarItemUpdateOneWithoutPageNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutPageNestedInput
    groupFooter?: GroupFooterUpdateOneWithoutPagesNestedInput
  }

  export type PageUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupFooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutPageNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutPageNestedInput
  }

  export type CategoryTranslationCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCategoreisInput
    author: UserCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryTranslationUncheckedCreateWithoutCategoryInput = {
    id?: string
    lang: string
    userId: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationCreateOrConnectWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    create: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryTranslationCreateManyCategoryInputEnvelope = {
    data: CategoryTranslationCreateManyCategoryInput | CategoryTranslationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCategoryInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput>
  }

  export type ArticleCreateManyCategoryInputEnvelope = {
    data: ArticleCreateManyCategoryInput | ArticleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    update: XOR<CategoryTranslationUpdateWithoutCategoryInput, CategoryTranslationUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    data: XOR<CategoryTranslationUpdateWithoutCategoryInput, CategoryTranslationUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryTranslationUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryTranslationScalarWhereInput
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ArticleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutCategoryInput, ArticleUncheckedUpdateWithoutCategoryInput>
    create: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutCategoryInput, ArticleUncheckedUpdateWithoutCategoryInput>
  }

  export type ArticleUpdateManyWithWhereWithoutCategoryInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type LanguageCreateWithoutCategoreisInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutCategoreisInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutCategoreisInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutCategoreisInput, LanguageUncheckedCreateWithoutCategoreisInput>
  }

  export type UserCreateWithoutCategoriesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTranslationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutCategoreisInput = {
    update: XOR<LanguageUpdateWithoutCategoreisInput, LanguageUncheckedUpdateWithoutCategoreisInput>
    create: XOR<LanguageCreateWithoutCategoreisInput, LanguageUncheckedCreateWithoutCategoreisInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutCategoreisInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutCategoreisInput, LanguageUncheckedUpdateWithoutCategoreisInput>
  }

  export type LanguageUpdateWithoutCategoreisInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutCategoreisInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type UserUpsertWithoutCategoriesInput = {
    update: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type UserUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CategoryUpsertWithoutTranslationsInput = {
    update: XOR<CategoryUpdateWithoutTranslationsInput, CategoryUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTranslationsInput, CategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type CategoryUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleTranslationCreateWithoutArticleInput = {
    id?: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutArticlesInput
    blocks?: BlockCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationUncheckedCreateWithoutArticleInput = {
    id?: string
    lang: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleTranslationCreateOrConnectWithoutArticleInput = {
    where: ArticleTranslationWhereUniqueInput
    create: XOR<ArticleTranslationCreateWithoutArticleInput, ArticleTranslationUncheckedCreateWithoutArticleInput>
  }

  export type ArticleTranslationCreateManyArticleInputEnvelope = {
    data: ArticleTranslationCreateManyArticleInput | ArticleTranslationCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutArticlesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
  }

  export type TagCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TagTranslationCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TagTranslationUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutArticlesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput>
  }

  export type CommentCreateWithoutArticleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CommentTranslationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutArticleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CommentTranslationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutArticleInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentCreateManyArticleInputEnvelope = {
    data: CommentCreateManyArticleInput | CommentCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type FooterCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: FooterTranslationCreateNestedManyWithoutFooterInput
    groups?: GroupFooterCreateNestedManyWithoutFooterInput
  }

  export type FooterUncheckedCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: FooterTranslationUncheckedCreateNestedManyWithoutFooterInput
    groups?: GroupFooterUncheckedCreateNestedManyWithoutFooterInput
  }

  export type FooterCreateOrConnectWithoutArticlesInput = {
    where: FooterWhereUniqueInput
    create: XOR<FooterCreateWithoutArticlesInput, FooterUncheckedCreateWithoutArticlesInput>
  }

  export type GroupFooterCreateWithoutArticlesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationCreateNestedManyWithoutGroupfooterInput
    footer?: FooterCreateNestedOneWithoutGroupsInput
    pages?: PageCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterUncheckedCreateWithoutArticlesInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: GroupFooterTranslationUncheckedCreateNestedManyWithoutGroupfooterInput
    pages?: PageUncheckedCreateNestedManyWithoutGroupFooterInput
  }

  export type GroupFooterCreateOrConnectWithoutArticlesInput = {
    where: GroupFooterWhereUniqueInput
    create: XOR<GroupFooterCreateWithoutArticlesInput, GroupFooterUncheckedCreateWithoutArticlesInput>
  }

  export type NavbarItemCreateWithoutArticleInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemCreateNestedManyWithoutNavItemInput
    page?: PageCreateNestedOneWithoutNavbarItemInput
  }

  export type NavbarItemUncheckedCreateWithoutArticleInput = {
    id?: string
    isDropdown?: boolean
    forArticle?: boolean
    forPage?: boolean
    pageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavbarItemTranslationUncheckedCreateNestedManyWithoutNavbarItemInput
    dropdownGroups?: DropDownGroupUncheckedCreateNestedManyWithoutNavItemInput
    dropdownItems?: DropdownItemUncheckedCreateNestedManyWithoutNavItemInput
  }

  export type NavbarItemCreateOrConnectWithoutArticleInput = {
    where: NavbarItemWhereUniqueInput
    create: XOR<NavbarItemCreateWithoutArticleInput, NavbarItemUncheckedCreateWithoutArticleInput>
  }

  export type DropdownItemCreateWithoutArticleInput = {
    id?: string
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationCreateNestedManyWithoutDropdownItemInput
    group?: DropDownGroupCreateNestedOneWithoutDropdownItemsInput
    page?: PageCreateNestedOneWithoutDropdownItemInput
    navItem?: NavbarItemCreateNestedOneWithoutDropdownItemsInput
  }

  export type DropdownItemUncheckedCreateWithoutArticleInput = {
    id?: string
    groupId?: string | null
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: DropdownItemTranslationUncheckedCreateNestedManyWithoutDropdownItemInput
  }

  export type DropdownItemCreateOrConnectWithoutArticleInput = {
    where: DropdownItemWhereUniqueInput
    create: XOR<DropdownItemCreateWithoutArticleInput, DropdownItemUncheckedCreateWithoutArticleInput>
  }

  export type ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleTranslationWhereUniqueInput
    update: XOR<ArticleTranslationUpdateWithoutArticleInput, ArticleTranslationUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleTranslationCreateWithoutArticleInput, ArticleTranslationUncheckedCreateWithoutArticleInput>
  }

  export type ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleTranslationWhereUniqueInput
    data: XOR<ArticleTranslationUpdateWithoutArticleInput, ArticleTranslationUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleTranslationUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleTranslationScalarWhereInput
    data: XOR<ArticleTranslationUpdateManyMutationInput, ArticleTranslationUncheckedUpdateManyWithoutArticleInput>
  }

  export type CategoryUpsertWithoutArticlesInput = {
    update: XOR<CategoryUpdateWithoutArticlesInput, CategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutArticlesInput, CategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type CategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TagUpsertWithWhereUniqueWithoutArticlesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutArticlesInput, TagUncheckedUpdateWithoutArticlesInput>
    create: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutArticlesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutArticlesInput, TagUncheckedUpdateWithoutArticlesInput>
  }

  export type TagUpdateManyWithWhereWithoutArticlesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutArticlesInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
  }

  export type CommentUpdateManyWithWhereWithoutArticleInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutArticleInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    articleId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type FooterUpsertWithoutArticlesInput = {
    update: XOR<FooterUpdateWithoutArticlesInput, FooterUncheckedUpdateWithoutArticlesInput>
    create: XOR<FooterCreateWithoutArticlesInput, FooterUncheckedCreateWithoutArticlesInput>
    where?: FooterWhereInput
  }

  export type FooterUpdateToOneWithWhereWithoutArticlesInput = {
    where?: FooterWhereInput
    data: XOR<FooterUpdateWithoutArticlesInput, FooterUncheckedUpdateWithoutArticlesInput>
  }

  export type FooterUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: FooterTranslationUpdateManyWithoutFooterNestedInput
    groups?: GroupFooterUpdateManyWithoutFooterNestedInput
  }

  export type FooterUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: FooterTranslationUncheckedUpdateManyWithoutFooterNestedInput
    groups?: GroupFooterUncheckedUpdateManyWithoutFooterNestedInput
  }

  export type GroupFooterUpsertWithoutArticlesInput = {
    update: XOR<GroupFooterUpdateWithoutArticlesInput, GroupFooterUncheckedUpdateWithoutArticlesInput>
    create: XOR<GroupFooterCreateWithoutArticlesInput, GroupFooterUncheckedCreateWithoutArticlesInput>
    where?: GroupFooterWhereInput
  }

  export type GroupFooterUpdateToOneWithWhereWithoutArticlesInput = {
    where?: GroupFooterWhereInput
    data: XOR<GroupFooterUpdateWithoutArticlesInput, GroupFooterUncheckedUpdateWithoutArticlesInput>
  }

  export type GroupFooterUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUpdateManyWithoutGroupfooterNestedInput
    footer?: FooterUpdateOneWithoutGroupsNestedInput
    pages?: PageUpdateManyWithoutGroupFooterNestedInput
  }

  export type GroupFooterUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUncheckedUpdateManyWithoutGroupFooterNestedInput
  }

  export type NavbarItemUpsertWithoutArticleInput = {
    update: XOR<NavbarItemUpdateWithoutArticleInput, NavbarItemUncheckedUpdateWithoutArticleInput>
    create: XOR<NavbarItemCreateWithoutArticleInput, NavbarItemUncheckedCreateWithoutArticleInput>
    where?: NavbarItemWhereInput
  }

  export type NavbarItemUpdateToOneWithWhereWithoutArticleInput = {
    where?: NavbarItemWhereInput
    data: XOR<NavbarItemUpdateWithoutArticleInput, NavbarItemUncheckedUpdateWithoutArticleInput>
  }

  export type NavbarItemUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutNavItemNestedInput
    page?: PageUpdateOneWithoutNavbarItemNestedInput
  }

  export type NavbarItemUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDropdown?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemNestedInput
    dropdownGroups?: DropDownGroupUncheckedUpdateManyWithoutNavItemNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutNavItemNestedInput
  }

  export type DropdownItemUpsertWithoutArticleInput = {
    update: XOR<DropdownItemUpdateWithoutArticleInput, DropdownItemUncheckedUpdateWithoutArticleInput>
    create: XOR<DropdownItemCreateWithoutArticleInput, DropdownItemUncheckedCreateWithoutArticleInput>
    where?: DropdownItemWhereInput
  }

  export type DropdownItemUpdateToOneWithWhereWithoutArticleInput = {
    where?: DropdownItemWhereInput
    data: XOR<DropdownItemUpdateWithoutArticleInput, DropdownItemUncheckedUpdateWithoutArticleInput>
  }

  export type DropdownItemUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUpdateManyWithoutDropdownItemNestedInput
    group?: DropDownGroupUpdateOneWithoutDropdownItemsNestedInput
    page?: PageUpdateOneWithoutDropdownItemNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownItemsNestedInput
  }

  export type DropdownItemUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemNestedInput
  }

  export type LanguageCreateWithoutArticlesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutArticlesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutArticlesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutArticlesInput, LanguageUncheckedCreateWithoutArticlesInput>
  }

  export type UserCreateWithoutArticlesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutArticlesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutTranslationsInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutTranslationsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutTranslationsInput, ArticleUncheckedCreateWithoutTranslationsInput>
  }

  export type BlockCreateWithoutArticleInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Page?: PageTranslationCreateNestedOneWithoutBlocksInput
    categoryService?: CategoryServiceTranslationCreateNestedOneWithoutBlocksInput
    service?: ServiceTranslationCreateNestedOneWithoutBlocksInput
  }

  export type BlockUncheckedCreateWithoutArticleInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    categoryServiceId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutArticleInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutArticleInput, BlockUncheckedCreateWithoutArticleInput>
  }

  export type BlockCreateManyArticleInputEnvelope = {
    data: BlockCreateManyArticleInput | BlockCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type LanguageUpsertWithoutArticlesInput = {
    update: XOR<LanguageUpdateWithoutArticlesInput, LanguageUncheckedUpdateWithoutArticlesInput>
    create: XOR<LanguageCreateWithoutArticlesInput, LanguageUncheckedCreateWithoutArticlesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutArticlesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutArticlesInput, LanguageUncheckedUpdateWithoutArticlesInput>
  }

  export type LanguageUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type UserUpsertWithoutArticlesInput = {
    update: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ArticleUpsertWithoutTranslationsInput = {
    update: XOR<ArticleUpdateWithoutTranslationsInput, ArticleUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ArticleCreateWithoutTranslationsInput, ArticleUncheckedCreateWithoutTranslationsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutTranslationsInput, ArticleUncheckedUpdateWithoutTranslationsInput>
  }

  export type ArticleUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type BlockUpsertWithWhereUniqueWithoutArticleInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutArticleInput, BlockUncheckedUpdateWithoutArticleInput>
    create: XOR<BlockCreateWithoutArticleInput, BlockUncheckedCreateWithoutArticleInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutArticleInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutArticleInput, BlockUncheckedUpdateWithoutArticleInput>
  }

  export type BlockUpdateManyWithWhereWithoutArticleInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutArticleInput>
  }

  export type TagTranslationCreateWithoutTagInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutTagsInput
  }

  export type TagTranslationUncheckedCreateWithoutTagInput = {
    id?: string
    lang: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationCreateOrConnectWithoutTagInput = {
    where: TagTranslationWhereUniqueInput
    create: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput>
  }

  export type TagTranslationCreateManyTagInputEnvelope = {
    data: TagTranslationCreateManyTagInput | TagTranslationCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutTagsInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutTagsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput>
  }

  export type TagTranslationUpsertWithWhereUniqueWithoutTagInput = {
    where: TagTranslationWhereUniqueInput
    update: XOR<TagTranslationUpdateWithoutTagInput, TagTranslationUncheckedUpdateWithoutTagInput>
    create: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput>
  }

  export type TagTranslationUpdateWithWhereUniqueWithoutTagInput = {
    where: TagTranslationWhereUniqueInput
    data: XOR<TagTranslationUpdateWithoutTagInput, TagTranslationUncheckedUpdateWithoutTagInput>
  }

  export type TagTranslationUpdateManyWithWhereWithoutTagInput = {
    where: TagTranslationScalarWhereInput
    data: XOR<TagTranslationUpdateManyMutationInput, TagTranslationUncheckedUpdateManyWithoutTagInput>
  }

  export type ArticleUpsertWithWhereUniqueWithoutTagsInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutTagsInput, ArticleUncheckedUpdateWithoutTagsInput>
    create: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutTagsInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutTagsInput, ArticleUncheckedUpdateWithoutTagsInput>
  }

  export type ArticleUpdateManyWithWhereWithoutTagsInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutTagsInput>
  }

  export type LanguageCreateWithoutTagsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutTagsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutTagsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutTagsInput, LanguageUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutTranslationsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutTagsInput = {
    update: XOR<LanguageUpdateWithoutTagsInput, LanguageUncheckedUpdateWithoutTagsInput>
    create: XOR<LanguageCreateWithoutTagsInput, LanguageUncheckedCreateWithoutTagsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutTagsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutTagsInput, LanguageUncheckedUpdateWithoutTagsInput>
  }

  export type LanguageUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type TagUpsertWithoutTranslationsInput = {
    update: XOR<TagUpdateWithoutTranslationsInput, TagUncheckedUpdateWithoutTranslationsInput>
    create: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTranslationsInput, TagUncheckedUpdateWithoutTranslationsInput>
  }

  export type TagUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type CommentTranslationCreateWithoutCommentInput = {
    id?: string
    name?: string | null
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCommentsInput
    author?: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentTranslationUncheckedCreateWithoutCommentInput = {
    id?: string
    lang: string
    userId?: string | null
    name?: string | null
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationCreateOrConnectWithoutCommentInput = {
    where: CommentTranslationWhereUniqueInput
    create: XOR<CommentTranslationCreateWithoutCommentInput, CommentTranslationUncheckedCreateWithoutCommentInput>
  }

  export type CommentTranslationCreateManyCommentInputEnvelope = {
    data: CommentTranslationCreateManyCommentInput | CommentTranslationCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    category?: CategoryCreateNestedOneWithoutArticlesInput
    tags?: TagCreateNestedManyWithoutArticlesInput
    footer?: FooterCreateNestedOneWithoutArticlesInput
    groupfooter?: GroupFooterCreateNestedOneWithoutArticlesInput
    navbarItem?: NavbarItemCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemCreateNestedOneWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCommentsInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    tags?: TagUncheckedCreateNestedManyWithoutArticlesInput
    navbarItem?: NavbarItemUncheckedCreateNestedOneWithoutArticleInput
    dropdownItem?: DropdownItemUncheckedCreateNestedOneWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCommentsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
  }

  export type CommentTranslationUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentTranslationWhereUniqueInput
    update: XOR<CommentTranslationUpdateWithoutCommentInput, CommentTranslationUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentTranslationCreateWithoutCommentInput, CommentTranslationUncheckedCreateWithoutCommentInput>
  }

  export type CommentTranslationUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentTranslationWhereUniqueInput
    data: XOR<CommentTranslationUpdateWithoutCommentInput, CommentTranslationUncheckedUpdateWithoutCommentInput>
  }

  export type CommentTranslationUpdateManyWithWhereWithoutCommentInput = {
    where: CommentTranslationScalarWhereInput
    data: XOR<CommentTranslationUpdateManyMutationInput, CommentTranslationUncheckedUpdateManyWithoutCommentInput>
  }

  export type ArticleUpsertWithoutCommentsInput = {
    update: XOR<ArticleUpdateWithoutCommentsInput, ArticleUncheckedUpdateWithoutCommentsInput>
    create: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutCommentsInput, ArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type ArticleUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type LanguageCreateWithoutCommentsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutCommentsInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutCommentsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutCommentsInput, LanguageUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type CommentCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    article: ArticleCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTranslationsInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTranslationsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTranslationsInput, CommentUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutCommentsInput = {
    update: XOR<LanguageUpdateWithoutCommentsInput, LanguageUncheckedUpdateWithoutCommentsInput>
    create: XOR<LanguageCreateWithoutCommentsInput, LanguageUncheckedCreateWithoutCommentsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutCommentsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutCommentsInput, LanguageUncheckedUpdateWithoutCommentsInput>
  }

  export type LanguageUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CommentUpsertWithoutTranslationsInput = {
    update: XOR<CommentUpdateWithoutTranslationsInput, CommentUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CommentCreateWithoutTranslationsInput, CommentUncheckedCreateWithoutTranslationsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutTranslationsInput, CommentUncheckedUpdateWithoutTranslationsInput>
  }

  export type CommentUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationCreateWithoutBlocksInput = {
    id?: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutPagesInput
    author: UserCreateNestedOneWithoutPagesInput
    page: PageCreateNestedOneWithoutTranslationsInput
  }

  export type PageTranslationUncheckedCreateWithoutBlocksInput = {
    id?: string
    lang: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTranslationCreateOrConnectWithoutBlocksInput = {
    where: PageTranslationWhereUniqueInput
    create: XOR<PageTranslationCreateWithoutBlocksInput, PageTranslationUncheckedCreateWithoutBlocksInput>
  }

  export type ArticleTranslationCreateWithoutBlocksInput = {
    id?: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutArticlesInput
    article: ArticleCreateNestedOneWithoutTranslationsInput
  }

  export type ArticleTranslationUncheckedCreateWithoutBlocksInput = {
    id?: string
    lang: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleTranslationCreateOrConnectWithoutBlocksInput = {
    where: ArticleTranslationWhereUniqueInput
    create: XOR<ArticleTranslationCreateWithoutBlocksInput, ArticleTranslationUncheckedCreateWithoutBlocksInput>
  }

  export type CategoryServiceTranslationCreateWithoutBlocksInput = {
    id?: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCategoriesServicesInput
    categoryService: CategoryServiceCreateNestedOneWithoutTranslationsInput
  }

  export type CategoryServiceTranslationUncheckedCreateWithoutBlocksInput = {
    id?: string
    lang: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    categoryServiceId: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryServiceTranslationCreateOrConnectWithoutBlocksInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    create: XOR<CategoryServiceTranslationCreateWithoutBlocksInput, CategoryServiceTranslationUncheckedCreateWithoutBlocksInput>
  }

  export type ServiceTranslationCreateWithoutBlocksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutTranslationsInput
  }

  export type ServiceTranslationUncheckedCreateWithoutBlocksInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTranslationCreateOrConnectWithoutBlocksInput = {
    where: ServiceTranslationWhereUniqueInput
    create: XOR<ServiceTranslationCreateWithoutBlocksInput, ServiceTranslationUncheckedCreateWithoutBlocksInput>
  }

  export type PageTranslationUpsertWithoutBlocksInput = {
    update: XOR<PageTranslationUpdateWithoutBlocksInput, PageTranslationUncheckedUpdateWithoutBlocksInput>
    create: XOR<PageTranslationCreateWithoutBlocksInput, PageTranslationUncheckedCreateWithoutBlocksInput>
    where?: PageTranslationWhereInput
  }

  export type PageTranslationUpdateToOneWithWhereWithoutBlocksInput = {
    where?: PageTranslationWhereInput
    data: XOR<PageTranslationUpdateWithoutBlocksInput, PageTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type PageTranslationUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutPagesNestedInput
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    page?: PageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PageTranslationUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleTranslationUpsertWithoutBlocksInput = {
    update: XOR<ArticleTranslationUpdateWithoutBlocksInput, ArticleTranslationUncheckedUpdateWithoutBlocksInput>
    create: XOR<ArticleTranslationCreateWithoutBlocksInput, ArticleTranslationUncheckedCreateWithoutBlocksInput>
    where?: ArticleTranslationWhereInput
  }

  export type ArticleTranslationUpdateToOneWithWhereWithoutBlocksInput = {
    where?: ArticleTranslationWhereInput
    data: XOR<ArticleTranslationUpdateWithoutBlocksInput, ArticleTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type ArticleTranslationUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ArticleTranslationUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceTranslationUpsertWithoutBlocksInput = {
    update: XOR<CategoryServiceTranslationUpdateWithoutBlocksInput, CategoryServiceTranslationUncheckedUpdateWithoutBlocksInput>
    create: XOR<CategoryServiceTranslationCreateWithoutBlocksInput, CategoryServiceTranslationUncheckedCreateWithoutBlocksInput>
    where?: CategoryServiceTranslationWhereInput
  }

  export type CategoryServiceTranslationUpdateToOneWithWhereWithoutBlocksInput = {
    where?: CategoryServiceTranslationWhereInput
    data: XOR<CategoryServiceTranslationUpdateWithoutBlocksInput, CategoryServiceTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type CategoryServiceTranslationUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCategoriesServicesNestedInput
    categoryService?: CategoryServiceUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CategoryServiceTranslationUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    categoryServiceId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTranslationUpsertWithoutBlocksInput = {
    update: XOR<ServiceTranslationUpdateWithoutBlocksInput, ServiceTranslationUncheckedUpdateWithoutBlocksInput>
    create: XOR<ServiceTranslationCreateWithoutBlocksInput, ServiceTranslationUncheckedCreateWithoutBlocksInput>
    where?: ServiceTranslationWhereInput
  }

  export type ServiceTranslationUpdateToOneWithWhereWithoutBlocksInput = {
    where?: ServiceTranslationWhereInput
    data: XOR<ServiceTranslationUpdateWithoutBlocksInput, ServiceTranslationUncheckedUpdateWithoutBlocksInput>
  }

  export type ServiceTranslationUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ServiceTranslationUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateWithoutCategoryServiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ServiceTranslationCreateNestedManyWithoutServiceInput
    orders?: OrderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryServiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ServiceTranslationUncheckedCreateNestedManyWithoutServiceInput
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryServiceInput, ServiceUncheckedCreateWithoutCategoryServiceInput>
  }

  export type ServiceCreateManyCategoryServiceInputEnvelope = {
    data: ServiceCreateManyCategoryServiceInput | ServiceCreateManyCategoryServiceInput[]
    skipDuplicates?: boolean
  }

  export type CategoryServiceTranslationCreateWithoutCategoryServiceInput = {
    id?: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutCategoriesServicesInput
    blocks?: BlockCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput = {
    id?: string
    lang: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceTranslationCreateOrConnectWithoutCategoryServiceInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    create: XOR<CategoryServiceTranslationCreateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput>
  }

  export type CategoryServiceTranslationCreateManyCategoryServiceInputEnvelope = {
    data: CategoryServiceTranslationCreateManyCategoryServiceInput | CategoryServiceTranslationCreateManyCategoryServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryServiceInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryServiceInput, ServiceUncheckedUpdateWithoutCategoryServiceInput>
    create: XOR<ServiceCreateWithoutCategoryServiceInput, ServiceUncheckedCreateWithoutCategoryServiceInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryServiceInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryServiceInput, ServiceUncheckedUpdateWithoutCategoryServiceInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryServiceInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryServiceInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    categoryId?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type CategoryServiceTranslationUpsertWithWhereUniqueWithoutCategoryServiceInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    update: XOR<CategoryServiceTranslationUpdateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedUpdateWithoutCategoryServiceInput>
    create: XOR<CategoryServiceTranslationCreateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedCreateWithoutCategoryServiceInput>
  }

  export type CategoryServiceTranslationUpdateWithWhereUniqueWithoutCategoryServiceInput = {
    where: CategoryServiceTranslationWhereUniqueInput
    data: XOR<CategoryServiceTranslationUpdateWithoutCategoryServiceInput, CategoryServiceTranslationUncheckedUpdateWithoutCategoryServiceInput>
  }

  export type CategoryServiceTranslationUpdateManyWithWhereWithoutCategoryServiceInput = {
    where: CategoryServiceTranslationScalarWhereInput
    data: XOR<CategoryServiceTranslationUpdateManyMutationInput, CategoryServiceTranslationUncheckedUpdateManyWithoutCategoryServiceInput>
  }

  export type LanguageCreateWithoutCategoriesServicesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutCategoriesServicesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    services?: ServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutCategoriesServicesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutCategoriesServicesInput, LanguageUncheckedCreateWithoutCategoriesServicesInput>
  }

  export type CategoryServiceCreateWithoutTranslationsInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceUncheckedCreateWithoutTranslationsInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceCreateOrConnectWithoutTranslationsInput = {
    where: CategoryServiceWhereUniqueInput
    create: XOR<CategoryServiceCreateWithoutTranslationsInput, CategoryServiceUncheckedCreateWithoutTranslationsInput>
  }

  export type BlockCreateWithoutCategoryServiceInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Page?: PageTranslationCreateNestedOneWithoutBlocksInput
    article?: ArticleTranslationCreateNestedOneWithoutBlocksInput
    service?: ServiceTranslationCreateNestedOneWithoutBlocksInput
  }

  export type BlockUncheckedCreateWithoutCategoryServiceInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    articleId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutCategoryServiceInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutCategoryServiceInput, BlockUncheckedCreateWithoutCategoryServiceInput>
  }

  export type BlockCreateManyCategoryServiceInputEnvelope = {
    data: BlockCreateManyCategoryServiceInput | BlockCreateManyCategoryServiceInput[]
    skipDuplicates?: boolean
  }

  export type LanguageUpsertWithoutCategoriesServicesInput = {
    update: XOR<LanguageUpdateWithoutCategoriesServicesInput, LanguageUncheckedUpdateWithoutCategoriesServicesInput>
    create: XOR<LanguageCreateWithoutCategoriesServicesInput, LanguageUncheckedCreateWithoutCategoriesServicesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutCategoriesServicesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutCategoriesServicesInput, LanguageUncheckedUpdateWithoutCategoriesServicesInput>
  }

  export type LanguageUpdateWithoutCategoriesServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutCategoriesServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    services?: ServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type CategoryServiceUpsertWithoutTranslationsInput = {
    update: XOR<CategoryServiceUpdateWithoutTranslationsInput, CategoryServiceUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CategoryServiceCreateWithoutTranslationsInput, CategoryServiceUncheckedCreateWithoutTranslationsInput>
    where?: CategoryServiceWhereInput
  }

  export type CategoryServiceUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CategoryServiceWhereInput
    data: XOR<CategoryServiceUpdateWithoutTranslationsInput, CategoryServiceUncheckedUpdateWithoutTranslationsInput>
  }

  export type CategoryServiceUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryServiceNestedInput
  }

  export type BlockUpsertWithWhereUniqueWithoutCategoryServiceInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutCategoryServiceInput, BlockUncheckedUpdateWithoutCategoryServiceInput>
    create: XOR<BlockCreateWithoutCategoryServiceInput, BlockUncheckedCreateWithoutCategoryServiceInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutCategoryServiceInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutCategoryServiceInput, BlockUncheckedUpdateWithoutCategoryServiceInput>
  }

  export type BlockUpdateManyWithWhereWithoutCategoryServiceInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutCategoryServiceInput>
  }

  export type CategoryServiceCreateWithoutServicesInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryServiceTranslationCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceUncheckedCreateWithoutServicesInput = {
    id?: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutCategoryServiceInput
  }

  export type CategoryServiceCreateOrConnectWithoutServicesInput = {
    where: CategoryServiceWhereUniqueInput
    create: XOR<CategoryServiceCreateWithoutServicesInput, CategoryServiceUncheckedCreateWithoutServicesInput>
  }

  export type ServiceTranslationCreateWithoutServiceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutServicesInput
    blocks?: BlockCreateNestedManyWithoutServiceInput
  }

  export type ServiceTranslationUncheckedCreateWithoutServiceInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: BlockUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceTranslationCreateOrConnectWithoutServiceInput = {
    where: ServiceTranslationWhereUniqueInput
    create: XOR<ServiceTranslationCreateWithoutServiceInput, ServiceTranslationUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTranslationCreateManyServiceInputEnvelope = {
    data: ServiceTranslationCreateManyServiceInput | ServiceTranslationCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutServiceInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutServiceInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    studentId?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutServiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
  }

  export type OrderCreateManyServiceInputEnvelope = {
    data: OrderCreateManyServiceInput | OrderCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type CategoryServiceUpsertWithoutServicesInput = {
    update: XOR<CategoryServiceUpdateWithoutServicesInput, CategoryServiceUncheckedUpdateWithoutServicesInput>
    create: XOR<CategoryServiceCreateWithoutServicesInput, CategoryServiceUncheckedCreateWithoutServicesInput>
    where?: CategoryServiceWhereInput
  }

  export type CategoryServiceUpdateToOneWithWhereWithoutServicesInput = {
    where?: CategoryServiceWhereInput
    data: XOR<CategoryServiceUpdateWithoutServicesInput, CategoryServiceUncheckedUpdateWithoutServicesInput>
  }

  export type CategoryServiceUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryServiceTranslationUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryServiceTranslationUncheckedUpdateManyWithoutCategoryServiceNestedInput
  }

  export type ServiceTranslationUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceTranslationWhereUniqueInput
    update: XOR<ServiceTranslationUpdateWithoutServiceInput, ServiceTranslationUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceTranslationCreateWithoutServiceInput, ServiceTranslationUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTranslationUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceTranslationWhereUniqueInput
    data: XOR<ServiceTranslationUpdateWithoutServiceInput, ServiceTranslationUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceTranslationUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceTranslationScalarWhereInput
    data: XOR<ServiceTranslationUpdateManyMutationInput, ServiceTranslationUncheckedUpdateManyWithoutServiceInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutServiceInput, OrderUncheckedUpdateWithoutServiceInput>
    create: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutServiceInput, OrderUncheckedUpdateWithoutServiceInput>
  }

  export type OrderUpdateManyWithWhereWithoutServiceInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutServiceInput>
  }

  export type LanguageCreateWithoutServicesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutServicesInput = {
    id?: string
    label: string
    language: string
    common: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedCreateNestedManyWithoutLanguageInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoreis?: CategoryTranslationUncheckedCreateNestedManyWithoutLanguageInput
    categoriesServices?: CategoryServiceTranslationUncheckedCreateNestedManyWithoutLanguageInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutLanguageInput
    tags?: TagTranslationUncheckedCreateNestedManyWithoutLanguageInput
    comments?: CommentTranslationUncheckedCreateNestedManyWithoutLanguageInput
    navbarItems?: NavbarItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownGroups?: DropDownGroupTranslationUncheckedCreateNestedManyWithoutLanguageInput
    dropdownItems?: DropdownItemTranslationUncheckedCreateNestedManyWithoutLanguageInput
    footers?: FooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
    groupFooters?: GroupFooterTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutServicesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutServicesInput, LanguageUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CategoryService: CategoryServiceCreateNestedOneWithoutServicesInput
    orders?: OrderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutTranslationsInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutTranslationsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTranslationsInput, ServiceUncheckedCreateWithoutTranslationsInput>
  }

  export type BlockCreateWithoutServiceInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Page?: PageTranslationCreateNestedOneWithoutBlocksInput
    article?: ArticleTranslationCreateNestedOneWithoutBlocksInput
    categoryService?: CategoryServiceTranslationCreateNestedOneWithoutBlocksInput
  }

  export type BlockUncheckedCreateWithoutServiceInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    articleId?: string | null
    categoryServiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutServiceInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutServiceInput, BlockUncheckedCreateWithoutServiceInput>
  }

  export type BlockCreateManyServiceInputEnvelope = {
    data: BlockCreateManyServiceInput | BlockCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type LanguageUpsertWithoutServicesInput = {
    update: XOR<LanguageUpdateWithoutServicesInput, LanguageUncheckedUpdateWithoutServicesInput>
    create: XOR<LanguageCreateWithoutServicesInput, LanguageUncheckedCreateWithoutServicesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutServicesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutServicesInput, LanguageUncheckedUpdateWithoutServicesInput>
  }

  export type LanguageUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    common?: JsonNullValueInput | InputJsonValue
    globals?: GlobalTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoreis?: CategoryTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    categoriesServices?: CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    tags?: TagTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    comments?: CommentTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    navbarItems?: NavbarItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownGroups?: DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    dropdownItems?: DropdownItemTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    footers?: FooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
    groupFooters?: GroupFooterTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type ServiceUpsertWithoutTranslationsInput = {
    update: XOR<ServiceUpdateWithoutTranslationsInput, ServiceUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ServiceCreateWithoutTranslationsInput, ServiceUncheckedCreateWithoutTranslationsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutTranslationsInput, ServiceUncheckedUpdateWithoutTranslationsInput>
  }

  export type ServiceUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CategoryService?: CategoryServiceUpdateOneRequiredWithoutServicesNestedInput
    orders?: OrderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BlockUpsertWithWhereUniqueWithoutServiceInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutServiceInput, BlockUncheckedUpdateWithoutServiceInput>
    create: XOR<BlockCreateWithoutServiceInput, BlockUncheckedCreateWithoutServiceInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutServiceInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutServiceInput, BlockUncheckedUpdateWithoutServiceInput>
  }

  export type BlockUpdateManyWithWhereWithoutServiceInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pages?: PageTranslationCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pages?: PageTranslationUncheckedCreateNestedManyWithoutAuthorInput
    articles?: ArticleTranslationUncheckedCreateNestedManyWithoutAuthorInput
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentTranslationUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type ServiceCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CategoryService: CategoryServiceCreateNestedOneWithoutServicesInput
    translations?: ServiceTranslationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutOrdersInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ServiceTranslationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutOrdersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    articles?: ArticleTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    categories?: CategoryTranslationUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentTranslationUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ServiceUpsertWithoutOrdersInput = {
    update: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type ServiceUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CategoryService?: CategoryServiceUpdateOneRequiredWithoutServicesNestedInput
    translations?: ServiceTranslationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ServiceTranslationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type PageTranslationCreateManyAuthorInput = {
    id?: string
    lang: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleTranslationCreateManyAuthorInput = {
    id?: string
    lang: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationCreateManyAuthorInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationCreateManyAuthorInput = {
    id?: string
    lang: string
    name?: string | null
    body: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyStudentInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    serviceId?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutPagesNestedInput
    blocks?: BlockUpdateManyWithoutPageNestedInput
    page?: PageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PageTranslationUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageTranslationUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleTranslationUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCategoreisNestedInput
    category?: CategoryUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CategoryTranslationUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCommentsNestedInput
    comment?: CommentUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CommentTranslationUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationCreateManyLanguageInput = {
    id?: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    globalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTranslationCreateManyLanguageInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    pageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationCreateManyLanguageInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryServiceTranslationCreateManyLanguageInput = {
    id?: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    categoryServiceId: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTranslationCreateManyLanguageInput = {
    id?: string
    name: string
    description?: string | null
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleTranslationCreateManyLanguageInput = {
    id?: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    articleId: string
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationCreateManyLanguageInput = {
    id?: string
    tagId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationCreateManyLanguageInput = {
    id?: string
    userId?: string | null
    name?: string | null
    body: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemTranslationCreateManyLanguageInput = {
    id?: string
    name: string
    navbarItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupTranslationCreateManyLanguageInput = {
    id?: string
    name: string
    dropdownGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemTranslationCreateManyLanguageInput = {
    id?: string
    name: string
    dropdownItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterTranslationCreateManyLanguageInput = {
    id?: string
    footerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterTranslationCreateManyLanguageInput = {
    id?: string
    title?: string | null
    groupfooterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    global?: GlobalUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type GlobalTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    globalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    globalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    blocks?: BlockUpdateManyWithoutPageNestedInput
    page?: PageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PageTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    pageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CategoryTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryService?: CategoryServiceUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    categoryServiceId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    categoryServiceId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneRequiredWithoutTranslationsNestedInput
    blocks?: BlockUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: StringFieldUpdateOperationsInput | string
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TagTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutCommentNestedInput
    comment?: CommentUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CommentTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    navbarItem?: NavbarItemUpdateOneWithoutTranslationsNestedInput
  }

  export type NavbarItemTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    navbarItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    navbarItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropdownGroup?: DropDownGroupUpdateOneWithoutTranslationsNestedInput
  }

  export type DropDownGroupTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dropdownGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dropdownGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropdownItem?: DropdownItemUpdateOneWithoutTranslationsNestedInput
  }

  export type DropdownItemTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dropdownItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dropdownItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footer?: FooterUpdateOneWithoutTranslationsNestedInput
  }

  export type FooterTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupfooter?: GroupFooterUpdateOneWithoutTranslationsNestedInput
  }

  export type GroupFooterTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationCreateManyGlobalInput = {
    id?: string
    lang: string
    name?: string | null
    logo?: string | null
    favicon?: string | null
    images?: GlobalTranslationCreateimagesInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinkCreateManyGlobalInput = {
    id?: string
    social: string
    url: string
  }

  export type GlobalTranslationUpdateWithoutGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutGlobalsNestedInput
  }

  export type GlobalTranslationUncheckedUpdateWithoutGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalTranslationUncheckedUpdateManyWithoutGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    images?: GlobalTranslationUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkUpdateWithoutGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateWithoutGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateManyWithoutGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    social?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type NavbarItemTranslationCreateManyNavbarItemInput = {
    id?: string
    name: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupCreateManyNavItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemCreateManyNavItemInput = {
    id?: string
    groupId?: string | null
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavbarItemTranslationUpdateWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutNavbarItemsNestedInput
  }

  export type NavbarItemTranslationUncheckedUpdateWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavbarItemTranslationUncheckedUpdateManyWithoutNavbarItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupUpdateWithoutNavItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropDownGroupTranslationUpdateManyWithoutDropdownGroupNestedInput
    dropdownItems?: DropdownItemUpdateManyWithoutGroupNestedInput
  }

  export type DropDownGroupUncheckedUpdateWithoutNavItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropDownGroupTranslationUncheckedUpdateManyWithoutDropdownGroupNestedInput
    dropdownItems?: DropdownItemUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type DropDownGroupUncheckedUpdateManyWithoutNavItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemUpdateWithoutNavItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUpdateManyWithoutDropdownItemNestedInput
    group?: DropDownGroupUpdateOneWithoutDropdownItemsNestedInput
    page?: PageUpdateOneWithoutDropdownItemNestedInput
    article?: ArticleUpdateOneWithoutDropdownItemNestedInput
  }

  export type DropdownItemUncheckedUpdateWithoutNavItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemNestedInput
  }

  export type DropdownItemUncheckedUpdateManyWithoutNavItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationCreateManyDropdownGroupInput = {
    id?: string
    name: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemCreateManyGroupInput = {
    id?: string
    pageId?: string | null
    forGroup?: boolean
    forArticle?: boolean
    forPage?: boolean
    articleId?: string | null
    navItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropDownGroupTranslationUpdateWithoutDropdownGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutDropdownGroupsNestedInput
  }

  export type DropDownGroupTranslationUncheckedUpdateWithoutDropdownGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropDownGroupTranslationUncheckedUpdateManyWithoutDropdownGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUpdateManyWithoutDropdownItemNestedInput
    page?: PageUpdateOneWithoutDropdownItemNestedInput
    article?: ArticleUpdateOneWithoutDropdownItemNestedInput
    navItem?: NavbarItemUpdateOneWithoutDropdownItemsNestedInput
  }

  export type DropdownItemUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemNestedInput
  }

  export type DropdownItemUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    forGroup?: BoolFieldUpdateOperationsInput | boolean
    forArticle?: BoolFieldUpdateOperationsInput | boolean
    forPage?: BoolFieldUpdateOperationsInput | boolean
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    navItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationCreateManyDropdownItemInput = {
    id?: string
    name: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownItemTranslationUpdateWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutDropdownItemsNestedInput
  }

  export type DropdownItemTranslationUncheckedUpdateWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownItemTranslationUncheckedUpdateManyWithoutDropdownItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationCreateManyFooterInput = {
    id?: string
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterCreateManyFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateManyFooterInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupfooterId?: string | null
  }

  export type FooterTranslationUpdateWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutFootersNestedInput
  }

  export type FooterTranslationUncheckedUpdateWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterTranslationUncheckedUpdateManyWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterUpdateWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUpdateManyWithoutGroupfooterNestedInput
    articles?: ArticleUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUpdateManyWithoutGroupFooterNestedInput
  }

  export type GroupFooterUncheckedUpdateWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupfooterNestedInput
    pages?: PageUncheckedUpdateManyWithoutGroupFooterNestedInput
  }

  export type GroupFooterUncheckedUpdateManyWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupFooterTranslationCreateManyGroupfooterInput = {
    id?: string
    title?: string | null
    lang: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateManyGroupfooterInput = {
    id?: string
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
  }

  export type PageCreateManyGroupFooterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupFooterTranslationUpdateWithoutGroupfooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutGroupFootersNestedInput
  }

  export type GroupFooterTranslationUncheckedUpdateWithoutGroupfooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupFooterTranslationUncheckedUpdateManyWithoutGroupfooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutGroupfooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutGroupfooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutGroupfooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageUpdateWithoutGroupFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutPageNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutGroupFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutPageNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutGroupFooterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationCreateManyPageInput = {
    id?: string
    lang: string
    userId: string
    title: string
    description?: string | null
    images?: PageTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTranslationUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutPagesNestedInput
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    blocks?: BlockUpdateManyWithoutPageNestedInput
  }

  export type PageTranslationUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageTranslationUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: PageTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyPageInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    articleId?: string | null
    categoryServiceId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleTranslationUpdateOneWithoutBlocksNestedInput
    categoryService?: CategoryServiceTranslationUpdateOneWithoutBlocksNestedInput
    service?: ServiceTranslationUpdateOneWithoutBlocksNestedInput
  }

  export type BlockUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationCreateManyCategoryInput = {
    id?: string
    lang: string
    userId: string
    name: string
    description?: string | null
    images?: CategoryTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateManyCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    footerId?: string | null
    groupfooterId?: string | null
  }

  export type CategoryTranslationUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCategoreisNestedInput
    author?: UserUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoryTranslationUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    tags?: TagUpdateManyWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    tags?: TagUncheckedUpdateManyWithoutArticlesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleTranslationCreateManyArticleInput = {
    id?: string
    lang: string
    userId: string
    slug?: string | null
    published?: boolean
    title?: string | null
    description?: string | null
    images?: ArticleTranslationCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyArticleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleTranslationUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    blocks?: BlockUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleTranslationUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TagTranslationUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TagTranslationUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CommentTranslationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CommentTranslationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyArticleInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    categoryServiceId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Page?: PageTranslationUpdateOneWithoutBlocksNestedInput
    categoryService?: CategoryServiceTranslationUpdateOneWithoutBlocksNestedInput
    service?: ServiceTranslationUpdateOneWithoutBlocksNestedInput
  }

  export type BlockUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationCreateManyTagInput = {
    id?: string
    lang: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagTranslationUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    category?: CategoryUpdateOneWithoutArticlesNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    footer?: FooterUpdateOneWithoutArticlesNestedInput
    groupfooter?: GroupFooterUpdateOneWithoutArticlesNestedInput
    navbarItem?: NavbarItemUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    navbarItem?: NavbarItemUncheckedUpdateOneWithoutArticleNestedInput
    dropdownItem?: DropdownItemUncheckedUpdateOneWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerId?: NullableStringFieldUpdateOperationsInput | string | null
    groupfooterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentTranslationCreateManyCommentInput = {
    id?: string
    lang: string
    userId?: string | null
    name?: string | null
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentTranslationUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneWithoutCommentNestedInput
  }

  export type CommentTranslationUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentTranslationUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyCategoryServiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryServiceTranslationCreateManyCategoryServiceInput = {
    id?: string
    lang: string
    name: string
    descriprion?: string | null
    images?: CategoryServiceTranslationCreateimagesInput | string[]
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ServiceTranslationUpdateManyWithoutServiceNestedInput
    orders?: OrderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ServiceTranslationUncheckedUpdateManyWithoutServiceNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryServiceTranslationUpdateWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutCategoriesServicesNestedInput
    blocks?: BlockUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceTranslationUncheckedUpdateWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutCategoryServiceNestedInput
  }

  export type CategoryServiceTranslationUncheckedUpdateManyWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriprion?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CategoryServiceTranslationUpdateimagesInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyCategoryServiceInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    articleId?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Page?: PageTranslationUpdateOneWithoutBlocksNestedInput
    article?: ArticleTranslationUpdateOneWithoutBlocksNestedInput
    service?: ServiceTranslationUpdateOneWithoutBlocksNestedInput
  }

  export type BlockUncheckedUpdateWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutCategoryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTranslationCreateManyServiceInput = {
    id?: string
    lang: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyServiceInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    studentId?: string | null
    DescriptionOtherService?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTranslationUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutServicesNestedInput
    blocks?: BlockUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTranslationUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: BlockUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTranslationUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    DescriptionOtherService?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyServiceInput = {
    id?: string
    type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: string | null
    articleId?: string | null
    categoryServiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Page?: PageTranslationUpdateOneWithoutBlocksNestedInput
    article?: ArticleTranslationUpdateOneWithoutBlocksNestedInput
    categoryService?: CategoryServiceTranslationUpdateOneWithoutBlocksNestedInput
  }

  export type BlockUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlobalCountOutputTypeDefaultArgs instead
     */
    export type GlobalCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GlobalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NavbarItemCountOutputTypeDefaultArgs instead
     */
    export type NavbarItemCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = NavbarItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropDownGroupCountOutputTypeDefaultArgs instead
     */
    export type DropDownGroupCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropDownGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropdownItemCountOutputTypeDefaultArgs instead
     */
    export type DropdownItemCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropdownItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FooterCountOutputTypeDefaultArgs instead
     */
    export type FooterCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FooterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupFooterCountOutputTypeDefaultArgs instead
     */
    export type GroupFooterCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GroupFooterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageCountOutputTypeDefaultArgs instead
     */
    export type PageCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageTranslationCountOutputTypeDefaultArgs instead
     */
    export type PageTranslationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PageTranslationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleCountOutputTypeDefaultArgs instead
     */
    export type ArticleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleTranslationCountOutputTypeDefaultArgs instead
     */
    export type ArticleTranslationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ArticleTranslationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryServiceCountOutputTypeDefaultArgs instead
     */
    export type CategoryServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryServiceTranslationCountOutputTypeDefaultArgs instead
     */
    export type CategoryServiceTranslationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryServiceTranslationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceTranslationCountOutputTypeDefaultArgs instead
     */
    export type ServiceTranslationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ServiceTranslationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlobalDefaultArgs instead
     */
    export type GlobalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GlobalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlobalTranslationDefaultArgs instead
     */
    export type GlobalTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GlobalTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SocialLinkDefaultArgs instead
     */
    export type SocialLinkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SocialLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NavbarItemDefaultArgs instead
     */
    export type NavbarItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = NavbarItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NavbarItemTranslationDefaultArgs instead
     */
    export type NavbarItemTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = NavbarItemTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropDownGroupDefaultArgs instead
     */
    export type DropDownGroupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropDownGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropDownGroupTranslationDefaultArgs instead
     */
    export type DropDownGroupTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropDownGroupTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropdownItemDefaultArgs instead
     */
    export type DropdownItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropdownItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropdownItemTranslationDefaultArgs instead
     */
    export type DropdownItemTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropdownItemTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FooterDefaultArgs instead
     */
    export type FooterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FooterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FooterTranslationDefaultArgs instead
     */
    export type FooterTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FooterTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupFooterDefaultArgs instead
     */
    export type GroupFooterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GroupFooterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupFooterTranslationDefaultArgs instead
     */
    export type GroupFooterTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GroupFooterTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageDefaultArgs instead
     */
    export type PageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageTranslationDefaultArgs instead
     */
    export type PageTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PageTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryTranslationDefaultArgs instead
     */
    export type CategoryTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleDefaultArgs instead
     */
    export type ArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleTranslationDefaultArgs instead
     */
    export type ArticleTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ArticleTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagTranslationDefaultArgs instead
     */
    export type TagTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TagTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentTranslationDefaultArgs instead
     */
    export type CommentTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CommentTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockDefaultArgs instead
     */
    export type BlockArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryServiceDefaultArgs instead
     */
    export type CategoryServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryServiceTranslationDefaultArgs instead
     */
    export type CategoryServiceTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryServiceTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceTranslationDefaultArgs instead
     */
    export type ServiceTranslationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ServiceTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}